{
  "1": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public int[] twoSum(int[] nums, int target) {\n        Map<Integer, Integer> numMap = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int complement = target - nums[i];\n            if (numMap.containsKey(complement)) {\n                return new int[] { numMap.get(complement), i };\n            }\n            numMap.put(nums[i], i);\n        }\n\n        return new int[0]; // Return an empty array if no valid pair is found\n    }\n}"
    }
  },
  "2": {
    "solution": {
      "linked-list": "/*\nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {\n        this.val = 0;\n    }\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n*/\n\nclass Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode();\n        ListNode current = dummy;\n        int carry = 0;\n\n        while (l1 != null || l2 != null || carry > 0) {\n            int sum = carry;\n\n            if (l1 != null) {\n                sum += l1.val;\n                l1 = l1.next;\n            }\n\n            if (l2 != null) {\n                sum += l2.val;\n                l2 = l2.next;\n            }\n\n            carry = sum / 10;\n            current.next = new ListNode(sum % 10);\n            current = current.next;\n        }\n\n        return dummy.next;\n    }\n}"
    }
  },
  "3": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int lengthOfLongestSubstring(String s) {\n        int[] charIndex = new int[128]; \n        int left = 0, right = 0, maxLength = 0;\n        int n = s.length();\n\n        while (right < n) {\n            char currentChar = s.charAt(right);\n            left = Math.max(charIndex[currentChar], left);\n            maxLength = Math.max(maxLength, right - left + 1);\n            charIndex[currentChar] = right + 1;\n            right++;\n        }\n\n        return maxLength;\n    }\n}"
    }
  },
  "4": {
    "solution": {
      "divide-and-conquer": "public class Solution {\n    public double findMedianSortedArrays(int[] nums1, int[] nums2) {\n        if (nums1.length > nums2.length) {\n            return findMedianSortedArrays(nums2, nums1);\n        }\n\n        int x = nums1.length;\n        int y = nums2.length;\n        int low = 0, high = x;\n\n        while (low <= high) {\n            int partitionX = (low + high) / 2;\n            int partitionY = (x + y + 1) / 2 - partitionX;\n\n            int maxX = (partitionX == 0) ? Integer.MIN_VALUE : nums1[partitionX - 1];\n            int minX = (partitionX == x) ? Integer.MAX_VALUE : nums1[partitionX];\n\n            int maxY = (partitionY == 0) ? Integer.MIN_VALUE : nums2[partitionY - 1];\n            int minY = (partitionY == y) ? Integer.MAX_VALUE : nums2[partitionY];\n\n            if (maxX <= minY && maxY <= minX) {\n                if ((x + y) % 2 == 0) {\n                    return ((double) Math.max(maxX, maxY) + Math.min(minX, minY)) / 2;\n                } else {\n                    return (double) Math.max(maxX, maxY);\n                }\n            } else if (maxX > minY) {\n                high = partitionX - 1;\n            } else {\n                low = partitionX + 1;\n            }\n        }\n\n        throw new IllegalArgumentException();\n    }\n}"
    }
  },
  "5": {
    "solution": {
      "two-pointers": "class Solution {\n\n    public String longestPalindrome(String s) {\n        if (s == null || s.length() == 0) {\n            return \"\";\n        }\n        int n = s.length();\n        int start = 0;\n        int maxLen = 1; \n        for (int i = 0; i < n; i++) {\n            int len1 = expandAroundCenter(s, i, i); // odd-length palindromes           \n            int len2 = expandAroundCenter(s, i, i + 1); // even-length palindromes\n            int maxLenCurr = Math.max(len1, len2);\n            if (maxLenCurr > maxLen) {\n                maxLen = maxLenCurr;\n                start = i - (maxLen - 1) / 2;\n            }\n        }\n        \n        return s.substring(start, start + maxLen);\n    }\n    \n    private int expandAroundCenter(String s, int left, int right) {\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            left--;\n            right++;\n        }\n        return right - left - 1;\n    }\n}\n"
    }
  },
  "6": {
    "solution": {
      "string": "class Solution {\n    public String convert(String s, int numRows) {\n        if (numRows == 1) return s;\n\n        List<StringBuilder> rows = new ArrayList<>();\n        for (int i = 0; i < Math.min(numRows, s.length()); i++) {\n            rows.add(new StringBuilder());\n        }\n\n        int currentRow = 0;\n        boolean goingDown = false;\n\n        for (char c : s.toCharArray()) {\n            rows.get(currentRow).append(c);\n            if (currentRow == 0 || currentRow == numRows - 1) {\n                goingDown = !goingDown;\n            }\n            currentRow += goingDown ? 1 : -1;\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (StringBuilder row : rows) {\n            result.append(row);\n        }\n\n        return result.toString();\n    }\n}"
    }
  },
  "7": {
    "solution": {
      "math": "class Solution {\n    public int reverse(int x) {\n        long reversed = 0;\n        while (x != 0) {\n            int digit = x % 10;\n            reversed = reversed * 10 + digit;\n            x /= 10;\n        }\n        if (reversed < Integer.MIN_VALUE || reversed > Integer.MAX_VALUE) {\n            return 0;\n        }\n        return (int) reversed;\n    }\n}"
    }
  },
  "8": {
    "solution": {
      "string": "class Solution {\n    public int myAtoi(String s) {\n        int index = 0;\n        int result = 0;\n        int sign = 1;\n\n        // Skip leading whitespaces\n        while (index < s.length() && s.charAt(index) == ' ') {\n            index++;\n        }\n\n        // Check for sign\n        if (index < s.length() && (s.charAt(index) == '+' || s.charAt(index) == '-')) {\n            sign = s.charAt(index) == '-' ? -1 : 1;\n            index++;\n        }\n\n        // Convert digits to integer\n        while (index < s.length() && Character.isDigit(s.charAt(index))) {\n            int digit = s.charAt(index) - '0';\n\n            // Check for overflow\n            if (result > (Integer.MAX_VALUE - digit) / 10) {\n                return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;\n            }\n\n            result = result * 10 + digit;\n            index++;\n        }\n\n        return result * sign;\n    }\n}"
    }
  },
  "9": {
    "solution": {
      "math": "class Solution {\n    public boolean isPalindrome(int x) {\n        if (x < 0 || (x % 10 == 0 && x != 0)) {\n            return false;\n        }\n\n        int reversed = 0, original = x;\n\n        while (x > 0) {\n            int digit = x % 10;\n            if (reversed > (Integer.MAX_VALUE - digit) / 10) {\n                return false;\n            }\n            reversed = reversed * 10 + digit;\n            x /= 10;\n        }\n\n        return original == reversed;\n    }\n}"
    }
  },
  "10": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        boolean dp[][] = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 2];\n            }\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (p.charAt(j - 1) == '.' || p.charAt(j - 1) == s.charAt(i - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i][j - 2] || \n                                (dp[i - 1][j] && (s.charAt(i - 1) == p.charAt(j - 2) || p.charAt(j - 2) == '.'));\n                }\n            }\n        }\n\n        System.out.println(Arrays.toString(dp));\n\n        return dp[m][n];\n    }\n}"
    }
  },
  "11": {
    "solution": {
      "two-pointers": "public class Solution {\n    public int maxArea(int[] height) {\n        int max = 0;\n        int left = 0;\n        int right = height.length - 1;\n\n        while (left < right) {\n            int currentArea = Math.min(height[left], height[right]) * (right - left);\n            max = Math.max(max, currentArea);\n\n            if (height[left] < height[right]) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return max;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] heights = {1, 2, 1};\n        System.out.println(solution.maxArea(heights)); // Output: 2\n    }\n}\n"
    }
  },
  "12": {
    "solution": {
      "math": "class Solution {\n    public String intToRoman(int num) {\n        int[] values = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n        String[] romans = {\"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"};\n\n        StringBuilder result = new StringBuilder();\n\n        for (int i = 0; i < values.length; i++) {\n            while (num >= values[i]) {\n                result.append(romans[i]);\n                num -= values[i];\n            }\n        }\n\n        return result.toString();\n    }\n}"
    }
  },
  "13": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public int romanToInt(String s) {\n        Map<Character, Integer> romanToValue = new HashMap<>();\n        romanToValue.put('I', 1);\n        romanToValue.put('V', 5);\n        romanToValue.put('X', 10);\n        romanToValue.put('L', 50);\n        romanToValue.put('C', 100);\n        romanToValue.put('D', 500);\n        romanToValue.put('M', 1000);\n\n        int total = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            int current = romanToValue.get(s.charAt(i));\n            int next = (i + 1 < s.length()) ? romanToValue.get(s.charAt(i + 1)) : 0;\n\n            if (current < next) {\n                total -= current;\n            } else {\n                total += current;\n            }\n        }\n\n        return total;\n    }\n}"
    }
  },
  "14": {
    "solution": {
      "string": "class TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n    int prefixCount;\n\n    public TrieNode() {\n        children = new TrieNode[26];\n        prefixCount = 0;\n    }\n}\n\nclass Solution {\n    private TrieNode root;\n    private int longestPrefixLength;\n    private int totalWords;\n\n    public void insert(String word) {\n        TrieNode currentNode = root;\n        int currentLength = 0;\n\n        for (int i = 0; i < word.length(); i++) {\n            int index = word.charAt(i) - 'a';\n            if (currentNode.children[index] == null) {\n                currentNode.children[index] = new TrieNode();\n            }\n            currentNode = currentNode.children[index];\n            currentNode.prefixCount++;\n            currentLength++;\n\n            if (currentNode.prefixCount == totalWords) {\n                longestPrefixLength = Math.max(longestPrefixLength, currentLength);\n            }\n        }\n    }\n\n    public String longestCommonPrefix(String[] strs) {\n        root = new TrieNode();\n        longestPrefixLength = 0;\n        totalWords = strs.length;\n\n        for (String str : strs) {\n            insert(str);\n        }\n\n        return longestPrefixLength > 0 ? strs[0].substring(0, longestPrefixLength) : \"\";\n    }\n}"
    }
  },
  "15": {
    "solution": {
      "two-pointers": "public class Solution {\n    public List<List<Integer>> threeSum(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            if (i == 0 || (i > 0 && nums[i] != nums[i - 1])) {\n                int left = i + 1, right = nums.length - 1, target = -nums[i];\n                while (left < right) {\n                    if (nums[left] + nums[right] == target) {\n                        result.add(Arrays.asList(nums[i], nums[left], nums[right]));\n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        left++;\n                        right--;\n                    } else if (nums[left] + nums[right] < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "16": {
    "solution": {
      "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int threeSumClosest(int[] nums, int target) {\n        Arrays.sort(nums);\n        int closestSum = nums[0] + nums[1] + nums[2];\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n            while (left < right) {\n                int currentSum = nums[i] + nums[left] + nums[right];\n                if (Math.abs(currentSum - target) < Math.abs(closestSum - target)) {\n                    closestSum = currentSum;\n                }\n                if (currentSum < target) {\n                    left++;\n                } else if (currentSum > target) {\n                    right--;\n                } else {\n                    return target; // Early exit if we find an exact match\n                }\n            }\n        }\n\n        return closestSum;\n    }\n}"
    }
  },
  "17": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    private static final String[] KEYPAD = {\n        \"\",     // 0\n        \"\",     // 1\n        \"abc\",  // 2\n        \"def\",  // 3\n        \"ghi\",  // 4\n        \"jkl\",  // 5\n        \"mno\",  // 6\n        \"pqrs\", // 7\n        \"tuv\",  // 8\n        \"wxyz\"  // 9\n    };\n\n    public List<String> letterCombinations(String digits) {\n        List<String> result = new ArrayList<>();\n        if (digits == null || digits.length() == 0) {\n            return result;\n        }\n        dfs(result, new StringBuilder(), digits, 0);\n        return result;\n    }\n\n    private void dfs(List<String> result, StringBuilder current, String digits, int index) {\n        if (index == digits.length()) {\n            result.add(current.toString());\n            return;\n        }\n\n        String letters = KEYPAD[digits.charAt(index) - '0'];\n        for (char letter : letters.toCharArray()) {\n            current.append(letter);\n            dfs(result, current, digits, index + 1);\n            current.deleteCharAt(current.length() - 1); // Backtrack\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String digits = \"23\";\n        List<String> combinations = solution.letterCombinations(digits);\n        System.out.println(combinations); // Output: [ad, ae, af, bd, be, bf, cd, ce, cf]\n    }\n}\n"
    }
  },
  "18": {
    "solution": {
      "two-pointers": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> fourSum(int[] nums, int target) {\n        List<List<Integer>> result = new ArrayList<>();\n        int n = nums.length;\n        if (n < 4) return result;\n        \n        Arrays.sort(nums);\n        \n        for (int i = 0; i < n - 3; i++) {\n            if (i > 0 && nums[i] == nums[i - 1]) continue; \n            for (int j = i + 1; j < n - 2; j++) {\n                if (j > i + 1 && nums[j] == nums[j - 1]) continue; \n                \n                int left = j + 1;\n                int right = n - 1;\n                \n                while (left < right) {\n                    long sum = (long) nums[i] + nums[j] + nums[left] + nums[right];\n                    \n                    if (sum == target) {\n                        result.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        \n                        while (left < right && nums[left] == nums[left + 1]) left++;\n                        while (left < right && nums[right] == nums[right - 1]) right--;\n                        \n                        left++;\n                        right--;\n                    } else if (sum < target) {\n                        left++;\n                    } else {\n                        right--;\n                    }\n                }\n            }\n        }\n        \n        return result;\n    }\n    \n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] nums = {1000000000, 1000000000, 1000000000, 1000000000};\n        int target = -294967296;\n        List<List<Integer>> result = sol.fourSum(nums, target);\n        \n        // Expected Output: []\n        for (List<Integer> quad : result) {\n            System.out.println(quad);\n        }\n    }\n}\n"
    }
  },
  "19": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode removeNthFromEnd(ListNode head, int n) {\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode slow = dummy;\n        ListNode fast = dummy;\n        for (int i = 1; i <= n + 1; i++) {\n            fast = fast.next;\n        }\n\n        while (fast != null) {\n            fast = fast.next;\n            slow = slow.next;\n        }\n        slow.next = slow.next.next;\n\n        return dummy.next;\n    }\n}\n"
    }
  },
  "20": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public boolean isValid(String s) {\n        Deque<Character> stack = new ArrayDeque<>();\n\n        for (char ch : s.toCharArray()) {\n            if (ch == '(' || ch == '{' || ch == '[') {\n                stack.push(ch);\n            } else {\n                if (stack.isEmpty())\n                    return false;\n                char open = stack.pop();\n                if (!isMatchingPair(open, ch))\n                    return false;\n            }\n        }\n\n        return stack.isEmpty();\n    }\n\n    private boolean isMatchingPair(char open, char close) {\n        return (open == '(' && close == ')') ||\n                (open == '{' && close == '}') ||\n                (open == '[' && close == ']');\n    }\n}\n"
    }
  },
  "21": {
    "solution": {
      "linked-list": "/* \nclass ListNode {\n    int val;        // The value of the node\n    ListNode next;  // Pointer to the next node in the list\n\n    ListNode() {}\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n*/\n\nclass Solution {\n    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (list1 != null && list2 != null) {\n            if (list1.val < list2.val) {\n                current.next = list1;\n                list1 = list1.next;\n            } else {\n                current.next = list2;\n                list2 = list2.next;\n            }\n            current = current.next;\n        }\n\n        current.next = (list1 != null) ? list1 : list2;\n\n        return dummy.next;\n    }\n}"
    }
  },
  "22": {
    "solution": {
      "dynamic-programming": "",
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> generateParenthesis(int n) {\n        List<String> result = new ArrayList<>();\n        dfs(\"\", n, n, result);\n        return result;\n    }\n\n    private void dfs(String prefix, int l, int r, List<String> result) {\n        if (l == 0 && r == 0) {\n            result.add(prefix);\n            return;\n        }\n        if (l > 0) {\n            dfs(prefix + \"(\", l - 1, r, result);\n        }\n        if (l < r) {\n            dfs(prefix + \")\", l, r - 1, result);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        List<String> combinations = solution.generateParenthesis(3);\n        System.out.println(combinations); // Output: [((())),(()()),(())(),()(()),()()()]\n    }\n}\n"
    }
  },
  "23": {
    "solution": {
      "merge-sort": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        if (lists == null || lists.length == 0) {\n            return null;\n        }\n        return mergeKLists(lists, 0, lists.length - 1);\n    }\n    \n    private ListNode mergeKLists(ListNode[] lists, int left, int right) {\n        if (left == right) {\n            return lists[left];\n        }\n        int mid = left + (right - left) / 2;\n        ListNode l1 = mergeKLists(lists, left, mid);\n        ListNode l2 = mergeKLists(lists, mid + 1, right);\n        return mergeTwoLists(l1, l2);\n    }\n    \n    private ListNode mergeTwoLists(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n        \n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n        \n        if (l1 != null) {\n            current.next = l1;\n        } else if (l2 != null) {\n            current.next = l2;\n        }\n        \n        return dummy.next;\n    }\n}\n",
      "heap-(priority-queue)": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode mergeKLists(ListNode[] lists) {\n        ListNode dummy = new ListNode(0);\n        ListNode curr = dummy;\n        Queue<ListNode> minHeap = new PriorityQueue<>((a, b) -> a.val - b.val);\n\n        for (ListNode list : lists)\n            if (list != null)\n                minHeap.offer(list);\n\n        while (!minHeap.isEmpty()) {\n            ListNode minNode = minHeap.poll();\n            if (minNode.next != null)\n                minHeap.offer(minNode.next);\n            curr.next = minNode;\n            curr = curr.next;\n        }\n\n        return dummy.next;\n    }\n}"
    }
  },
  "24": {
    "solution": {
      "linked-list": "/* \nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {}\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n*/\n\nclass Solution {\n    public ListNode swapPairs(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode prev = dummy;\n\n        while (prev.next != null && prev.next.next != null) {\n            ListNode first = prev.next;\n            ListNode second = prev.next.next;\n\n            first.next = second.next;\n            second.next = first;\n            prev.next = second;\n\n            prev = first;\n        }\n\n        return dummy.next;\n    }\n}"
    }
  },
  "25": {
    "solution": {
      "recursion": "/* \nclass ListNode {\n    int val;\n    ListNode next;\n\n    ListNode() {}\n\n    ListNode(int val) {\n        this.val = val;\n    }\n\n    ListNode(int val, ListNode next) {\n        this.val = val;\n        this.next = next;\n    }\n}\n*/\n\nclass Solution {\n    private ListNode reverseKNodes(ListNode head, int k) {\n        ListNode prev = null;\n        ListNode curr = head;\n        ListNode next = null;\n        int count = 0;\n\n        while (curr != null && count < k) {\n            next = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = next;\n            count++;\n        }\n\n        return prev;\n    }\n\n    public ListNode reverseKGroup(ListNode head, int k) {\n        if (head == null || k == 1) return head;\n\n        ListNode temp = head;\n        int count = 0;\n        while (temp != null && count < k) {\n            temp = temp.next;\n            count++;\n        }\n\n        if (count < k) return head;\n\n        ListNode newHead = reverseKNodes(head, k);\n        head.next = reverseKGroup(temp, k);\n        return newHead;\n    }\n}"
    }
  },
  "26": {
    "solution": {
      "two-pointers": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        if (nums.length == 0) return 0;\n\n        int slow = 1;  // slow pointer\n        for (int fast = 1; fast < nums.length; fast++) {  // fast pointer\n            if (nums[fast] != nums[fast - 1]) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}\n"
    }
  },
  "27": {
    "solution": {
      "two-pointers": "class Solution {\n    public int removeElement(int[] nums, int val) {\n        int slow = 0;  \n        for (int fast = 0; fast < nums.length; fast++) { \n            if (nums[fast] != val) {\n                nums[slow++] = nums[fast];\n            }\n        }\n        return slow;\n    }\n}"
    }
  },
  "28": {
    "solution": {
      "two-pointers": "class Solution {\n    public int strStr(String haystack, String needle) {\n        if (needle.isEmpty()) {\n            return 0;\n        }\n        int haystackLength = haystack.length();\n        int needleLength = needle.length();\n        \n        for (int i = 0; i <= haystackLength - needleLength; i++) {\n            int j = 0;\n            while (j < needleLength && haystack.charAt(i + j) == needle.charAt(j)) {\n                j++;\n            }\n            if (j == needleLength) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
    }
  },
  "29": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int divide(int dividend, int divisor) {\n        if (dividend == Integer.MIN_VALUE && divisor == -1) {\n            return Integer.MAX_VALUE;\n        }\n\n        int resultSign = ((dividend > 0) ^ (divisor > 0)) ? -1 : 1;\n\n        long absoluteDividend = Math.abs((long) dividend);\n        long absoluteDivisor = Math.abs((long) divisor);\n        long result = 0;\n\n        while (absoluteDividend >= absoluteDivisor) {\n            long multiplier = 1;\n            long tempDivisor = absoluteDivisor;\n\n            while (tempDivisor << 1 <= absoluteDividend) {\n                tempDivisor <<= 1;\n                multiplier <<= 1;\n            }\n\n            absoluteDividend -= tempDivisor;\n            result += multiplier;\n        }\n\n        return resultSign * (int) result;\n    }\n}"
    }
  },
  "30": {
    "solution": {
      "sliding-window": "import java.util.*;\n\npublic class Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || s.length() == 0 || words == null || words.length == 0) {\n            return result;\n        }\n\n        int wordLength = words[0].length();\n        int wordsCount = words.length;\n        int totalLength = wordLength * wordsCount;\n\n        Map<String, Integer> wordMap = new HashMap<>();\n        for (String word : words) {\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\n        }\n\n        for (int i = 0; i < wordLength; i++) {\n            int left = i;\n            int right = i;\n            int count = 0;\n            Map<String, Integer> currentMap = new HashMap<>();\n            \n            while (right + wordLength <= s.length()) {\n                String word = s.substring(right, right + wordLength);\n                right += wordLength;\n\n                if (wordMap.containsKey(word)) {\n                    currentMap.put(word, currentMap.getOrDefault(word, 0) + 1);\n                    count++;\n                    while (currentMap.get(word) > wordMap.get(word)) {\n                        String leftWord = s.substring(left, left + wordLength);\n                        currentMap.put(leftWord, currentMap.get(leftWord) - 1);\n                        left += wordLength;\n                        count--;\n                    }\n                    if (count == wordsCount) {\n                        result.add(left);\n                    }\n                } else {\n                    currentMap.clear();\n                    count = 0;\n                    left = right;\n                }\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "31": {
    "solution": {
      "two-pointers": "class Solution {\n    public void nextPermutation(int[] nums) {\n        int n = nums.length;\n        int i = n - 2;\n        \n        while (i >= 0 && nums[i] >= nums[i + 1]) {\n            i--;\n        }\n        \n        if (i >= 0) {\n            int j = n - 1;\n            while (nums[j] <= nums[i]) {\n                j--;\n            }\n            swap(nums, i, j);\n        }\n        \n        reverse(nums, i + 1, n - 1);\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n    \n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            swap(nums, start, end);\n            start++;\n            end--;\n        }\n    }\n}\n"
    }
  },
  "32": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public int longestValidParentheses(String s) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        stack.push(-1);\n        int maxLength = 0;\n\n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '(') {\n                stack.push(i);\n            } else {\n                stack.pop();\n                if (stack.isEmpty()) {\n                    stack.push(i);\n                } else {\n                    maxLength = Math.max(maxLength, i - stack.peek());\n                }\n            }\n        }\n\n        return maxLength;\n    }\n}\n"
    }
  },
  "33": {
    "solution": {
      "binary-search": "class Solution {\n    public int search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            }\n\n            if (nums[left] <= nums[mid]) {\n                if (nums[left] <= target && target < nums[mid]) {\n                    right = mid - 1;\n                } else {\n                    left = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[right]) {\n                    left = mid + 1;\n                } else {\n                    right = mid - 1;\n                }\n            }\n        }\n\n        return -1;\n    }\n}"
    }
  },
  "34": {
    "solution": {
      "binary-search": "class Solution {\n    private int binarySearchFirst(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        int firstPos = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                firstPos = mid;\n                high = mid - 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return firstPos;\n    }\n\n    private int binarySearchLast(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n        int lastPos = -1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) {\n                lastPos = mid;\n                low = mid + 1;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return lastPos;\n    }\n\n    public int[] searchRange(int[] nums, int target) {\n        int first = binarySearchFirst(nums, target);\n        int last = binarySearchLast(nums, target);\n        return new int[] {first, last};\n    }\n}"
    }
  },
  "35": {
    "solution": {
      "binary-search": "class Solution {\n    public int searchInsert(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) {\n                return mid;\n            } else if (nums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return low;\n    }\n}"
    }
  },
  "36": {
    "solution": {
      "matrix": "public class Solution {\n\n    public boolean isSafe(char[][] board, int row, int col, char num) {\n        for (int j = 0; j < 9; j++) {\n            if (board[row][j] == num) {\n                return false;\n            }\n        }\n\n        for (int i = 0; i < 9; i++) {\n            if (board[i][col] == num) {\n                return false;\n            }\n        }\n\n        int startRow = row - row % 3;\n        int startCol = col - col % 3;\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == num) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public boolean isValidSudoku(char[][] board) {\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char num = board[i][j];                \n                if (num == '.') continue;\n\n                board[i][j] = '.';\n                if (!isSafe(board, i, j, num)) {\n                    return false; \n                }\n                board[i][j] = num;\n            }\n        }\n\n        return true;\n    }\n}\n"
    }
  },
  "37": {
    "solution": {
      "backtracking": "public class Solution {\n\n   public boolean isSafe(int[][] board, int row, int col, int num, int n) {\n        for (int j = 0; j < n; j++)\n            if (board[row][j] == num)\n                return false;\n\n        for (int i = 0; i < n; i++)\n            if (board[i][col] == num)\n                return false;\n\n        int startRow = row - row % 3,\n                startCol = col - col % 3;\n\n        // check within the section (3 * 3)(n = 3)\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                if (board[i + startRow][j + startCol] == num)\n                    return false;\n            }\n        }\n\n        return true;\n    }\n\n    boolean solve(int[][] board, int row, int col, int n) {\n        // avoid further tracking if all cells are explored\n        if (row == n - 1 && col == n)\n            return true;\n\n        // move to next row\n        if (col == n) {\n            row++;\n            col = 0;\n        }\n\n        // check for next element horizontally if element is\n        // already present\n        if (board[row][col] != 0)\n            return solve(board, row, col + 1, n);\n\n        // if present value is 0, replace it with values from 0-9\n        for (int num = 1; num < n + 1; num++) {\n            if (isSafe(board, row, col, num, n)) {\n                board[row][col] = num;\n        // check for next column\n                if (solve(board, row, col + 1, n)) {\n                    return true;\n                }\n            }\n            board[row][col] = 0;\n        }\n\n        return false;\n    }\n\n    public void solveSudoku(char[][] board) {\n        int n = board[0].length;\n        int grid[][] = new int[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == '.') {\n                    grid[i][j] = 0;\n                } else {\n                    grid[i][j] = Integer.parseInt(String.valueOf(board[i][j]));\n                }\n            }\n        }\n        solve(grid, 0, 0, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    board[i][j] = '.';\n                } else {\n                    board[i][j] = (char) (grid[i][j] + '0');\n                }\n            }\n        }\n    }\n\n}\n"
    }
  },
  "38": {
    "solution": {
      "string": "class Solution {\n    public String countAndSay(int n) {\n        String result = \"1\";\n\n        for (int i = 2; i <= n; i++) {\n            StringBuilder temp = new StringBuilder();\n            int count = 1;\n\n            for (int j = 1; j < result.length(); j++) {\n                if (result.charAt(j) == result.charAt(j - 1)) {\n                    count++;\n                } else {\n                    temp.append(count).append(result.charAt(j - 1));\n                    count = 1;\n                }\n            }\n\n            temp.append(count).append(result.charAt(result.length() - 1));\n            result = temp.toString();\n        }\n\n        return result;\n    }\n}"
    }
  },
  "39": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> combinationSum(int[] candidates, int target) {\n        List<List<Integer>> res = new ArrayList<>();\n        Arrays.sort(candidates);\n        dfs(0, candidates, target, res, new ArrayList<>());\n        return res;\n    }\n\n    private void dfs(int s, int[] candidates, int target, List<List<Integer>> res, List<Integer> curr) {\n        if (target < 0)\n            return;\n        if (target == 0) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = s; i < candidates.length; ++i) {\n            // if(int i=0;... , ans = [[2, 2, 3], [2, 3, 2], [3, 2, 2], [7]]\n            curr.add(candidates[i]);\n            dfs(i, candidates, target - candidates[i], res, curr);\n            curr.remove(curr.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] candidates = { 2, 3, 6, 7 };\n        int target = 7;\n        List<List<Integer>> combinations = solution.combinationSum(candidates, target);\n        System.out.println(combinations); // Output: [[2, 2, 3], [7]]\n    }\n}\n"
    }
  },
  "40": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> combinationSum2(int[] candidates, int target) {\n        List<List<Integer>> result = new ArrayList<List<Integer>>();\n        if (candidates == null || candidates.length == 0)\n            return result;\n        ArrayList<Integer> current = new ArrayList<Integer>();\n        Arrays.sort(candidates);\n        dfs(candidates, target, 0, current, result);\n        return result;\n    }\n\n    public void dfs(int[] candidates, int target, int j, ArrayList<Integer> curr,\n            List<List<Integer>> result) {\n        if (target == 0) {\n            ArrayList<Integer> temp = new ArrayList<Integer>(curr);\n            result.add(temp);\n            return;\n        }\n        for (int i = j; i < candidates.length; i++) {\n            if (target < candidates[i]) {\n                return;\n            }\n            if (i == j || candidates[i] != candidates[i - 1]) {\n                curr.add(candidates[i]);\n                dfs(candidates, target - candidates[i], i + 1, curr, result);\n                curr.remove(curr.size() - 1);\n            }\n        }\n    }\n}"
    }
  },
  "41": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public int firstMissingPositive(int[] nums) {\n        int n = nums.length;\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] <= 0) {\n                nums[i] = n + 1;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            int val = Math.abs(nums[i]);\n            if (val <= n) {\n                nums[val - 1] = -Math.abs(nums[val - 1]);\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (nums[i] > 0) {\n                return i + 1;\n            }\n        }\n\n        return n + 1;\n    }\n}"
    }
  },
  "42": {
    "solution": {
      "two-pointers": "class Solution {\n    public int trap(int[] height) {\n        if (height == null || height.length == 0) return 0;\n\n        int left = 0, right = height.length - 1;\n        int left_max = 0, right_max = 0;\n        int waterTrapped = 0;\n\n        while (left < right) {\n            if (height[left] < height[right]) {\n                if (height[left] >= left_max) {\n                    left_max = height[left];\n                } else {\n                    waterTrapped += left_max - height[left];\n                }\n                left++;\n            } else {\n                if (height[right] >= right_max) {\n                    right_max = height[right];\n                } else {\n                    waterTrapped += right_max - height[right];\n                }\n                right--;\n            }\n        }\n\n        return waterTrapped;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] height = {0,1,0,2,1,0,1,3,2,1,2,1};\n        System.out.println(sol.trap(height)); // Output: 6\n    }\n}\n"
    }
  },
  "43": {
    "solution": {
      "math": "class Solution {\\npublic:\\n    string multiply(string num1, string num2) {\\n        int m = num1.size();\\n        int n = num2.size();\\n        \\n        vector<int> result(m + n, 0);\\n        \\n        reverse(num1.begin(), num1.end());\\n        reverse(num2.begin(), num2.end());\\n        \\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                result[i + j] += (num1[i] - '0') * (num2[j] - '0');\\n                result[i + j + 1] += result[i + j] / 10;  \\n                result[i + j] %= 10; \\n            }\\n        }\\n        \\n        while (result.size() > 1 && result.back() == 0) {\\n            result.pop_back();\\n        }\\n        \\n        string resultStr;\\n        for (int i = result.size() - 1; i >= 0; --i) {\\n            resultStr += to_string(result[i]);\\n        }\\n        \\n        return resultStr;\\n    }\\n};"
    }
  },
  "44": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public static boolean isMatch(String s, String p) {\n        int m = s.length();\n        int n = p.length();\n        boolean dp[][] = new boolean[m + 1][n + 1];\n        dp[0][0] = true;\n        for (int j = 1; j <= n; j++) {\n            if (p.charAt(j - 1) == '*') {\n                dp[0][j] = dp[0][j - 1];\n            }\n        }\n\n        for (int i = 1; i < m + 1; i++) {\n            for (int j = 1; j < n + 1; j++) {\n                if (p.charAt(j - 1) == '?' || p.charAt(j - 1) == s.charAt(i - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else if (p.charAt(j - 1) == '*') {\n                    dp[i][j] = dp[i - 1][j] || dp[i][j - 1];\n                }\n            }\n        }\n\n        System.out.println(Arrays.toString(dp));\n\n        return dp[m][n];\n    }\n}"
    }
  },
  "45": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public static int jump(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[0] = 0;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (j + nums[j] >= i) {\n                    dp[i] = Math.min(dp[i], dp[j] + 1);\n                }\n            }\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n - 1];\n    }\n};\n"
    }
  },
  "46": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> permute(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean[] visited = new boolean[nums.length];\n        dfs(nums, res, new ArrayList<>(), visited);\n        return res;\n    }\n\n    private void dfs(int[] nums, List<List<Integer>> res, List<Integer> curr, boolean[] visited) {\n        if (curr.size() == nums.length) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (!visited[i]) {\n                visited[i] = true;\n                curr.add(nums[i]);\n                dfs(nums, res, curr, visited);\n                curr.remove(curr.size() - 1);\n                visited[i] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> permutations = solution.permute(nums);\n        System.out.println(permutations); // Output: [[1, 2, 3], [1, 3, 2], [2, 1, 3], [2, 3, 1], [3, 1, 2], [3, 2, 1]]\n    }\n}\n"
    }
  },
  "47": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.Arrays;\nimport java.util.List;\n\nclass Solution {\n\n    public List<List<Integer>> permuteUnique(int[] nums) {\n        List<List<Integer>> res = new ArrayList<>();\n        boolean[] visited = new boolean[nums.length];\n        if (nums == null || nums.length == 0) {\n            return res;\n        }\n        Arrays.sort(nums); // Sort the array to handle duplicates\n        dfs(nums, res, new ArrayList<>(), visited);\n        return res;\n    }\n\n    private void dfs(int[] nums, List<List<Integer>> res, List<Integer> curr, boolean[] visited) {\n        if (curr.size() == nums.length) {\n            res.add(new ArrayList<>(curr));\n            return;\n        }\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i]) {\n                continue;\n            }\n            if (i == 0 || nums[i] != nums[i - 1] || (nums[i] == nums[i - 1] && visited[i - 1])) {\n                visited[i] = true;\n                curr.add(nums[i]);\n                dfs(nums, res, curr, visited);\n                curr.remove(curr.size() - 1); // Backtrack\n                visited[i] = false;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 2};\n        List<List<Integer>> permutations = solution.permuteUnique(nums);\n        System.out.println(permutations); // Output: [[1, 1, 2], [1, 2, 1], [2, 1, 1]]\n    }\n}\n"
    }
  },
  "48": {
    "solution": {
      "matrix": "public class RotateImage {\n\n    public void rotate(int[][] matrix) {\n        if (matrix == null || matrix.length == 0) return;\n        \n        int n = matrix.length;\n        transpose(matrix, n);\n        \n        for (int i = 0; i < n; i++) {\n            reverseRow(matrix[i], n);\n        }\n    }\n    \n    private void transpose(int[][] matrix, int n) {\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                swap(matrix, i, j, j, i);\n            }\n        }\n    }\n    \n    private void reverseRow(int[] row, int n) {\n        int left = 0, right = n - 1;\n        while (left < right) {\n            int temp = row[left];\n            row[left] = row[right];\n            row[right] = temp;\n            left++;\n            right--;\n        }\n    }\n    \n    private void swap(int[][] matrix, int i, int j, int x, int y) {\n        int temp = matrix[i][j];\n        matrix[i][j] = matrix[x][y];\n        matrix[x][y] = temp;\n    }\n\n    public static void main(String[] args) {\n        RotateImage ri = new RotateImage();\n        int[][] matrix = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        \n        ri.rotate(matrix);\n        \n        for (int i = 0; i < matrix.length; i++) {\n            for (int j = 0; j < matrix[i].length; j++) {\n                System.out.print(matrix[i][j] + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n"
    }
  },
  "49": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public List<List<String>> groupAnagrams(String[] strs) {\n        Map<String, List<String>> anagramGroups = new HashMap<>();\n\n        for (String str : strs) {\n            char[] chars = str.toCharArray();\n            Arrays.sort(chars);\n            String sortedStr = new String(chars);\n\n            anagramGroups.computeIfAbsent(sortedStr, k -> new ArrayList<>()).add(str);\n        }\n\n        return new ArrayList<>(anagramGroups.values());\n    }\n}"
    }
  },
  "50": {
    "solution": {
      "recursion": "class Solution {\n    public double myPow(double x, int n) {\n        long power = n;\n        if (power < 0) {\n            x = 1 / x;\n            power = -power;\n        }\n        return fastPow(x, power);\n    }\n\n    private double fastPow(double x, long n) {\n        if (n == 0) return 1.0;\n        double half = fastPow(x, n / 2);\n        return (n % 2 == 0) ? half * half : half * half * x;\n    }\n}"
    }
  },
  "51": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<String>> solveNQueens(int n) {\n        List<List<String>> res = new ArrayList<>();\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                board[i][j] = '.';\n            }\n        }\n        dfs(board, 0, res);\n        return res;\n    }\n\n    private void dfs(char[][] board, int row, List<List<String>> res) {\n        if (row == board.length) {\n            res.add(construct(board));\n            return;\n        }\n\n        for (int col = 0; col < board.length; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                dfs(board, row + 1, res);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    private boolean isValid(char[][] board, int row, int col) {\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private List<String> construct(char[][] board) {\n        List<String> path = new ArrayList<>();\n        for (int i = 0; i < board.length; i++) {\n            path.add(new String(board[i]));\n        }\n        return path;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 4;\n        List<List<String>> result = solution.solveNQueens(n);\n        for (List<String> solutionBoard : result) {\n            for (String row : solutionBoard) {\n                System.out.println(row);\n            }\n            System.out.println();\n        }\n    }\n}\n"
    }
  },
  "52": {
    "solution": {
      "backtracking": "class Solution {\n    private int count = 0;\n    public int totalNQueens(int n) {\n        char[][] board = new char[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                board[i][j] = '.';\n            }\n        }\n        dfs(board, 0);\n        return count;\n    }\n\n    private void dfs(char[][] board, int row) {\n        if (row == board.length) {\n            count++;\n            return;\n        }\n        for (int col = 0; col < board.length; col++) {\n            if (isValid(board, row, col)) {\n                board[row][col] = 'Q';\n                dfs(board, row + 1);\n                board[row][col] = '.';\n            }\n        }\n    }\n\n    private boolean isValid(char[][] board, int row, int col) {\n        for (int i = 0; i < row; i++) {\n            if (board[i][col] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col - 1; i >= 0 && j >= 0; i--, j--) {\n            if (board[i][j] == 'Q') return false;\n        }\n        for (int i = row - 1, j = col + 1; i >= 0 && j < board.length; i--, j++) {\n            if (board[i][j] == 'Q') return false;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 4;\n        int totalSolutions = solution.totalNQueens(n);\n        System.out.println(\"Total number of solutions: \" + totalSolutions);\n    }\n}"
    }
  },
  "53": {
    "solution": {
      "dynamic-programming": "public class Solution {\n    // dp[i]: Maximum subarray sum ending at index i\n    public static int maxSubArray(int[] a) {\n        int dp[] = new int[a.length];\n        dp[0] = a[0];\n        for (int i = 1; i < a.length; i++) {\n            dp[i] = Math.max(dp[i - 1] + a[i], a[i]);\n        }\n        System.out.println(Arrays.toString(dp));\n        return Arrays.stream(dp).max().getAsInt();\n    }\n}",
      "divide-and-conquer": "public class Solution {\n    public int maxSubArray(int[] nums) {\n        return maxSubArrayHelper(nums, 0, nums.length - 1);\n    }\n\n    private int maxSubArrayHelper(int[] nums, int left, int right) {\n        if (left == right) {\n            return nums[left];\n        }\n\n        int mid = (left + right) / 2;\n        int leftMax = maxSubArrayHelper(nums, left, mid);\n        int rightMax = maxSubArrayHelper(nums, mid + 1, right);\n        int crossMax = findMaxCrossingSubarray(nums, left, mid, right);\n\n        return Math.max(leftMax, Math.max(rightMax, crossMax));\n    }\n\n    private int findMaxCrossingSubarray(int[] nums, int left, int mid, int right) {\n        int leftSum = Integer.MIN_VALUE;\n        int sum = 0;\n        for (int i = mid; i >= left; i--) {\n            sum += nums[i];\n            if (sum > leftSum) {\n                leftSum = sum;\n            }\n        }\n\n        int rightSum = Integer.MIN_VALUE;\n        sum = 0;\n        for (int i = mid + 1; i <= right; i++) {\n            sum += nums[i];\n            if (sum > rightSum) {\n                rightSum = sum;\n            }\n        }\n\n        return leftSum + rightSum;\n    }\n\n}"
    }
  },
  "54": {
    "solution": {
      "matrix": "package com.sai.designPatterns;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public List<Integer> spiralOrder(int[][] matrix) {\n        List<Integer> result = new ArrayList<>();\n        if (matrix == null || matrix.length == 0) return result;\n\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n\n        dfs(matrix, visited, result, 0, 0, 0);\n        return result;\n    }\n\n    private void dfs(int[][] matrix, boolean[][] visited, List<Integer> result, int row, int col, int direction) {\n        if (row < 0 || row >= matrix.length || col < 0 || col >= matrix[0].length || visited[row][col]) {\n            return;\n        }\n\n        visited[row][col] = true;\n        result.add(matrix[row][col]);\n\n        int nextRow = row + DIRECTIONS[direction][0];\n        int nextCol = col + DIRECTIONS[direction][1];\n        if (nextRow < 0 || nextRow >= matrix.length || nextCol < 0 || nextCol >= matrix[0].length || visited[nextRow][nextCol]) {\n            direction = (direction + 1) % 4;\n            nextRow = row + DIRECTIONS[direction][0];\n            nextCol = col + DIRECTIONS[direction][1];\n        }\n\n        dfs(matrix, visited, result, nextRow, nextCol, direction);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Sample 2D matrix\n        int[][] matrix = {\n                {1, 2, 3, 4},\n                {5, 6, 7, 8},\n                {9, 10, 11, 12}\n        };\n\n        // Get the spiral order\n        List<Integer> result = solution.spiralOrder(matrix);\n\n        System.out.println(\"Spiral Order: \" + result);\n    }\n}\n"
    }
  },
  "55": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public boolean canJump(int[] nums) {\n        int n = nums.length;\n        boolean[] dp = new boolean[n];\n        dp[0] = true; // You are always at the start\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                // If j is reachable and we can jump from j to i\n                if (dp[j] && j + nums[j] >= i) {\n                    dp[i] = true;\n                    break; // No need to check further\n                }\n            }\n        }\n\n        return dp[n - 1]; // Can we reach the last index?\n    }\n}"
    }
  },
  "56": {
    "solution": {
      "sorting": "class Solution {\\npublic:\\n    vector<vector<int>> merge(vector<vector<int>>& intervals) {\\n        // If there are no intervals, return an empty result\\n        if (intervals.empty()) {\\n            return {};\\n        }\\n        \\n        sort(intervals.begin(), intervals.end());\\n        \\n        vector<vector<int>> result;\\n        result.push_back(intervals[0]);\\n        \\n        for (int i = 1; i < intervals.size(); ++i) {\\n            if (intervals[i][0] <= result.back()[1]) {\\n                result.back()[1] = max(result.back()[1], intervals[i][1]);\\n            } else {\\n                result.push_back(intervals[i]);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};"
    }
  },
  "57": {
    "solution": {
      "array": "import java.util.*;\n\nclass Solution {\n    public int[][] insert(int[][] intervals, int[] newInterval) {\n        List<int[]> result = new ArrayList<>();\n        int i = 0, n = intervals.length;\n\n        while (i < n && intervals[i][1] < newInterval[0]) {\n            result.add(intervals[i++]);\n        }\n\n        while (i < n && intervals[i][0] <= newInterval[1]) {\n            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);\n            newInterval[1] = Math.max(newInterval[1], intervals[i][1]);\n            i++;\n        }\n        result.add(newInterval);\n\n        while (i < n) {\n            result.add(intervals[i++]);\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n}"
    }
  },
  "58": {
    "solution": {
      "string": "class Solution {\n    public int lengthOfLastWord(String s) {\n        int index = s.length() - 1;\n\n        while (index >= 0 && s.charAt(index) == ' ') {\n            index--;\n        }\n\n        int length = 0;\n        while (index >= 0 && s.charAt(index) != ' ') {\n            length++;\n            index--;\n        }\n\n        return length;\n    }\n}"
    }
  },
  "59": {
    "solution": {
      "matrix": "public class Solution {\n\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int[][] generateMatrix(int n) {\n        int[][] matrix = new int[n][n];\n        boolean[][] visited = new boolean[n][n];\n        int row = 0, col = 0, dir = 0;\n        for (int i = 1; i <= n * n; i++) {\n            matrix[row][col] = i;\n            visited[row][col] = true;\n\n            int nextRow = row + DIRECTIONS[dir][0];\n            int nextCol = col + DIRECTIONS[dir][1];\n\n            if (nextRow < 0 || nextRow >= n || nextCol < 0 || nextCol >= n || visited[nextRow][nextCol]) {\n                dir = (dir + 1) % 4; \n                nextRow = row + DIRECTIONS[dir][0];\n                nextCol = col + DIRECTIONS[dir][1];\n            }\n\n            row = nextRow;\n            col = nextCol;\n        }\n        return matrix;\n    }\n\n}\n"
    }
  },
  "60": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public String getPermutation(int n, int k) {\n        List<Integer> nums = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            nums.add(i);\n        }\n\n        int[] factorial = new int[n];\n        factorial[0] = 1;\n        for (int i = 1; i < n; i++) {\n            factorial[i] = factorial[i - 1] * i;\n        }\n\n        k--;\n        StringBuilder result = new StringBuilder();\n\n        for (int i = n; i > 0; i--) {\n            int index = k / factorial[i - 1];\n            result.append(nums.get(index));\n            nums.remove(index);\n            k %= factorial[i - 1];\n        }\n\n        return result.toString();\n    }\n}"
    }
  },
  "61": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode rotateRight(ListNode head, int k) {\n        if (head == null || head.next == null || k == 0) {\n            return head;\n        }\n        ListNode oldTail = head;\n        int length = 1;\n        while (oldTail.next != null) {\n            oldTail = oldTail.next;\n            length++;\n        }\n        oldTail.next = head;        \n        int newTailPosition = length - k % length - 1;        \n        ListNode newTail = head;\n        for (int i = 0; i < newTailPosition; i++) {\n            newTail = newTail.next;\n        }        \n        ListNode newHead = newTail.next;        \n        newTail.next = null;\n        return newHead;\n    }\n}\n"
    }
  },
  "62": {
    "solution": {
      "dynamic-programming": "class Solution {\n    int uniquePaths(int m, int n) {\n        int[][] dp = new int[m][n];\n        for (int[] dp1 : dp)\n            Arrays.fill(dp1, 1);\n        for (int i = 1; i < m; i++)\n            for (int j = 1; j < n; j++)\n                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n        return dp[m - 1][n - 1];\n    }\n}"
    }
  },
  "63": {
    "solution": {
      "dynamic-programming": "class Solution {\n    // dp[i][j]: the number of unique paths to reach the cell at position (i, j) in\n    // the grid without any obstacle.\n    public int uniquePathsWithObstacles(int[][] obstacleGrid) {\n        int m = obstacleGrid.length;\n        int n = obstacleGrid[0].length;\n        int[][] dp = new int[m + 1][n + 1];\n        dp[0][1] = 1;\n        // or dp[1][0] = 1\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (obstacleGrid[i - 1][j - 1] == 0) {\n                    dp[i][j] = dp[i - 1][j] + dp[i][j - 1];\n                }\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp));\n        return dp[m][n];\n    }\n}"
    }
  },
  "64": {
    "solution": {
      "dynamic-programming": "class Solution {\n //  dp[i][j] represents the minimum path sum to reach the cell at row i and column j in a 2D grid\n    public int minPathSum(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int[][] dp = grid;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (i > 0 && j > 0) {\n                    dp[i][j] += Math.min(dp[i - 1][j], dp[i][j - 1]);\n                } else if (i > 0) {\n                    dp[i][0] += dp[i - 1][0];\n                } else if (j > 0) {\n                    dp[0][j] += dp[0][j - 1];\n                }\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp));\n\n        return dp[m - 1][n - 1];\n    }\n}"
    }
  },
  "65": {
    "solution": {
      "string": "class Solution {\n    public boolean isNumber(String s) {\n        s = s.trim();\n        boolean hasDigit = false, hasDot = false, hasExp = false;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                hasDigit = true;\n            } else if (c == '+' || c == '-') {\n                if (i > 0 && s.charAt(i - 1) != 'e' && s.charAt(i - 1) != 'E') return false;\n            } else if (c == '.') {\n                if (hasDot || hasExp) return false;\n                hasDot = true;\n            } else if (c == 'e' || c == 'E') {\n                if (hasExp || !hasDigit) return false;\n                hasExp = true;\n                hasDigit = false;\n            } else {\n                return false;\n            }\n        }\n\n        return hasDigit;\n    }\n}"
    }
  },
  "66": {
    "solution": {
      "array": "import java.util.*;\n\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int n = digits.length;\n\n        for (int i = n - 1; i >= 0; --i) {\n            if (digits[i] < 9) {\n                digits[i]++;\n                return digits;\n            }\n            digits[i] = 0;\n        }\n\n        int[] result = new int[n + 1];\n        result[0] = 1;\n        return result;\n    }\n}"
    }
  },
  "67": {
    "solution": {
      "math": "class Solution {\n    public String addBinary(String a, String b) {\n        StringBuilder result = new StringBuilder();\n        int carry = 0, i = a.length() - 1, j = b.length() - 1;\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int sum = carry;\n\n            if (i >= 0) sum += a.charAt(i--) - '0';\n            if (j >= 0) sum += b.charAt(j--) - '0';\n\n            carry = sum / 2;\n            result.append(sum % 2);\n        }\n\n        return result.reverse().toString();\n    }\n}"
    }
  },
  "68": {
    "solution": {
      "string": "class Solution {\\npublic:\\n    vector<string> fullJustify(vector<string>& words, size_t maxWidth) {\\n        vector<string> ans;\\n        vector<string> row;\\n        size_t rowLetters = 0;\\n\\n        for (const string& word : words) {\\n            // If we place the word in this row, it will exceed the maximum\\n            // width. Therefore, we cannot put the word in this row and have to\\n            // pad spaces for each word in this row.\\n            if (rowLetters + row.size() + word.length() > maxWidth) {\\n                const int spaces = maxWidth - rowLetters;\\n                if (row.size() == 1) {\\n                    // Pad all the spaces after row[0].\\n                    for (int i = 0; i < spaces; ++i)\\n                        row[0] += \" \";\\n                } else {\\n                    // Evenly pad all the spaces to each word (expect the last\\n                    // one) in this row.\\n                    for (int i = 0; i < spaces; ++i)\\n                        row[i % (row.size() - 1)] += \" \";\\n                }\\n                ans.push_back(join(row, \"\"));\\n                row.clear();\\n                rowLetters = 0;\\n            }\\n            row.push_back(word);\\n            rowLetters += word.length();\\n        }\\n        ans.push_back(ljust(join(row, \" \"), maxWidth));\\n\\n        return ans;\\n    }\\n\\nprivate:\\n    string join(const vector<string>& words, const string& s) {\\n        string joined;\\n        for (int i = 0; i < words.size(); ++i) {\\n            joined += words[i];\\n            if (i != words.size() - 1)\\n                joined += s;\\n        }\\n        return joined;\\n    }\\n\\n    string ljust(string s, int width) {\\n        for (int i = 0; i < s.length() - width; ++i)\\n            s += \" \";\\n        return s;\\n    }\\n};"
    }
  },
  "69": {
    "solution": {
      "math": "class Solution {\n    public int mySqrt(int x) {\n        if (x == 0 || x == 1) return x;\n\n        int low = 0, high = x, ans = 0;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if ((long) mid * mid <= x) {\n                ans = mid;\n                low = mid + 1;\n            } else {\n                high = mid - 1;\n            }\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "70": {
    "solution": {
      "dynamic-programming": "class Solution {\n    // dp[i] represents the number of distinct ways to climb a staircase with i\n    // steps\n    public int climbStairs(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int i = 2; i <= n; i++) {\n            dp[i] = dp[i - 1] + dp[i - 2];\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n];\n    }\n}"
    }
  },
  "71": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public String simplifyPath(String path) {\n        Deque<String> stack = new ArrayDeque<>();\n        String[] components = path.split(\"/\");\n\n        for (String component : components) {\n            if (component.equals(\"\") || component.equals(\".\")) {\n                continue;\n            } else if (component.equals(\"..\")) {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                }\n            } else {\n                stack.push(component);\n            }\n        }\n\n        StringBuilder simplifiedPath = new StringBuilder();\n        while (!stack.isEmpty()) {\n            simplifiedPath.insert(0, \"/\" + stack.pop());\n        }\n\n        return simplifiedPath.length() > 0 ? simplifiedPath.toString() : \"/\";\n    }\n}\n"
    }
  },
  "72": {
    "solution": {
      "dynamic-programming": "class Solution {\n   //  dp[i][j] represents the minimum number of operations (edits) required to transform the substring word1[0...i-1] to the substring word2[0...j-1].\n    public int minDistance(String word1, String word2) {\n        int m = word1.length();\n        int n = word2.length();\n        if (m == 0) return n;\n        if (n == 0) return m;\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            dp[i][0] = i;\n        }\n\n        for (int j = 1; j <= n; j++) {\n            dp[0][j] = j;\n        }\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (word1.charAt(i - 1) == word2.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1];\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1], // replace\n                            Math.min(dp[i - 1][j], // remove\n                                    dp[i][j - 1] // insert\n                            )) + 1;\n                }\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp));\n        return dp[m][n];\n    }\n}"
    }
  },
  "73": {
    "solution": {
      "matrix": "public class Solution {\n    public void setZeroes(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        boolean isFirstRowZero = false;\n        boolean isFirstColZero = false;\n        \n        for (int i = 0; i < m; i++) {\n            if (matrix[i][0] == 0) {\n                isFirstColZero = true;\n                break;\n            }\n        }\n        \n        for (int j = 0; j < n; j++) {\n            if (matrix[0][j] == 0) {\n                isFirstRowZero = true;\n                break;\n            }\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][j] == 0) {\n                    matrix[i][0] = 0;\n                    matrix[0][j] = 0;\n                }\n            }\n        }\n        \n        for (int i = 1; i < m; i++) {\n            for (int j = 1; j < n; j++) {\n                if (matrix[i][0] == 0 || matrix[0][j] == 0) {\n                    matrix[i][j] = 0;\n                }\n            }\n        }\n        \n        if (isFirstRowZero) {\n            for (int j = 0; j < n; j++) {\n                matrix[0][j] = 0;\n            }\n        }\n        \n        if (isFirstColZero) {\n            for (int i = 0; i < m; i++) {\n                matrix[i][0] = 0;\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] matrix = {\n            {1, 1, 1},\n            {1, 0, 1},\n            {1, 1, 1}\n        };\n        \n        solution.setZeroes(matrix);\n        \n        for (int[] row : matrix) {\n            for (int val : row) {\n                System.out.print(val);\n            }\n            System.out.println();\n        }\n    }\n}\n"
    }
  },
  "74": {
    "solution": {
      "matrix": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n\n        int m = matrix.length;\n        int n = matrix[0].length;\n\n        int left = 0;\n        int right = m * n - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            int midValue = matrix[mid / n][mid % n];\n\n            if (midValue == target) {\n                return true;\n            } else if (midValue < target) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "75": {
    "solution": {
      "two-pointers": "class Solution {\n    public void sortColors(int[] nums) {\n        int low = 0;\n        int mid = 0;\n        int high = nums.length - 1;\n\n        while (mid <= high) {\n            if (nums[mid] == 0) {\n                swap(nums, low, mid);\n                low++;\n                mid++;\n            } else if (nums[mid] == 1) {\n                mid++;\n            } else {  // nums[mid] == 2\n                swap(nums, mid, high);\n                high--;\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int[] nums = {2, 0, 2, 1, 1, 0};\n        sol.sortColors(nums);        \n        for (int num : nums) {\n            System.out.print(num + \" \");\n        }\n    }\n}\n"
    }
  },
  "76": {
    "solution": {
      "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public String minWindow(String s, String t) {\n        if (s == null || s.length() == 0 || t == null || t.length() == 0) {\n            return;\n        }\n\n        Map<Character, Integer> tCount = new HashMap<>();\n        for (char c : t.toCharArray()) {\n            tCount.put(c, tCount.getOrDefault(c, 0) + 1);\n        }\n\n        int required = tCount.size();\n        int left = 0, right = 0;\n        int formed = 0;\n        Map<Character, Integer> windowCounts = new HashMap<>();\n        int[] ans = {-1, 0, 0}; // length, left, right\n\n        while (right < s.length()) {\n            char c = s.charAt(right);\n            windowCounts.put(c, windowCounts.getOrDefault(c, 0) + 1);\n\n            if (tCount.containsKey(c) && windowCounts.get(c).intValue() == tCount.get(c).intValue()) {\n                formed++;\n            }\n\n            while (left <= right && formed == required) {\n                c = s.charAt(left);\n                \n                if (ans[0] == -1 || right - left + 1 < ans[0]) {\n                    ans[0] = right - left + 1;\n                    ans[1] = left;\n                    ans[2] = right;\n                }\n\n                windowCounts.put(c, windowCounts.get(c) - 1);\n                if (tCount.containsKey(c) && windowCounts.get(c).intValue() < tCount.get(c).intValue()) {\n                    formed--;\n                }\n\n                left++;\n            }\n\n            right++;\n        }\n\n        return ans[0] == -1 ? : s.substring(ans[1], ans[2] + 1);\n    }\n}\n"
    }
  },
  "77": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> combine(int n, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(result, new ArrayList<>(), n, k, 1);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> combination, int n, int k, int start) {\n        if (combination.size() == k) {\n            result.add(new ArrayList<>(combination));\n            return;\n        }\n\n        for (int i = start; i <= n; i++) {\n            combination.add(i);\n            dfs(result, combination, n, k, i + 1);\n            combination.remove(combination.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int n = 4;\n        int k = 2;\n        List<List<Integer>> result = solution.combine(n, k);\n        for (List<Integer> combo : result) {\n            System.out.println(combo);\n        }\n    }\n}\n"
    }
  },
  "78": {
    "solution": {
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<Integer>> subsets(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        dfs(result, new ArrayList<>(), nums, 0);\n        return result;\n    }\n\n    private void dfs(List<List<Integer>> result, List<Integer> current, int[] nums, int start) {\n        result.add(new ArrayList<>(current));\n        for (int i = start; i < nums.length; i++) {\n            current.add(nums[i]);\n            dfs(result, current, nums, i + 1);\n            current.remove(current.size() - 1);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 2, 3};\n        List<List<Integer>> result = solution.subsets(nums);\n        for (List<Integer> subset : result) {\n            System.out.println(subset);\n        }\n    }\n}\n"
    }
  },
  "79": {
    "solution": {
      "backtracking": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public boolean exist(char[][] board, String word) {\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (dfs(board, word, row, col, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int row, int col, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||\n                board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        char temp = board[row][col];\n        board[row][col] = '#';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            if (dfs(board, word, newRow, newCol, index + 1)) {\n                return true;\n            }\n        }\n        board[row][col] = temp;\n        return false;\n    }\n}",
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public boolean exist(char[][] board, String word) {\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int row = 0; row < rows; row++) {\n            for (int col = 0; col < cols; col++) {\n                if (dfs(board, word, row, col, 0)) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n\n    private boolean dfs(char[][] board, String word, int row, int col, int index) {\n        if (index == word.length()) {\n            return true;\n        }\n        if (row < 0 || row >= board.length || col < 0 || col >= board[0].length ||\n                board[row][col] != word.charAt(index)) {\n            return false;\n        }\n        char temp = board[row][col];\n        board[row][col] = '#';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            if (dfs(board, word, newRow, newCol, index + 1)) {\n                return true;\n            }\n        }\n        board[row][col] = temp;\n        return false;\n    }\n}"
    }
  },
  "80": {
    "solution": {
      "two-pointers": "class Solution {\n    public int removeDuplicates(int[] nums) {\n        int n = nums.length;\n        if (n <= 2) {\n            return n;\n        }\n        int slow = 2;\n        for (int fast = 2; fast < n; fast++) {\n            if (nums[fast] != nums[slow - 2]) {\n                nums[slow++] = nums[fast];\n            }\n        }\n\n        return slow;\n    }\n}"
    }
  },
  "81": {
    "solution": {
      "array": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) return true;\n\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\n                low++;\n                high--;\n            } else if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}",
      "binary-search": "class Solution {\n    public boolean search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] == target) return true;\n\n            if (nums[low] == nums[mid] && nums[mid] == nums[high]) {\n                low++;\n                high--;\n            } else if (nums[low] <= nums[mid]) {\n                if (nums[low] <= target && target < nums[mid]) {\n                    high = mid - 1;\n                } else {\n                    low = mid + 1;\n                }\n            } else {\n                if (nums[mid] < target && target <= nums[high]) {\n                    low = mid + 1;\n                } else {\n                    high = mid - 1;\n                }\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "82": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode deleteDuplicates(ListNode head) {\n        if (head == null) return null;\n\n        ListNode dummy = new ListNode(0);\n        dummy.next = head;\n        ListNode prev = dummy;\n        ListNode current = head;\n\n        while (current != null) {\n            while (current.next != null && current.val == current.next.val) {\n                current = current.next;\n            }\n            if (prev.next != current) {\n                prev.next = current.next;\n            } else {\n                prev = prev.next;\n            }\n            current = current.next; \n        }\n\n        return dummy.next;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();        \n        ListNode head = new ListNode(1);\n        head.next = new ListNode(2);\n        head.next.next = new ListNode(3);\n        head.next.next.next = new ListNode(3);\n        head.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next.next = new ListNode(5);\n\n        ListNode result = sol.deleteDuplicates(head);        \n        while (result != null) {\n            System.out.print(result.val + \" \");\n            result = result.next;\n        }\n    }\n}\n"
    }
  },
  "83": {
    "solution": {
      "linked-list": "/**\\n * Definition for singly-linked list.\\n * struct ListNode {\\n *     int val;\\n *     ListNode *next;\\n *     ListNode() : val(0), next(nullptr) {}\\n *     ListNode(int x) : val(x), next(nullptr) {}\\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    ListNode* deleteDuplicates(ListNode* head) {\\n        // Edge case: if the list is empty or has only one element, no duplicates\\n        if (head == nullptr) return nullptr;\\n\\n        ListNode* current = head;\\n\\n        while (current != nullptr && current->next != nullptr) {\\n            // If the current node's value is equal to the next node's value\\n            if (current->val == current->next->val) {\\n                // Skip the next node\\n                current->next = current->next->next;\\n            } else {\\n                // Otherwise, move to the next node\\n                current = current->next;\\n            }\\n        }\\n\\n        return head;\\n    }\\n};"
    }
  },
  "84": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int largestRectangleArea(int[] heights) {\n        Stack<Integer> stack = new Stack<>();\n        int maxArea = 0;\n        int index = 0;\n\n        while (index < heights.length) {\n            if (stack.isEmpty() || heights[index] >= heights[stack.peek()]) {\n                stack.push(index++);\n            } else {\n                int top = stack.pop();\n                int height = heights[top];\n                int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n                maxArea = Math.max(maxArea, height * width);\n            }\n        }\n\n        while (!stack.isEmpty()) {\n            int top = stack.pop();\n            int height = heights[top];\n            int width = stack.isEmpty() ? index : index - stack.peek() - 1;\n            maxArea = Math.max(maxArea, height * width);\n        }\n\n        return maxArea;\n    }\n}"
    }
  },
  "85": {
    "solution": {
      "matrix": "class Solution {\n    // dp[i][j] represents the height of consecutive '1's ending at the cell (i, j) in the binary matrix\n    public int maximalRectangle(char[][] matrix) {\n        if (matrix.length == 0) return 0;\n        int n = matrix.length;\n        int m = matrix[0].length;\n        int[][] dp = new int[n][m];\n        int maxArea = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < m; j++) {\n                if (i == 0)\n                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;\n                else\n                    dp[i][j] = matrix[i][j] == '1' ? (dp[i - 1][j] + 1) : 0;\n                int min = dp[i][j];\n                for (int k = j; k >= 0; k--) {\n                    if (min == 0) break;\n                    if (dp[i][k] < min) min = dp[i][k];\n                    maxArea = Math.max(maxArea, min * (j - k + 1));\n                }\n            }\n        }\n        System.out.println(Arrays.deepToString(dp).replaceAll(\"],\", \"],\\n\"));\n        return maxArea;\n    }\n}"
    }
  },
  "86": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\nclass Solution {\n    public ListNode partition(ListNode head, int x) {\n        ListNode dummy1 = new ListNode(0);\n        ListNode dummy2 = new ListNode(0); \n        ListNode lessPtr = dummy1; \n        ListNode greaterOrEqualPtr = dummy2; \n        \n        while (head != null) {\n            if (head.val < x) {\n                lessPtr.next = head;\n                lessPtr = lessPtr.next;\n            } else {\n                greaterOrEqualPtr.next = head;\n                greaterOrEqualPtr = greaterOrEqualPtr.next;\n            }\n            head = head.next;\n        }\n        \n        lessPtr.next = dummy2.next;\n        greaterOrEqualPtr.next = null; \n        return dummy1.next; \n    }\n}\n"
    }
  },
  "87": {
    "solution": {
      "dynamic-programming": "class Solution {\n\n    // dp[i][j][len]: represents whether the substring of length len starting from index i in s1 and the substring of length len starting from index j in s2 are scrambled strings.\n    public boolean isScramble(String s1, String s2) {\n        if (s1.length() != s2.length()) {\n            return false;\n        }\n        int n = s1.length();\n        boolean[][][] dp = new boolean[n][n][n + 1];\n\n        // strings of length 1\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (s1.charAt(i) == s2.charAt(j)) {\n                    dp[i][j][1] = true;\n                }\n            }\n        }\n\n        // longer substrings\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                for (int j = 0; j <= n - len; j++) {\n                    for (int k = 1; k < len; k++) {\n                        if ((dp[i][j][k] && dp[i + k][j + k][len - k]) // without swap\n                                || (dp[i][j + len - k][k] && dp[i + k][j][len - k]) // with swap\n                        ) {\n                            dp[i][j][len] = true;\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp)\n                .replaceAll(\"]]\", \"]\n]\")\n                .replaceAll(\"\\\\[\\\\[\", \"[\n[\")\n                .replaceAll(\"\\\\[\\\\[\", \"[\n[\")\n                .replaceAll(\"],\", \"],\n\")\n                .replaceAll(\"]]\", \"]\n]\")\n        );\n        return dp[0][0][n];\n    }\n}"
    }
  },
  "88": {
    "solution": {
      "two-pointers": "class Solution {\n    public void merge(int[] nums1, int m, int[] nums2, int n) {\n        int p1 = m - 1;\n        int p2 = n - 1;\n        \n        int p = m + n - 1; \n        while (p1 >= 0 && p2 >= 0) {\n            if (nums1[p1] > nums2[p2]) {\n                nums1[p--] = nums1[p1--];\n            } else {\n                nums1[p--] = nums2[p2--];\n            }\n        }\n        \n        while (p2 >= 0) {\n            nums1[p--] = nums2[p2--];\n        }\n    }\n}\n"
    }
  },
  "89": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<Integer> grayCode(int n) {\n        List<Integer> result = new ArrayList<>();\n        Set<Integer> visited = new HashSet<>();\n        int total = 1 << n;\n\n        result.add(0);\n        visited.add(0);\n        dfs(0, n, result, visited, total);\n        return result;\n    }\n\n    private boolean dfs(int current, int n, List<Integer> result, Set<Integer> visited, int total) {\n        if (result.size() == total) return true;\n\n        for (int i = 0; i < n; i++) {\n            int next = current ^ (1 << i);\n            if (!visited.contains(next)) {\n                result.add(next);\n                visited.add(next);\n                if (dfs(next, n, result, visited, total)) return true;\n                result.remove(result.size() - 1);\n                visited.remove(next);\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "90": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> subsetsWithDup(int[] nums) {\n        Arrays.sort(nums);\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(0, nums, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int index, int[] nums, List<Integer> subset, List<List<Integer>> result) {\n        result.add(new ArrayList<>(subset));\n\n        for (int i = index; i < nums.length; i++) {\n            if (i > index && nums[i] == nums[i - 1]) continue;\n            subset.add(nums[i]);\n            backtrack(i + 1, nums, subset, result);\n            subset.remove(subset.size() - 1);\n        }\n    }\n}"
    }
  },
  "91": {
    "solution": {
      "dynamic-programming": "class Solution {\n//i: Represents the starting index of the substring in the input string s1.\n//dp[i]: Represents the number of ways to decode the substring starting from index i until the end of the string.\n    static boolean isSafe(char c1) {\n        return c1 != '0';\n    }\n\n    static boolean isSafe(char c1, char c2) {\n        return c1 == '1' || (c1 == '2' && c2 <= '6');\n    }\n\n    static int numDecodings(String s1) {\n        int n = s1.length();\n        int[] dp = new int[n + 1];\n        dp[n] = 1;\n        char[] s = s1.toCharArray();\n        if (isSafe(s[n - 1])) dp[n - 1] = 1;\n        for (int i = n - 2; i >= 0; --i) {\n            if (isSafe(s[i]))\n                dp[i] += dp[i + 1];\n            if (isSafe(s[i], s[i + 1]))\n                dp[i] += dp[i + 2];\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[0];\n    }\n}"
    }
  },
  "92": {
    "solution": {
      "linked-list": "/*\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n*/\n\nclass Solution {\n    private ListNode successor = null;\n\n    public ListNode reverseBetween(ListNode head, int left, int right) {\n        if (left == 1) {\n            return reverseN(head, right);\n        }\n        head.next = reverseBetween(head.next, left - 1, right - 1);\n        return head;\n    }\n\n    private ListNode reverseN(ListNode head, int n) {\n        if (n == 1) {\n            successor = head.next;\n            return head;\n        }\n\n        ListNode last = reverseN(head.next, n - 1);\n        head.next.next = head;\n        head.next = successor;\n\n        return last;\n    }\n}"
    }
  },
  "93": {
    "solution": {
      "backtracking": "import java.util.*;\n\npublic class Solution {\n    public List<String> restoreIpAddresses(String s) {\n        List<String> result = new ArrayList<>();\n        List<String> segments = new ArrayList<>();\n        dfs(s, 0, segments, result);\n        return result;\n    }\n\n    private void dfs(String s, int start, List<String> segments, List<String> result) {\n        if (segments.size() == 4) {\n            if (start == s.length()) {\n                result.add(String.join(\".\", segments));\n            }\n            return;\n        }\n\n        for (int len = 1; len <= 3; len++) {\n            if (start + len > s.length()) break;\n\n            String segment = s.substring(start, start + len);\n\n            if (isValid(segment)) {\n                segments.add(segment);\n                dfs(s, start + len, segments, result);\n                segments.remove(segments.size() - 1); // backtrack\n            }\n        }\n    }\n\n    private boolean isValid(String segment) {\n        if (segment.length() == 0 || segment.length() > 3) return false;\n        if (segment.startsWith(\"0\") && segment.length() > 1) return false;\n\n        int value = Integer.parseInt(segment);\n        return value >= 0 && value <= 255;\n    }\n}"
    }
  },
  "94": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> inorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        inorder(root, result);\n        return result;\n    }\n\n    private void inorder(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n        inorder(node.left, result);\n        result.add(node.val);\n        inorder(node.right, result);\n    }\n}"
    }
  },
  "95": {
    "solution": {
      "binary-search-tree": "\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n\n    TreeNode() {\n    }\n\n    TreeNode(int val) {\n        this.val = val;\n    }\n\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\npublic class Solution {\n    public List<TreeNode> generateTrees(int n) {\n        if (n == 0)\n            return new ArrayList<>();\n        return generateTrees(1, n);\n    }\n\n    private List<TreeNode> generateTrees(int start, int end) {\n        List<TreeNode> allTrees = new ArrayList<>();\n        if (start > end) {\n            allTrees.add(null);\n            return allTrees;\n        }\n\n        for (int i = start; i <= end; i++) {\n            // all possible left subtrees if i is chosen to be a root\n            List<TreeNode> leftTrees = generateTrees(start, i - 1);\n\n            // all possible right subtrees if i is chosen to be a root\n            List<TreeNode> rightTrees = generateTrees(i + 1, end);\n\n            // connect left and right subtrees to the root i\n            for (TreeNode left : leftTrees) {\n                for (TreeNode right : rightTrees) {\n                    TreeNode currTree = new TreeNode(i);\n                    currTree.left = left;\n                    currTree.right = right;\n                    allTrees.add(currTree);\n                }\n            }\n        }\n        return allTrees;\n    }\n}\n"
    }
  },
  "96": {
    "solution": {
      "binary-search-tree": "public class Solution {\n\n    public int numTrees(int n) {\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        dp[1] = 1;\n        for (int nodes = 2; nodes <= n; nodes++) {\n            for (int root = 1; root <= nodes; root++) {\n                dp[nodes] += dp[root - 1] * dp[nodes - root];\n            }\n        }\n        return dp[n];\n    }\n\n}\n"
    }
  },
  "97": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public boolean isInterleave(String s1, String s2, String s3) {\n        int m = s1.length();\n        int n = s2.length();\n        if (m + n != s3.length()) return false;\n        boolean[] dp = new boolean[n + 1];\n        // dp[n] indicates whether it's possible to form s3 by interleaving characters from s1 and \n        // first n characters from s2.\n        for (int i = 0; i <= m; ++i)\n            for (int j = 0; j <= n; ++j)\n                if (i == 0 && j == 0)\n                    dp[j] = true;\n                else if (i == 0)\n                    dp[j] = dp[j - 1] && s2.charAt(j - 1) == s3.charAt(j - 1);\n                else if (j == 0)\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i - 1);\n                else\n                    dp[j] = dp[j] && s1.charAt(i - 1) == s3.charAt(i + j - 1) ||\n                            dp[j - 1] && s2.charAt(j - 1) == s3.charAt(i + j - 1);\n        return dp[n];\n    }\n}"
    }
  },
  "98": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode prev = null;\n\n    public boolean isValidBST(TreeNode root) {\n        return inorder(root);\n    }\n\n    private boolean inorder(TreeNode node) {\n        if (node == null) return true;\n\n        // Left\n        if (!inorder(node.left)) return false;\n\n        // Current\n        if (prev != null && node.val <= prev.val) return false;\n        prev = node;\n\n        // Right\n        return inorder(node.right);\n    }\n}"
    }
  },
  "99": {
    "solution": {
      "binary-search-tree": "// Morris Algorithm\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\npublic class Solution {\n\n    public void recoverTree(TreeNode root) {\n        TreeNode first = null;\n        TreeNode second = null;\n        TreeNode prev = null;\n        TreeNode temp = null;\n\n        while (root != null) {\n            if (root.left != null) {\n                // Find the rightmost node in the left subtree or link it to the current root\n                temp = root.left;\n                while (temp.right != null && temp.right != root) {\n                    temp = temp.right;\n                }\n\n                if (temp.right != null) {\n                    // Unlink the rightmost node from the current root\n                    if (prev != null && root.val < prev.val) {\n                        if (first == null) {\n                            first = prev;\n                        }\n                        second = root;\n                    }\n                    prev = root;\n\n                    temp.right = null;\n                    root = root.right;\n                } else {\n                    // Link the rightmost node to the current root, threading\n                    temp.right = root;\n                    root = root.left;\n                }\n            } else {\n                // Check for swapped nodes\n                if (prev != null && root.val < prev.val) {\n                    if (first == null) {\n                        first = prev;\n                    }\n                    second = root;\n                }\n                prev = root;\n\n                root = root.right;\n            }\n        }\n\n        // Swap the values of the two nodes\n        if (first != null && second != null) {\n            int tempVal = first.val;\n            first.val = second.val;\n            second.val = tempVal;\n        }\n    }\n}\n"
    }
  },
  "100": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public boolean isSameTree(TreeNode p, TreeNode q) {\n        if (p == null && q == null) return true;\n        if (p == null || q == null || p.val != q.val) return false;\n        return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);\n    }\n}"
    }
  },
  "101": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public boolean isSymmetric(TreeNode root) {\n        return root == null || isMirror(root.left, root.right);\n    }\n    private boolean isMirror(TreeNode t1, TreeNode t2) {\n        if (t1 == null && t2 == null) return true;\n        if (t1 == null || t2 == null || t1.val != t2.val) return false;\n        return isMirror(t1.left, t2.right) && isMirror(t1.right, t2.left);\n    }\n}"
    }
  },
  "102": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> levelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            result.add(level);\n        }\n        return result;\n    }\n}"
    }
  },
  "103": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        boolean leftToRight = true;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            LinkedList<Integer> level = new LinkedList<>();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (leftToRight) {\n                    level.addLast(node.val);\n                } else {\n                    level.addFirst(node.val);\n                }\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            result.add(level);\n            leftToRight = !leftToRight;\n        }\n        return result;\n    }\n}"
    }
  },
  "104": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public int maxDepth(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(maxDepth(root.left), maxDepth(root.right));\n    }\n}"
    }
  },
  "105": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    private Map<Integer, Integer> inorderMap;\n    private int preorderIndex = 0;\n\n    public TreeNode buildTree(int[] preorder, int[] inorder) {\n        inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        return build(preorder, 0, inorder.length - 1);\n    }\n\n    private TreeNode build(int[] preorder, int left, int right) {\n        if (left > right) return null;\n        int rootVal = preorder[preorderIndex++];\n        TreeNode root = new TreeNode(rootVal);\n        root.left = build(preorder, left, inorderMap.get(rootVal) - 1);\n        root.right = build(preorder, inorderMap.get(rootVal) + 1, right);\n        return root;\n    }\n}"
    }
  },
  "106": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    private Map<Integer, Integer> inorderMap;\n    private int postIndex;\n\n    public TreeNode buildTree(int[] inorder, int[] postorder) {\n        inorderMap = new HashMap<>();\n        for (int i = 0; i < inorder.length; i++) {\n            inorderMap.put(inorder[i], i);\n        }\n        postIndex = postorder.length - 1;\n        return build(postorder, 0, inorder.length - 1);\n    }\n\n    private TreeNode build(int[] postorder, int left, int right) {\n        if (left > right) return null;\n        int rootVal = postorder[postIndex--];\n        TreeNode root = new TreeNode(rootVal);\n        root.right = build(postorder, inorderMap.get(rootVal) + 1, right);\n        root.left = build(postorder, left, inorderMap.get(rootVal) - 1);\n        return root;\n    }\n}"
    }
  },
  "107": {
    "solution": {
      "tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> levelOrderBottom(TreeNode root) {\n        LinkedList<List<Integer>> result = new LinkedList<>();\n        if (root == null) return result;\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            List<Integer> level = new ArrayList<>();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                level.add(node.val);\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            result.addFirst(level);\n        }\n        return result;\n    }\n}"
    }
  },
  "108": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode sortedArrayToBST(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return null;\n        }\n        return constructBST(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode constructBST(int[] nums, int left, int right) {\n        if (left > right) {\n            return null;\n        }\n\n        int mid = left + (right - left) / 2;\n        TreeNode node = new TreeNode(nums[mid]);\n\n        node.left = constructBST(nums, left, mid - 1);\n        node.right = constructBST(nums, mid + 1, right);\n\n        return node;\n    }\n}"
    }
  },
  "109": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode sortedListToBST(ListNode head) {\n        if (head == null) {\n            return null;\n        }\n        return sortedListToBSTHelper(head, null);\n    }\n\n    private TreeNode sortedListToBSTHelper(ListNode head, ListNode tail) {\n        if (head == tail) {\n            return null;\n        }\n\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != tail && fast.next != tail) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        TreeNode node = new TreeNode(slow.val);\n        node.left = sortedListToBSTHelper(head, slow);\n        node.right = sortedListToBSTHelper(slow.next, tail);\n        return node;\n    }\n}"
    }
  },
  "110": {
    "solution": {
      "binary-tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nclass Solution {\n    public boolean isBalanced(TreeNode root) {\n        return dfs(root) != -1;\n    }\n\n    private int dfs(TreeNode node) {\n        if (node == null) return 0;\n\n        int leftHeight = dfs(node.left);\n        if (leftHeight == -1) return -1;\n\n        int rightHeight = dfs(node.right);\n        if (rightHeight == -1) return -1;\n\n        if (Math.abs(leftHeight - rightHeight) > 1) return -1;\n\n        return Math.max(leftHeight, rightHeight) + 1;\n    }\n}"
    }
  },
  "111": {
    "solution": {
      "breadth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nimport java.util.*;\n\nclass Solution {\n    public int minDepth(TreeNode root) {\n        if (root == null) return 0;\n\n        Queue<Pair<TreeNode, Integer>> q = new LinkedList<>();\n        q.offer(new Pair<>(root, 1));\n\n        while (!q.isEmpty()) {\n            Pair<TreeNode, Integer> pair = q.poll();\n            TreeNode node = pair.getKey();\n            int depth = pair.getValue();\n\n            if (node.left == null && node.right == null) return depth;\n\n            if (node.left != null) q.offer(new Pair<>(node.left, depth + 1));\n            if (node.right != null) q.offer(new Pair<>(node.right, depth + 1));\n        }\n\n        return 0;\n    }\n}"
    }
  },
  "112": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nclass Solution {\n    public boolean hasPathSum(TreeNode root, int targetSum) {\n        if (root == null) return false;\n\n        if (root.left == null && root.right == null && targetSum == root.val) return true;\n\n        int remainingSum = targetSum - root.val;\n        return hasPathSum(root.left, remainingSum) || hasPathSum(root.right, remainingSum);\n    }\n}"
    }
  },
  "113": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nimport java.util.*;\n\nclass Solution {\n    public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> currentPath = new ArrayList<>();\n        dfs(root, targetSum, currentPath, result);\n        return result;\n    }\n\n    private void dfs(TreeNode root, int targetSum, List<Integer> currentPath, List<List<Integer>> result) {\n        if (root == null) return;\n\n        currentPath.add(root.val);\n        if (root.left == null && root.right == null && root.val == targetSum) {\n            result.add(new ArrayList<>(currentPath));\n        } else {\n            dfs(root.left, targetSum - root.val, currentPath, result);\n            dfs(root.right, targetSum - root.val, currentPath, result);\n        }\n        currentPath.remove(currentPath.size() - 1);\n    }\n}"
    }
  },
  "114": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nclass Solution {\n    public void flatten(TreeNode root) {\n        TreeNode current = root;\n\n        while (current != null) {\n            if (current.left != null) {\n                TreeNode predecessor = current.left;\n                while (predecessor.right != null) {\n                    predecessor = predecessor.right;\n                }\n                predecessor.right = current.right;\n                current.right = current.left;\n                current.left = null;\n            }\n            current = current.right;\n        }\n    }\n}"
    }
  },
  "115": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numDistinct(String s, String t) {\n        int m = s.length();\n        int n = t.length();\n        int[] dp = new int[n + 1];\n        dp[0] = 1;\n        for (int i = 1; i <= m; ++i)\n            for (int j = n; j >= 1; --j)\n                if (s.charAt(i - 1) == t.charAt(j - 1))\n                    dp[j] += dp[j - 1];\n        System.out.println(Arrays.toString(dp));\n        return dp[n];\n    }\n}"
    }
  },
  "121": {
    "solution": {
      "dynamic-programming": "class Solution {\n    // dp[i] represents the minimum price of the stock among the prices encountered up to index i in the prices array.\n    // You want to maximize your profit by choosing a single day to buy one stock and choosing a different day in the future to sell that stock.\n\n    public int maxProfit(int[] prices) {\n        int res = 0;\n        int[] dp = new int[prices.length];\n        dp[0] = prices[0];\n        for (int i = 1; i < prices.length; i++) {\n            dp[i] = Math.min(dp[i - 1], prices[i]);\n        }\n        for (int i = 0; i < prices.length; i++) {\n            res = Math.max(res, prices[i] - dp[i]);\n        }\n        System.out.println(Arrays.toString(dp));\n        return res;\n    }\n}"
    }
  },
  "122": {
    "solution": {
      "dynamic-programming": "class Solution {\n\n    // dp[i]: Maximum profit attainable on or before day i.\n\n    public static int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n\n        int n = prices.length;\n        int[] dp = new int[n];\n\n        dp[0] = 0;\n        for (int i = 1; i < n; i++) {\n            int diff = prices[i] - prices[i - 1];\n            dp[i] = Math.max(dp[i - 1] + diff, dp[i - 1]);\n        }\n\n        return dp[n - 1];\n    }\n}"
    }
  },
  "123": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public static int maxProfit(int[] prices) {\n        if (prices == null || prices.length == 0) {\n            return 0;\n        }\n\n        int n = prices.length;\n        int[] leftProfit = new int[n];\n        int[] rightProfit = new int[n];\n\n        // Calculate maximum profit from left to right\n        int minPrice = prices[0];\n        leftProfit[0] = 0;\n        for (int i = 1; i < n; i++) {\n            minPrice = Math.min(minPrice, prices[i]);\n            leftProfit[i] = Math.max(leftProfit[i - 1], prices[i] - minPrice);\n        }\n\n        // Calculate maximum profit from right to left\n        int maxPrice = prices[n - 1];\n        rightProfit[n - 1] = 0;\n        for (int i = n - 2; i >= 0; i--) {\n            maxPrice = Math.max(maxPrice, prices[i]);\n            rightProfit[i] = Math.max(rightProfit[i + 1], maxPrice - prices[i]);\n        }\n\n        int maxProfit = 0;\n        // Find the maximum profit by combining left and right profits\n        for (int i = 0; i < n; i++) {\n            maxProfit = Math.max(maxProfit, leftProfit[i] + rightProfit[i]);\n        }\n\n        return maxProfit;\n    }\n\n    public static void main(String[] args) {\n        int[] prices = { 3, 3, 5, 0, 0, 3, 1, 4 };\n        System.out.println(\"Maximum profit: \" + maxProfit(prices));\n    }\n}"
    }
  },
  "124": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\nclass Solution {\n    public int maxPathSum(TreeNode root) {\n        int[] maxSum = new int[]{Integer.MIN_VALUE};\n        dfs(root, maxSum);\n        return maxSum[0];\n    }\n\n    private int dfs(TreeNode node, int[] maxSum) {\n        if (node == null) return 0;\n\n        int left = Math.max(dfs(node.left, maxSum), 0);\n        int right = Math.max(dfs(node.right, maxSum), 0);\n\n        int currentMax = node.val + left + right;\n        maxSum[0] = Math.max(maxSum[0], currentMax);\n\n        return node.val + Math.max(left, right);\n    }\n}"
    }
  },
  "125": {
    "solution": {
      "two-pointers": "class Solution {\n    public boolean isPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        \n        while (left < right) {\n            char c1 = s.charAt(left);\n            char c2 = s.charAt(right);\n            \n            if (!Character.isLetterOrDigit(c1)) {\n                left++;\n            } else if (!Character.isLetterOrDigit(c2)) {\n                right--;\n            } else {\n                if (Character.toLowerCase(c1) != Character.toLowerCase(c2)) {\n                    return false;\n                }\n                left++;\n                right--;\n            }\n        }\n        \n        return true;\n    }\n}\n"
    }
  },
  "126": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    private boolean isOneLetterDifferent(String word1, String word2) {\n        int diff = 0;\n        for (int i = 0; i < word1.length(); i++) {\n            if (word1.charAt(i) != word2.charAt(i)) {\n                diff++;\n                if (diff > 1) return false;\n            }\n        }\n        return diff == 1;\n    }\n\n    private void bfs(List<List<Integer>> adjList, List<List<Integer>> predecessors, int start, int end) {\n        int n = adjList.size();\n        int[] distance = new int[n];\n        Arrays.fill(distance, Integer.MAX_VALUE);\n        Queue<Integer> queue = new LinkedList<>();\n\n        queue.offer(start);\n        predecessors.get(start).add(-1);\n        distance[start] = 0;\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : adjList.get(current)) {\n                if (distance[neighbor] > distance[current] + 1) {\n                    distance[neighbor] = distance[current] + 1;\n                    queue.offer(neighbor);\n                    predecessors.get(neighbor).clear();\n                    predecessors.get(neighbor).add(current);\n                } else if (distance[neighbor] == distance[current] + 1) {\n                    predecessors.get(neighbor).add(current);\n                }\n            }\n        }\n    }\n\n    private void dfs(List<List<String>> result, List<String> path, List<List<Integer>> predecessors,\n                     int currentIndex, List<String> wordList) {\n        if (currentIndex == -1) {\n            List<String> validPath = new ArrayList<>(path);\n            Collections.reverse(validPath);\n            result.add(validPath);\n            return;\n        }\n        for (int prev : predecessors.get(currentIndex)) {\n            path.add(wordList.get(currentIndex));\n            dfs(result, path, predecessors, prev, wordList);\n            path.remove(path.size() - 1);\n        }\n    }\n\n    public List<List<String>> findLadders(String beginWord, String endWord, List<String> wordList) {\n        int n = wordList.size();\n        int startIndex = -1, endIndex = -1;\n\n        for (int i = 0; i < n; i++) {\n            if (wordList.get(i).equals(beginWord)) startIndex = i;\n            if (wordList.get(i).equals(endWord)) endIndex = i;\n        }\n\n        if (endIndex == -1) return new ArrayList<>();\n\n        if (startIndex == -1) {\n            wordList.add(0, beginWord);\n            startIndex = 0;\n            endIndex++;\n            n++;\n        }\n\n        List<List<Integer>> adjList = new ArrayList<>();\n        for (int i = 0; i < n; i++) adjList.add(new ArrayList<>());\n\n        for (int i = 0; i < n - 1; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if (isOneLetterDifferent(wordList.get(i), wordList.get(j))) {\n                    adjList.get(i).add(j);\n                    adjList.get(j).add(i);\n                }\n            }\n        }\n\n        List<List<Integer>> predecessors = new ArrayList<>();\n        for (int i = 0; i < n; i++) predecessors.add(new ArrayList<>());\n\n        bfs(adjList, predecessors, startIndex, endIndex);\n\n        List<List<String>> result = new ArrayList<>();\n        List<String> path = new ArrayList<>();\n        dfs(result, path, predecessors, endIndex, wordList);\n\n        return result;\n    }\n}"
    }
  },
  "127": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public int ladderLength(String beginWord, String endWord, List<String> wordList) {\n        Set<String> wordSet = new HashSet<>(wordList);\n        if (!wordSet.contains(endWord)) return 0; // End word must be in the wordList\n\n        Queue<String> queue = new LinkedList<>();\n        queue.add(beginWord);\n        int level = 1; // Start transformation count\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String word = queue.poll();\n                char[] wordArr = word.toCharArray();\n                \n                for (int j = 0; j < wordArr.length; j++) {\n                    char originalChar = wordArr[j];\n                    \n                    for (char c = 'a'; c <= 'z'; c++) {\n                        if (c == originalChar) continue; // Skip same letter\n                        \n                        wordArr[j] = c;\n                        String newWord = new String(wordArr);\n\n                        if (newWord.equals(endWord)) return level + 1; // Found transformation\n\n                        if (wordSet.contains(newWord)) {\n                            queue.add(newWord);\n                            wordSet.remove(newWord); // Mark as visited\n                        }\n                    }\n                    \n                    wordArr[j] = originalChar; // Restore original character\n                }\n            }\n            level++; // Increase transformation count\n        }\n\n        return 0; // No possible transformation sequence\n    }\n}\n"
    }
  },
  "128": {
    "solution": {
      "array": "import java.util.HashSet;\n\nclass Solution {\n    public int longestConsecutive(int[] nums) {\n        if (nums == null || nums.length == 0) return 0;\n\n        HashSet<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n\n        int maxLength = 0;\n        for (int num : set) {\n            if (!set.contains(num - 1)) { // Check if it's the start of a sequence\n                int currentNum = num;\n                int currentLength = 1;\n\n                while (set.contains(currentNum + 1)) {\n                    currentNum++;\n                    currentLength++;\n                }\n\n                maxLength = Math.max(maxLength, currentLength);\n            }\n        }\n\n        return maxLength;\n    }\n}\n"
    }
  },
  "129": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public int sumNumbers(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode node, int currentSum) {\n        if (node == null) return 0;\n\n        currentSum = currentSum * 10 + node.val;\n\n        if (node.left == null && node.right == null) {\n            return currentSum;\n        }\n\n        return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n    }\n}"
    }
  },
  "130": {
    "solution": {
      "union-find": "",
      "matrix": "class Solution {\n    public void solve(char[][] board) {\n        if (board == null || board.length == 0 || board[0].length == 0) {\n            return;\n        }\n\n        int m = board.length;\n        int n = board[0].length;\n\n        for (int i = 0; i < m; i++) {\n            if (board[i][0] == 'O') {\n                dfs(board, i, 0);\n            }\n            if (board[i][n - 1] == 'O') {\n                dfs(board, i, n - 1);\n            }\n        }\n\n        for (int j = 0; j < n; j++) {\n            if (board[0][j] == 'O') {\n                dfs(board, 0, j);\n            }\n            if (board[m - 1][j] == 'O') {\n                dfs(board, m - 1, j);\n            }\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (board[i][j] == 'O') {\n                    board[i][j] = 'X';\n                } else if (board[i][j] == '*') {\n                    board[i][j] = 'O';\n                }\n            }\n        }\n    }\n\n    private void dfs(char[][] board, int i, int j) {\n        int m = board.length;\n        int n = board[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n || board[i][j] != 'O') {\n            return;\n        }\n        board[i][j] = '*';\n        dfs(board, i, j + 1);\n        dfs(board, i + 1, j);\n        dfs(board, i, j - 1);\n        dfs(board, i - 1, j);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] board = {\n            {'X', 'X', 'X', 'X'},\n            {'X', 'O', 'O', 'X'},\n            {'X', 'X', 'O', 'X'},\n            {'X', 'O', 'X', 'X'}\n        };\n\n        solution.solve(board);\n\n        for (char[] row : board) {\n            System.out.println(new String(row));\n        }\n    }\n}\n"
    }
  },
  "131": {
    "solution": {
      "dynamic-programming": "",
      "backtracking": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<List<String>> partition(String s) {\n        List<List<String>> result = new ArrayList<>();\n        dfs(s, 0, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void dfs(String s, int start, List<String> current, List<List<String>> result) {\n        if (start == s.length()) {\n            result.add(new ArrayList<>(current));\n            return;\n        }\n        for (int end = start; end < s.length(); end++) {\n            String substring = s.substring(start, end + 1);\n            if (isPalindrome(substring)) {\n                current.add(substring);\n                dfs(s, end + 1, current, result);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n\n    private boolean isPalindrome(String s) {\n        int left = 0;\n        int right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return false;\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"aab\";\n        List<List<String>> result = solution.partition(s);\n        for (List<String> partition : result) {\n            System.out.println(partition);\n        }\n    }\n}\n"
    }
  },
  "132": {
    "solution": {
      "dynamic-programming": "import java.util.Arrays;\n\nclass Solution {\n    public int minCut(String s) {\n        int n = s.length();\n        boolean[][] isPalindrome = new boolean[n][n];\n        int[] dp = new int[n];\n\n        // Step 1: Precompute palindromes using DP\n        for (int len = 1; len <= n; len++) {\n            for (int i = 0; i + len - 1 < n; i++) {\n                int j = i + len - 1;\n                if (s.charAt(i) == s.charAt(j)) {\n                    if (len <= 2) {\n                        isPalindrome[i][j] = true;\n                    } else {\n                        isPalindrome[i][j] = isPalindrome[i + 1][j - 1];\n                    }\n                }\n            }\n        }\n\n        // Step 2: DP to find the minimum cuts\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        for (int i = 0; i < n; i++) {\n            if (isPalindrome[0][i]) {\n                dp[i] = 0;\n            } else {\n                for (int j = 0; j < i; j++) {\n                    if (isPalindrome[j + 1][i]) {\n                        dp[i] = Math.min(dp[i], dp[j] + 1);\n                    }\n                }\n            }\n        }\n\n        return dp[n - 1];\n    }\n}"
    }
  },
  "133": {
    "solution": {
      "graph": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> neighbors;\n    public Node() {\n        val = 0;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val) {\n        val = _val;\n        neighbors = new ArrayList<Node>();\n    }\n    public Node(int _val, ArrayList<Node> _neighbors) {\n        val = _val;\n        neighbors = _neighbors;\n    }\n}\n*/\n\nclass Solution {\n    private Map<Node, Node> cloneMap = new HashMap<>();\n\n    public Node cloneGraph(Node node) {\n        if (node == null) return null;\n        return dfs(node);\n    }\n\n    private Node dfs(Node node) {\n        if (cloneMap.containsKey(node)) {\n            return cloneMap.get(node);\n        }\n\n        Node clone = new Node(node.val);\n        cloneMap.put(node, clone);\n\n        for (Node neighbor : node.neighbors) {\n            clone.neighbors.add(dfs(neighbor));\n        }\n\n        return clone;\n    }\n}"
    }
  },
  "134": {
    "solution": {
      "greedy": "class Solution {\n    public int canCompleteCircuit(int[] gas, int[] cost) {\n        int totalGas = 0, totalCost = 0, tank = 0, start = 0;\n\n        for (int i = 0; i < gas.length; i++) {\n            totalGas += gas[i];\n            totalCost += cost[i];\n            tank += gas[i] - cost[i];\n\n            if (tank < 0) {\n                start = i + 1;\n                tank = 0;\n            }\n        }\n\n        return totalGas >= totalCost ? start : -1;\n    }\n}"
    }
  },
  "135": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] candies = new int[n];\n        Arrays.fill(candies, 1);\n\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n            }\n        }\n\n        int total = 0;\n        for (int candy : candies) {\n            total += candy;\n        }\n\n        return total;\n    }\n}"
    }
  },
  "136": {
    "solution": {
      "array": "class Solution {\n    public int singleNumber(int[] nums) {\n        int result = 0;\n        for (int num : nums) {\n            result ^= num;\n        }\n        return result;\n    }\n}"
    }
  },
  "137": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int singleNumber(int[] nums) {\n        int ones = 0, twos = 0;\n        for (int num : nums) {\n            ones = (ones ^ num) & ~twos;\n            twos = (twos ^ num) & ~ones;\n        }\n        return ones;\n    }\n}"
    }
  },
  "138": {
    "solution": {
      "linked-list": "/*\nclass Node {\n    int val;\n    Node next;\n    Node random;\n    Node(int val) {\n        this.val = val;\n    }\n}\n*/\n\nclass Solution {\n    public Node copyRandomList(Node head) {\n        if (head == null) return null;\n\n        Node current = head;\n        while (current != null) {\n            Node newNode = new Node(current.val);\n            newNode.next = current.next;\n            current.next = newNode;\n            current = newNode.next;\n        }\n\n        current = head;\n        while (current != null) {\n            if (current.random != null) {\n                current.next.random = current.random.next;\n            }\n            current = current.next.next;\n        }\n\n        Node dummy = new Node(0);\n        Node copy = dummy;\n        current = head;\n\n        while (current != null) {\n            Node temp = current.next;\n            current.next = temp.next;\n            copy.next = temp;\n            copy = copy.next;\n            current = current.next;\n        }\n\n        return dummy.next;\n    }\n}"
    }
  },
  "139": {
    "solution": {
      "dynamic-programming": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    // dp[i] represents whether the substring of s from index 0 to index i-1 can be\n    // segmented into words from the given wordDict.\n    static boolean wordBreak(String s, List<String> wordDict) {\n        int n = s.length();\n        Set<String> wordSet = new HashSet<>(wordDict);\n        boolean[] dp = new boolean[n + 1];\n        dp[0] = true;\n        for (int i = 1; i <= n; ++i)\n            for (int j = 0; j < i; ++j)\n                if (dp[j] && wordSet.contains(s.substring(j, i))) {\n                    dp[i] = true;\n                    break;\n                }\n        System.out.println(Arrays.toString(dp));\n        // [true, false, false, false, true, false, false, false, true]\n        return dp[n];\n    }\n}"
    }
  },
  "140": {
    "solution": {
      "dynamic-programming": "",
      "backtracking": "import java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\nclass Solution {\n\n    public List<String> wordBreak(String s, List<String> wordDict) {\n        return dfs(s, wordDict, new HashMap<>());\n    }\n\n    private List<String> dfs(String s, List<String> wordDict, Map<String, List<String>> memo) {\n        if (memo.containsKey(s)) {\n            return memo.get(s);\n        }\n        if (s.length() == 0) {\n            List<String> baseResult = new ArrayList<>();\n            baseResult.add(\"\");\n            return baseResult;\n        }\n\n        List<String> res = new ArrayList<>();\n        for (String word : wordDict) {\n            if (s.startsWith(word)) {\n                List<String> sublist = dfs(s.substring(word.length()), wordDict, memo);\n                for (String sub : sublist) {\n                    res.add(word + (sub.isEmpty() ? \"\" : \" \") + sub);\n                }\n            }\n        }\n        memo.put(s, res);\n        return res;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"catsanddog\";\n        List<String> wordDict = new ArrayList<>();\n        wordDict.add(\"cat\");\n        wordDict.add(\"cats\");\n        wordDict.add(\"and\");\n        wordDict.add(\"sand\");\n        wordDict.add(\"dog\");\n\n        List<String> result = solution.wordBreak(s, wordDict);\n        for (String sentence : result) {\n            System.out.println(sentence);\n        }\n    }\n}\n"
    }
  },
  "141": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) {\n *         val = x;\n *         next = null;\n *     }\n * }\n */\npublic class Solution {\n    public boolean hasCycle(ListNode head) {\n        if (head == null || head.next == null) {\n            return false;\n        }\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (slow != fast) {\n            if (fast == null || fast.next == null) {\n                return false;\n            }\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n        return true;\n    }\n}"
    }
  },
  "142": {
    "solution": {
      "two-pointers": "public class Solution {\n    public ListNode detectCycle(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head;\n\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n            if (slow == fast) {\n                slow = head;\n                while (slow != fast) {\n                    slow = slow.next;\n                    fast = fast.next;\n                }\n                return slow; \n            }\n        }\n\n        return null; \n    }\n}\n"
    }
  },
  "143": {
    "solution": {
      "two-pointers": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public void reorderList(ListNode head) {\n        if (head == null || head.next == null) return;\n\n        // Step 1: Find the middle node\n        ListNode slow = head, fast = head;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        // Step 2: Reverse the second half\n        ListNode secondHalf = reverseList(slow.next);\n        slow.next = null; // Split the list\n\n        // Step 3: Merge two halves alternately\n        ListNode firstHalf = head;\n        while (secondHalf != null) {\n            ListNode temp1 = firstHalf.next;\n            ListNode temp2 = secondHalf.next;\n\n            firstHalf.next = secondHalf;\n            secondHalf.next = temp1;\n\n            firstHalf = temp1;\n            secondHalf = temp2;\n        }\n    }\n\n    // Helper function to reverse a linked list\n    private ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        while (head != null) {\n            ListNode next = head.next;\n            head.next = prev;\n            prev = head;\n            head = next;\n        }\n        return prev;\n    }\n}"
    }
  },
  "144": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> preorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        dfs(root, result);\n        return result;\n    }\n\n    private void dfs(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n\n        result.add(node.val);\n        dfs(node.left, result);\n        dfs(node.right, result);\n    }\n}"
    }
  },
  "145": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> postorderTraversal(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        dfs(root, result);\n        return result;\n    }\n\n    private void dfs(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n\n        dfs(node.left, result);\n        dfs(node.right, result);\n        result.add(node.val);\n    }\n}"
    }
  },
  "146": {
    "solution": {
      "doubly-linked-list": "class LRUCache {\n    class Node {\n        int key;\n        int value;\n        Node prev;\n        Node next;\n        \n        public Node(int key, int value) {\n            this.key = key;\n            this.value = value;\n        }\n    }\n    \n    private int capacity;\n    private Map<Integer, Node> map;\n    private Node head;\n    private Node tail;\n    \n    public LRUCache(int capacity) {\n        this.capacity = capacity;\n        map = new HashMap<>();\n        head = new Node(-1, -1);\n        tail = new Node(-1, -1);\n        head.next = tail;\n        tail.prev = head;\n    }\n    \n    public int get(int key) {\n        if (!map.containsKey(key)) {\n            return -1;\n        }\n        \n        Node node = map.get(key);\n        moveToHead(node);\n        \n        return node.value;\n    }\n    \n    public void put(int key, int value) {\n        if (map.containsKey(key)) {\n            Node node = map.get(key);\n            node.value = value;\n            moveToHead(node);\n        } else {\n            Node newNode = new Node(key, value);\n            map.put(key, newNode);\n            addToHead(newNode);\n            \n            if (map.size() > capacity) {\n                Node removed = removeTail();\n                map.remove(removed.key);\n            }\n        }\n    }\n    \n    private void moveToHead(Node node) {\n        removeNode(node);\n        addToHead(node);\n    }\n    \n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n    \n    private void addToHead(Node node) {\n        node.next = head.next;\n        node.next.prev = node;\n        head.next = node;\n        node.prev = head;\n    }\n    \n    private Node removeTail() {\n        Node nodeToRemove = tail.prev;\n        removeNode(nodeToRemove);\n        return nodeToRemove;\n    }\n}\n\npublic class Main {\n    public static void main(String[] args) {\n        LRUCache cache = new LRUCache(2); // Capacity is 2\n        cache.put(1, 1);\n        cache.put(2, 2);\n        System.out.println(cache.get(1)); // Output: 1\n        cache.put(3, 3);\n        System.out.println(cache.get(2)); // Output: -1 (not found)\n        cache.put(4, 4);\n        System.out.println(cache.get(1)); // Output: -1 (not found)\n        System.out.println(cache.get(3)); // Output: 3\n        System.out.println(cache.get(4)); // Output: 4\n    }\n}\n"
    }
  },
  "147": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode insertionSortList(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode dummy = new ListNode(0); // Dummy node for sorted list\n        ListNode current = head; // Pointer to traverse the original list\n\n        while (current != null) {\n            ListNode nextNode = current.next; // Store next node\n            ListNode prev = dummy; // Start from dummy node\n\n            // Find the correct position in the sorted list\n            while (prev.next != null && prev.next.val < current.val) {\n                prev = prev.next;\n            }\n\n            // Insert current node into sorted list\n            current.next = prev.next;\n            prev.next = current;\n\n            current = nextNode; // Move to next node\n        }\n\n        return dummy.next; // Head of sorted list\n    }\n}"
    }
  },
  "148": {
    "solution": {
      "merge-sort": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode sortList(ListNode head) {\n        if (head == null || head.next == null) {\n            return head;\n        }\n\n        ListNode mid = getMid(head);\n        ListNode left = head;\n        ListNode right = mid.next;\n        mid.next = null; \n        left = sortList(left);\n        right = sortList(right);\n\n        return merge(left, right);\n    }\n\n    private ListNode getMid(ListNode head) {\n        ListNode slow = head;\n        ListNode fast = head.next;\n        while (fast != null && fast.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        return slow;\n    }\n\n    private ListNode merge(ListNode l1, ListNode l2) {\n        ListNode dummy = new ListNode(0);\n        ListNode current = dummy;\n\n        while (l1 != null && l2 != null) {\n            if (l1.val < l2.val) {\n                current.next = l1;\n                l1 = l1.next;\n            } else {\n                current.next = l2;\n                l2 = l2.next;\n            }\n            current = current.next;\n        }\n\n        if (l1 != null) {\n            current.next = l1;\n        } else {\n            current.next = l2;\n        }\n\n        return dummy.next;\n    }\n}\n"
    }
  },
  "149": {
    "solution": {
      "geometry": "import java.util.*;\n\nclass Solution {\n    public int maxPoints(int[][] points) {\n        if (points.length <= 1) return points.length;\n\n        int maxPointsOnLine = 1;\n\n        for (int i = 0; i < points.length; i++) {\n            Map<String, Integer> slopeCount = new HashMap<>();\n            int duplicate = 0, vertical = 0, localMax = 0;\n\n            for (int j = i + 1; j < points.length; j++) {\n                int dx = points[j][0] - points[i][0];\n                int dy = points[j][1] - points[i][1];\n\n                if (dx == 0 && dy == 0) {\n                    duplicate++;\n                } else if (dx == 0) {\n                    vertical++;\n                } else {\n                    int gcd = gcd(dx, dy);\n                    dx /= gcd;\n                    dy /= gcd;\n\n                    String slope = dy + \"/\" + dx;\n                    slopeCount.put(slope, slopeCount.getOrDefault(slope, 0) + 1);\n                    localMax = Math.max(localMax, slopeCount.get(slope));\n                }\n            }\n\n            localMax = Math.max(localMax, vertical);\n            maxPointsOnLine = Math.max(maxPointsOnLine, localMax + duplicate + 1);\n        }\n\n        return maxPointsOnLine;\n    }\n\n    private int gcd(int a, int b) {\n        return b == 0 ? a : gcd(b, a % b);\n    }\n}"
    }
  },
  "150": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public int evalRPN(String[] tokens) {\n        Stack<Integer> stack = new Stack<>();\n\n        for (String token : tokens) {\n            if (\"+\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a + b);\n            } else if (\"-\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a - b);\n            } else if (\"*\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a * b);\n            } else if (\"/\".equals(token)) {\n                int b = stack.pop();\n                int a = stack.pop();\n                stack.push(a / b);\n            } else {\n                stack.push(Integer.parseInt(token));\n            }\n        }\n\n        return stack.pop();\n    }\n}"
    }
  },
  "151": {
    "solution": {
      "string": "import java.util.*;\n\nclass Solution {\n    public String reverseWords(String s) {\n        s = s.trim(); // Remove leading and trailing spaces\n        String[] words = s.split(\"\\\\s+\"); // Split by spaces\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = words.length - 1; i >= 0; i--) {\n            sb.append(words[i]);\n            if (i > 0) {\n                sb.append(\" \");\n            }\n        }\n        \n        return sb.toString();\n    }\n}"
    }
  },
  "152": {
    "solution": {
      "dynamic-programming": "class Solution {\n    // the maximum product will always lie either from the starting of the array or from the end of the array.\n    public int maxProduct(int[] nums) {\n        int ans, prevMin, prevMax;\n        ans = prevMin = prevMax = nums[0];\n        for (int i = 1; i < nums.length; i++) {\n            int mini = prevMin * nums[i];\n            int maxi = prevMax * nums[i];\n            prevMin = Math.min(nums[i], Math.min(mini, maxi));\n            prevMax = Math.max(nums[i], Math.max(mini, maxi));\n            ans = Math.max(ans, prevMax);\n        }\n        return ans;\n    }\n}"
    }
  },
  "153": {
    "solution": {
      "array": "",
      "binary-search": "class Solution {\n    public int findMin(int[] nums) {\n        int low = 0, high = nums.length - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] > nums[high]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return nums[low];\n    }\n}"
    }
  },
  "154": {
    "solution": {
      "array": "class Solution {\n    public int findMin(int[] nums) {\n        int left = 0;\n        int right = nums.length - 1;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            \n            if (nums[mid] == nums[right]) {\n                right--; // Handle duplicates\n            } else if (nums[mid] < nums[right]) {\n                right = mid; // Minimum is in the left half\n            } else {\n                left = mid + 1; // Minimum is in the right half\n            }\n        }\n\n        return nums[left];\n    }\n}"
    }
  },
  "155": {
    "solution": {
      "stack": "import java.util.Stack;\n\nclass MinStack {\n    private Stack<Integer> stack;\n    private Stack<Integer> minStack;\n\n    public MinStack() {\n        stack = new Stack<>();\n        minStack = new Stack<>();\n    }\n\n    public void push(int val) {\n        stack.push(val);\n        if (minStack.isEmpty() || val <= minStack.peek()) {\n            minStack.push(val);\n        }\n    }\n\n    public void pop() {\n        if (stack.peek().equals(minStack.peek())) {\n            minStack.pop();\n        }\n        stack.pop();\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int getMin() {\n        return minStack.peek();\n    }\n}"
    }
  },
  "156": {
    "solution": {
      "depth-first-search": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public TreeNode upsideDownBinaryTree(TreeNode root) {\n        if (root == null || root.left == null) return root;\n\n        TreeNode newRoot = upsideDownBinaryTree(root.left);\n\n        root.left.left = root.right;\n        root.left.right = root;\n\n        root.left = null;\n        root.right = null;\n\n        return newRoot;\n    }\n}"
    }
  },
  "157": {
    "solution": {
      "interactive": "/**\n * The read4 API is defined in the parent class Reader4.\n *     int read4(char[] buffer4);\n */\n\npublic class Solution extends Reader4 {\n  /**\n   * @param buffer  Destination buffer\n   * @param charactersToRead Number of characters to read\n   * @return The number of actual characters read\n   */\n  public int read(char[] buffer, int charactersToRead) {\n    char[] tempBuffer = new char[4]; // Temporary buffer to store read characters\n    int tempIndex = 0;  // Index for tempBuffer\n    int tempSize = 0;   // Number of characters read into tempBuffer\n    int bufferIndex = 0; // Index for buffer\n\n    while (bufferIndex < charactersToRead) {\n      if (tempIndex == tempSize) {  // If all characters in tempBuffer are consumed\n        tempIndex = 0;              // Reset tempBuffer index\n        tempSize = read4(tempBuffer); // Read up to 4 characters from the file\n        if (tempSize == 0)           // If EOF is reached\n          return bufferIndex;\n      }\n      buffer[bufferIndex++] = tempBuffer[tempIndex++];\n    }\n\n    return bufferIndex;\n  }\n}"
    }
  },
  "158": {
    "solution": {
      "interactive": "/* The read4 API is defined in the parent class Reader4.\n   int read4(char[] buf4); */\n\npublic class Solution extends Reader4 {\n    private char[] buffer = new char[4];\n    private int bufferPointer = 0;\n    private int bufferCount = 0;\n\n    /**\n     * @param buf Destination buffer\n     * @param n Number of characters to read\n     * @return The number of actual characters read\n     */\n    public int read(char[] buf, int n) {\n        int totalRead = 0;\n\n        while (totalRead < n) {\n            if (bufferPointer == 0) {\n                bufferCount = read4(buffer);\n            }\n            if (bufferCount == 0) break;\n\n            while (totalRead < n && bufferPointer < bufferCount) {\n                buf[totalRead++] = buffer[bufferPointer++];\n            }\n\n            if (bufferPointer >= bufferCount) {\n                bufferPointer = 0;\n            }\n        }\n\n        return totalRead;\n    }\n}"
    }
  },
  "159": {
    "solution": {
      "sliding-window": "class Solution {\n    public int lengthOfLongestSubstringTwoDistinct(String s) {\n        Map<Character, Integer> count = new HashMap<>();\n        int n = s.length();\n        int ans = 0;\n        int left = 0;\n        for (int right = 0; right < n; ++right) {\n            char c = s.charAt(right);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n            while (count.size() > 2) {\n                char t = s.charAt(left++);\n                count.put(t, count.get(t) - 1);\n                if (count.get(t) == 0) {\n                    count.remove(t);\n                }\n            }\n            ans = Math.max(ans, right - left + 1);\n        }\n        return ans;\n    }\n}"
    }
  },
  "160": {
    "solution": {
      "linked-list": "/*\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode(int x) {\n        val = x;\n        next = null;\n    }\n}\n*/\n\npublic class Solution {\n    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {\n        if (headA == null || headB == null) return null;\n\n        int lenA = getLength(headA);\n        int lenB = getLength(headB);\n\n        while (lenA > lenB) {\n            headA = headA.next;\n            lenA--;\n        }\n\n        while (lenB > lenA) {\n            headB = headB.next;\n            lenB--;\n        }\n\n        while (headA != headB) {\n            headA = headA.next;\n            headB = headB.next;\n        }\n\n        return headA;\n    }\n\n    private int getLength(ListNode head) {\n        int length = 0;\n        while (head != null) {\n            length++;\n            head = head.next;\n        }\n        return length;\n    }\n}"
    }
  },
  "161": {
    "solution": {
      "two-pointers": "public class Solution {\n    public boolean isOneEditDistance(String s, String t) {\n        int m = s.length(), n = t.length();\n        if (Math.abs(m - n) > 1) return false;\n\n        if (m > n) return isOneEditDistance(t, s);\n\n        for (int i = 0; i < m; i++) {\n            if (s.charAt(i) != t.charAt(i)) {\n                if (m == n) {\n                    return s.substring(i + 1).equals(t.substring(i + 1));\n                } else {\n                    return s.substring(i).equals(t.substring(i + 1));\n                }\n            }\n        }\n\n        return m + 1 == n;\n    }\n}"
    }
  },
  "162": {
    "solution": {
      "binary-search": "public class Solution {\n    public int findPeakElement(int[] nums) {\n        int low = 0, high = nums.length - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (nums[mid] > nums[mid + 1]) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return low;\n    }\n}"
    }
  },
  "163": {
    "solution": {
      "array": "class Solution {\n public:\n  vector<vector<int>> findMissingRanges(vector<int>& nums, int lower,\n                                        int upper) {\n    if (nums.empty())\n      return {getRange(lower, upper)};\n\n    vector<vector<int>> ans;\n\n    if (nums.front() > lower)\n      ans.push_back(getRange(lower, nums.front() - 1));\n\n    for (int i = 1; i < nums.size(); ++i)\n      if (nums[i] > nums[i - 1] + 1)\n        ans.push_back(getRange(nums[i - 1] + 1, nums[i] - 1));\n\n    if (nums.back() < upper)\n      ans.push_back(getRange(nums.back() + 1, upper));\n\n    return ans;\n  }\n\n private:\n  vector<int> getRange(int lo, int hi) {\n    if (lo == hi)\n      return vector<int>{lo, lo};\n    return vector<int>{lo, hi};\n  }\n};"
    }
  },
  "164": {
    "solution": {
      "radix-sort": "class Solution {\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return 0;\n        }\n        \n        radixSort(nums);\n        \n        int maxGap = 0;\n        for (int i = 1; i < nums.length; i++) {\n            maxGap = Math.max(maxGap, nums[i] - nums[i - 1]);\n        }\n        return maxGap;\n    }\n\n    private void radixSort(int[] nums) {\n        int max = Arrays.stream(nums).max().getAsInt();\n        int exp = 1;\n        while (max / exp > 0) {\n            countingSort(nums, exp);\n            exp *= 10;\n        }\n    }\n\n    private void countingSort(int[] nums, int exp) {\n        int n = nums.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n\n        for (int i = 0; i < n; i++) {\n            int index = (nums[i] / exp) % 10;\n            count[index]++;\n        }\n\n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            int index = (nums[i] / exp) % 10;\n            output[count[index] - 1] = nums[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, nums, 0, n);\n    }\n}\n",
      "bucket-sort": "import java.util.*;\n\npublic class Solution {\n\n    public int maximumGap(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return 0;\n        }\n\n        int n = nums.length;\n        int minVal = Integer.MAX_VALUE;\n        int maxVal = Integer.MIN_VALUE;\n\n        for (int num : nums) {\n            minVal = Math.min(minVal, num);\n            maxVal = Math.max(maxVal, num);\n        }\n\n        int bucketSize = Math.max(1, (maxVal - minVal) / (n - 1));\n        int bucketCount = (maxVal - minVal) / bucketSize + 1;\n\n        List<Integer>[] buckets = new ArrayList[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n\n        for (int num : nums) {\n            int bucketIndex = (num - minVal) / bucketSize;\n            buckets[bucketIndex].add(num);\n        }\n\n        int maxGap = 0;\n        int previousMax = minVal;\n\n        for (int i = 0; i < bucketCount; i++) {\n            if (buckets[i].isEmpty()) {\n                continue;\n            }\n            Collections.sort(buckets[i]);\n            int currentMin = buckets[i].get(0);\n            int currentMax = buckets[i].get(buckets[i].size() - 1);\n            maxGap = Math.max(maxGap, currentMin - previousMax);\n            previousMax = currentMax;\n        }\n\n        return maxGap;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = { 3, 6, 9, 1 };\n        int[] nums2 = { 10 };\n\n        System.out.println(\"Maximum gap for nums1: \" + solution.maximumGap(nums1)); // Output: 3\n        System.out.println(\"Maximum gap for nums2: \" + solution.maximumGap(nums2)); // Output: 0\n    }\n}\n"
    }
  },
  "165": {
    "solution": {
      "two-pointers": "class Solution {\n    public int compareVersion(String version1, String version2) {\n        int length1 = version1.length(), length2 = version2.length();\n\n        for (int index1 = 0, index2 = 0; index1 < length1 || index2 < length2; ++index1, ++index2) {\n            int revision1 = 0, revision2 = 0;\n\n            // Extract numerical value of the current revision from version1\n            while (index1 < length1 && version1.charAt(index1) != '.') {\n                revision1 = revision1 * 10 + (version1.charAt(index1++) - '0');\n            }\n\n            // Extract numerical value of the current revision from version2\n            while (index2 < length2 && version2.charAt(index2) != '.') {\n                revision2 = revision2 * 10 + (version2.charAt(index2++) - '0');\n            }\n\n            // Compare the current revisions\n            if (revision1 != revision2) {\n                return revision1 < revision2 ? -1 : 1;\n            }\n        }\n        return 0;\n    }\n}"
    }
  },
  "166": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public String fractionToDecimal(int numerator, int denominator) {\n        if (numerator == 0) return \"0\";\n        \n        StringBuilder result = new StringBuilder();\n        \n        // Handle sign\n        if ((numerator < 0) ^ (denominator < 0)) {\n            result.append(\"-\");\n        }\n        \n        // Convert to long to handle overflow cases\n        long num = Math.abs((long) numerator);\n        long den = Math.abs((long) denominator);\n        \n        // Append integer part\n        result.append(num / den);\n        long remainder = num % den;\n        \n        if (remainder == 0) return result.toString();\n        \n        // Append decimal point\n        result.append(\".\");\n        \n        // Map to store remainder positions\n        Map<Long, Integer> remainderMap = new HashMap<>();\n        \n        while (remainder != 0) {\n            // If remainder is seen before, it means repeating fraction\n            if (remainderMap.containsKey(remainder)) {\n                result.insert(remainderMap.get(remainder), \"(\");\n                result.append(\")\");\n                break;\n            }\n            \n            // Store remainder with its index\n            remainderMap.put(remainder, result.length());\n            remainder *= 10;\n            result.append(remainder / den);\n            remainder %= den;\n        }\n        \n        return result.toString();\n    }\n}"
    }
  },
  "167": {
    "solution": {
      "two-pointers": "class Solution {\n    public int[] twoSum(int[] numbers, int target) {\n        int left = 0;\n        int right = numbers.length - 1;\n\n        while (left < right) {\n            int sum = numbers[left] + numbers[right];\n            if (sum == target) {\n                return new int[] { left + 1, right + 1 };\n            } else if (sum < target) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n        \n        return new int[] {};\n    }\n}"
    }
  },
  "168": {
    "solution": {
      "math": "public class Solution {\n    public String convertToTitle(int columnNumber) {\n        StringBuilder result = new StringBuilder();\n\n        while (columnNumber > 0) {\n            columnNumber--; // Adjust for 1-based indexing\n            int remainder = columnNumber % 26;\n            result.append((char) ('A' + remainder));\n            columnNumber /= 26;\n        }\n\n        return result.reverse().toString();\n    }\n}"
    }
  },
  "169": {
    "solution": {
      "divide-and-conquer": "",
      "counting": "class Solution {\n  public int majorityElement(int[] nums) {\n    Integer ans = null;\n    int count = 0;\n\n    for (final int num : nums) {\n      if (count == 0)\n        ans = num;\n      count += num == ans ? 1 : -1;\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "170": {
    "solution": {
      "two-pointers": "import java.util.*;\n\npublic class TwoSum {\n    private Map<Integer, Integer> map;\n\n    public TwoSum() {\n        map = new HashMap<>();\n    }\n\n    public void add(int number) {\n        map.put(number, map.getOrDefault(number, 0) + 1);\n    }\n\n    public boolean find(int value) {\n        for (int key : map.keySet()) {\n            int complement = value - key;\n            if (complement == key) {\n                if (map.get(key) > 1) return true;\n            } else if (map.containsKey(complement)) {\n                return true;\n            }\n        }\n        return false;\n    }\n}"
    }
  },
  "171": {
    "solution": {
      "string": "public class Solution {\n    public int titleToNumber(String columnTitle) {\n        int result = 0;\n        for (char c : columnTitle.toCharArray()) {\n            result = result * 26 + (c - 'A' + 1);\n        }\n        return result;\n    }\n}"
    }
  },
  "172": {
    "solution": {
      "math": "public class Solution {\n    public int trailingZeroes(int n) {\n        int count = 0;\n        while (n >= 5) {\n            n /= 5;\n            count += n;\n        }\n        return count;\n    }\n}"
    }
  },
  "173": {
    "solution": {
      "iterator": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.*;\n\nclass BSTIterator {\n    private Stack<TreeNode> stack;\n\n    public BSTIterator(TreeNode root) {\n        stack = new Stack<>();\n        pushAll(root);\n    }\n    \n    /** @return the next smallest number */\n    public int next() {\n        TreeNode node = stack.pop();\n        pushAll(node.right);\n        return node.val;\n    }\n    \n    public boolean hasNext() {\n        return !stack.isEmpty();\n    }\n    \n    private void pushAll(TreeNode node) {\n        while (node != null) {\n            stack.push(node);\n            node = node.left;\n        }\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
    }
  },
  "174": {
    "solution": {
      "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}};\n    \n    public int calculateMinimumHP(int[][] dungeon) {\n        int m = dungeon.length;\n        int n = dungeon[0].length;\n        Integer[][] memo = new Integer[m][n]; // Memoization table to store minimum health needed\n        return dfs(dungeon, 0, 0, m, n, memo);\n    }\n    \n    private int dfs(int[][] dungeon, int i, int j, int m, int n, Integer[][] memo) {\n        // Base case: if at the princess's cell, calculate minimum health to survive\n        if (i == m - 1 && j == n - 1) {\n            return Math.max(1, 1 - dungeon[i][j]);\n        }\n        \n        if (memo[i][j] != null) {\n            return memo[i][j];\n        }\n        \n        int minHealth = Integer.MAX_VALUE;\n        \n        // Explore right and down directions\n        for (int[] dir : DIRECTIONS) {\n            int ni = i + dir[0];\n            int nj = j + dir[1];\n            \n            if (ni < m && nj < n) {\n                minHealth = Math.min(minHealth, dfs(dungeon, ni, nj, m, n, memo));\n            }\n        }\n        \n        int healthRequired = Math.max(1, minHealth - dungeon[i][j]);        \n        memo[i][j] = healthRequired;\n        \n        return healthRequired;\n    }\n}\n"
    }
  },
  "175": {
    "solution": {
      "database": "SELECT FirstName, LastName, City, State FROM Person LEFT JOIN Address ON Person.PersonId = Address.PersonId;"
    }
  },
  "176": {
    "solution": {
      "database": "SELECT\n    (SELECT DISTINCT\n            Salary\n        FROM\n            Employee\n        ORDER BY Salary DESC\n        LIMIT 1 OFFSET 1) AS SecondHighestSalary\n;"
    }
  },
  "177": {
    "solution": {
      "database": "CREATE FUNCTION getNthHighestSalary(N INT) RETURNS INT\nBEGIN\n  SET N = N - 1;\n  RETURN (\n      select distinct e.Salary\n      from Employee e\n      order by e.Salary desc\n      limit N, 1\n  );\nEND"
    }
  },
  "178": {
    "solution": {
      "database": "# Write your MySQL query statement below\n\nSELECT s.score, (SELECT count(distinct(score)) from scores m where m.score >= s.score) as \"Rank\" FROM scores s order by s.score desc;\n\n# SELECT\n#     score,\n#     DENSE_RANK() OVER(ORDER BY score DESC) as \"Rank\"\n# FROM scores"
    }
  },
  "179": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public String largestNumber(int[] nums) {\n        String[] strNums = new String[nums.length];\n\n        // Convert numbers to strings\n        for (int i = 0; i < nums.length; i++) {\n            strNums[i] = String.valueOf(nums[i]);\n        }\n\n        // Sort using a custom comparator\n        Arrays.sort(strNums, (a, b) -> (b + a).compareTo(a + b));\n\n        // If the largest number is \"0\", return \"0\" (handles cases like [0, 0])\n        if (strNums[0].equals(\"0\")) {\n            return \"0\";\n        }\n\n        // Join sorted numbers to form the largest number\n        return String.join(\"\", strNums);\n    }\n}"
    }
  },
  "180": {
    "solution": {
      "database": "select distinct l1.Num as ConsecutiveNums\nfrom Logs l1, Logs l2, Logs l3\nwhere l2.Id = l1.Id+1 and l3.Id = l2.Id + 1 and l1.Num = l2.Num and l2.Num = l3.Num"
    }
  },
  "181": {
    "solution": {
      "database": "SELECT e1.Name AS Employee\nFROM Employee e1, Employee e2\nWHERE e1.ManagerId = e2.Id AND e1.Salary > e2.Salary;"
    }
  },
  "182": {
    "solution": {
      "database": "select distinct p1.Email\nfrom Person p1, Person p2\nwhere p1.Id <> p2.Id and p1.Email = p2.Email"
    }
  },
  "183": {
    "solution": {
      "database": "SELECT c2.Name AS Customers\nFROM Customers c2\nWHERE c2.Id \nNOT IN \n(SELECT o.CustomerId\nFROM Orders o);"
    }
  },
  "184": {
    "solution": {
      "database": "select d1.Name as Department, e1.Name as Employee, e1.Salary as Salary\nfrom Employee e1, Department d1, \n\n(select d.Id as Id, e.Name as Employee, max(e.Salary) as Salary\nfrom Employee e, Department d\nwhere e.DepartmentId = d.Id\ngroup by d.Id) as a\n\nwhere e1.DepartmentId = d1.Id and d1.Id = a.Id and a.Salary = e1.Salary"
    }
  },
  "185": {
    "solution": {
      "database": "select d1.Name as Department, e1.Name as Employee, e1.Salary as Salary\nfrom Employee e1, Department d1\nwhere e1.DepartmentId  = d1.Id and 3 > (select count(distinct(e2.salary)) from Employee e2 where e2.salary > e1.salary and e2.DepartmentId = e1.DepartmentId)"
    }
  },
  "186": {
    "solution": {
      "two-pointers": "class Solution {\n    public void reverseWords(char[] sentence) {\n        int length = sentence.length;\n        for (int start = 0, end = 0; end < length; ++end) {\n            if (sentence[end] == ' ') {\n                reverse(sentence, start, end - 1);\n                start = end + 1;\n            } else if (end == length - 1) {\n                reverse(sentence, start, end);\n            }\n        }\n        reverse(sentence, 0, length - 1);\n    }\n\n    private void reverse(char[] sentence, int left, int right) {\n        while (left < right) {\n            char temp = sentence[left];\n            sentence[left] = sentence[right];\n            sentence[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}"
    }
  },
  "187": {
    "solution": {
      "sliding-window": "import java.util.List;\nimport java.util.Map;\n\nclass Solution {\n    public List<String> findRepeatedDnaSequences(String s) {\n        List<String> result = new ArrayList<>();\n        if (s.length() <= 10) return result;\n\n        Map<String, Integer> sequenceCount = new HashMap<>();\n        for (int i = 0; i <= s.length() - 10; i++) {\n            String sequence = s.substring(i, i + 10);\n            sequenceCount.put(sequence, sequenceCount.getOrDefault(sequence, 0) + 1);\n            if (sequenceCount.get(sequence) == 2) {\n                result.add(sequence);\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "188": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public static int maxProfit(int k, int[] prices) {\n        if (prices == null || prices.length == 0 || k == 0) {\n            return 0;\n        }\n        \n        int n = prices.length;\n        \n        // If k is large enough, we can use the greedy solution\n        if (k >= n / 2) {\n            int maxProfit = 0;\n            for (int i = 1; i < n; i++) {\n                if (prices[i] > prices[i - 1]) {\n                    maxProfit += prices[i] - prices[i - 1];\n                }\n            }\n            return maxProfit;\n        }\n        \n        // dp[i][j] stores the maximum profit with at most i transactions\n        // using prices[0:j] (0-based index)\n        int[][] dp = new int[k + 1][n];\n        \n        for (int i = 1; i <= k; i++) {\n            int maxDiff = -prices[0];\n            for (int j = 1; j < n; j++) {\n                dp[i][j] = Math.max(dp[i][j - 1], prices[j] + maxDiff);\n                maxDiff = Math.max(maxDiff, dp[i - 1][j] - prices[j]);\n            }\n        }\n        \n        return dp[k][n - 1];\n    }\n}"
    }
  },
  "189": {
    "solution": {
      "two-pointers": "class Solution {\n    public void rotate(int[] nums, int k) {\n        k = k % nums.length;\n        reverse(nums, 0, nums.length - 1);\n        reverse(nums, 0, k - 1);\n        reverse(nums, k, nums.length - 1);\n    }\n\n    private void reverse(int[] nums, int start, int end) {\n        while (start < end) {\n            int temp = nums[start];\n            nums[start] = nums[end];\n            nums[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}"
    }
  },
  "190": {
    "solution": {
      "bit-manipulation": "public class Solution {\n  public int reverseBits(int n) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if (((n >> i) & 1) == 1)\n        ans |= (1 << (31 - i));\n\n    return ans;\n  }\n}\n"
    }
  },
  "191": {
    "solution": {
      "bit-manipulation": "public class Solution {\n  public int hammingWeight(int n) {\n    int ans = 0;\n\n    for (int i = 0; i < 32; ++i)\n      if (((n >> i) & 1) == 1)\n        ++ans;\n\n    return ans;\n  }\n}\n"
    }
  },
  "192": {
    "solution": {
      "shell": "#!/bin/bash\ntr -s ' ' '\\n' < words.txt | sort | uniq -c | awk '{print $2, $1}' | sort -nr -k2\n"
    }
  },
  "193": {
    "solution": {
      "shell": "#!/bin/bash\ngrep -E '^(([0-9]{3}) [0-9]{3}-[0-9]{4}$|^[0-9]{3}-[0-9]{3}-[0-9]{4}$)' file.txt"
    }
  },
  "194": {
    "solution": {
      "shell": "#!/bin/bash\nawk '\n{\n    for (i = 1; i <= NF; i++) {\n        if (NR == 1) {\n            res[i] = $i;\n        } else {\n            res[i] = res[i] \" \" $i;\n        }\n    }\n}\nEND {\n    for (i = 1; i <= NF; i++) {\n        print res[i];\n    }\n}' file.txt\n"
    }
  },
  "195": {
    "solution": {
      "shell": "#!/bin/bash\nsed '10q;d' file.txt"
    }
  },
  "196": {
    "solution": {
      "database": "DELETE p1 FROM Person p1, Person p2 WHERE p1.Email = p2.Email AND p1.Id > p2.Id;"
    }
  },
  "197": {
    "solution": {
      "database": "WITH yesterday AS (SELECT id,recordDate,temperature,DATE_SUB(recordDate, INTERVAL 1 DAY) AS yesterday\nFROM Weather)\n\nSELECT yesterday.id\nFROM yesterday LEFT JOIN Weather on yesterday.yesterday = Weather.recordDate\nWHERE Weather.temperature IS NOT NULL AND yesterday.temperature > Weather.temperature"
    }
  },
  "198": {
    "solution": {
      "dynamic-programming": "class Solution {\n    // dp[i] represents the maximum amount of money that can be robbed from the\n    // first i houses.\n    public int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        int[] dp = new int[nums.length + 1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        for (int i = 2; i <= nums.length; i++) {\n            dp[i] = Math.max(nums[i - 1] + dp[i - 2], dp[i - 1]);\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[nums.length];\n    }\n}"
    }
  },
  "199": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public List<Integer> rightSideView(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            TreeNode rightMost = null;\n\n            for (int i = 0; i < size; i++) {\n                TreeNode current = queue.poll();\n                rightMost = current;\n\n                if (current.left != null) queue.offer(current.left);\n                if (current.right != null) queue.offer(current.right);\n            }\n\n            if (rightMost != null) {\n                result.add(rightMost.val);\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "200": {
    "solution": {
      "union-find": "",
      "matrix": "class Solution {\n\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int numIslands(char[][] grid) {\n        if (grid == null || grid.length == 0) {\n            return 0;\n        }\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int numIslands = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == '1') {\n                    numIslands++;\n                    dfs(grid, i, j);\n                }\n            }\n        }\n\n        return numIslands;\n    }\n\n    private void dfs(char[][] grid, int i, int j) {\n        int m = grid.length;\n        int n = grid[0].length;\n\n        if (i < 0 || i >= m || j < 0 || j >= n || grid[i][j] != '1') {\n            return;\n        }\n        grid[i][j] = '0';\n        for (int[] direction : DIRECTIONS) {\n            int newRow = i + direction[0];\n            int newCol = j + direction[1];\n            dfs(grid, newRow, newCol);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        char[][] grid = {\n            {'1', '1', '1', '1', '0'},\n            {'1', '1', '0', '1', '0'},\n            {'1', '1', '0', '0', '0'},\n            {'0', '0', '0', '0', '0'}\n        };\n\n        int result = solution.numIslands(grid);\n        System.out.println(\"Number of Islands: \" + result); // Output: 1\n    }\n}\n"
    }
  },
  "201": {
    "solution": {
      "bit-manipulation": "public class Solution {\n    public int rangeBitwiseAnd(int left, int right) {\n        int shiftCount = 0;\n\n        while (left != right) {\n            left >>= 1;\n            right >>= 1;\n            shiftCount++;\n        }\n\n        return left << shiftCount;\n    }\n}"
    }
  },
  "202": {
    "solution": {
      "two-pointers": "import java.util.HashSet;\n\npublic class Solution {\n    public boolean isHappy(int n) {\n        HashSet<Integer> seen = new HashSet<>();\n\n        while (n != 1 && !seen.contains(n)) {\n            seen.add(n);\n            n = getNextNumber(n);\n        }\n\n        return n == 1;\n    }\n\n    private int getNextNumber(int n) {\n        int sum = 0;\n        while (n > 0) {\n            int digit = n % 10;\n            sum += digit * digit;\n            n /= 10;\n        }\n        return sum;\n    }\n}\n"
    }
  },
  "203": {
    "solution": {
      "linked-list": "class Solution {\n    public ListNode removeElements(ListNode head, int targetValue) {\n        // Create a dummy node to handle edge cases like removing the head node\n        ListNode dummyNode = new ListNode(0);\n        dummyNode.next = head;\n        \n        ListNode currentNode = dummyNode;\n        \n        // Traverse the linked list\n        while (currentNode.next != null) {\n            if (currentNode.next.val == targetValue) {\n                currentNode.next = currentNode.next.next; // Remove the node\n            } else {\n                currentNode = currentNode.next; // Move to the next node\n            }\n        }\n        \n        return dummyNode.next; // Return the updated head\n    }\n}"
    }
  },
  "204": {
    "solution": {
      "number-theory": "public class Solution {\n    public int countPrimes(int n) {\n        if (n <= 2) return 0;\n\n        boolean[] isPrime = new boolean[n];\n        Arrays.fill(isPrime, true);\n        isPrime[0] = isPrime[1] = false;\n\n        for (int i = 2; i * i < n; i++) {\n            if (isPrime[i]) {\n                for (int j = i * i; j < n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n\n        int count = 0;\n        for (int i = 2; i < n; i++) {\n            if (isPrime[i]) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}"
    }
  },
  "205": {
    "solution": {
      "hash-table": "import java.util.*;\n\npublic class Solution {\n    public boolean isIsomorphic(String s, String t) {\n        if (s.length() != t.length()) return false;\n\n        Map<Character, Character> sToT = new HashMap<>();\n        Map<Character, Character> tToS = new HashMap<>();\n\n        for (int i = 0; i < s.length(); i++) {\n            char cs = s.charAt(i);\n            char ct = t.charAt(i);\n\n            if (sToT.containsKey(cs) && sToT.get(cs) != ct) return false;\n            if (tToS.containsKey(ct) && tToS.get(ct) != cs) return false;\n\n            sToT.put(cs, ct);\n            tToS.put(ct, cs);\n        }\n\n        return true;\n    }\n}"
    }
  },
  "206": {
    "solution": {
      "linked-list": "class ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode reverseList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n\n        while (curr != null) {\n            ListNode nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n\n        return prev;\n    }\n}"
    }
  },
  "207": {
    "solution": {
      "topological-sort": "class Solution {\n    public boolean canFinish(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> adjList = new ArrayList<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        int[] indegree = new int[numCourses];\n\n        for (int[] prerequisite : prerequisites) {\n            int course = prerequisite[0];\n            int prerequisiteCourse = prerequisite[1];\n\n            adjList.get(prerequisiteCourse).add(course);\n            indegree[course]++;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (indegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        int visitedCount = 0;\n        \n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            visitedCount++;\n\n            for (int neighbor : adjList.get(course)) {\n                indegree[neighbor]--;\n                if (indegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        return visitedCount == numCourses;\n    }\n}"
    }
  },
  "208": {
    "solution": {
      "trie": "class TrieNode {\n    TrieNode[] children;\n    boolean isEndOfWord;\n\n    TrieNode() {\n        children = new TrieNode[26]; // For lowercase 'a' to 'z'\n        isEndOfWord = false;\n    }\n}\n\npublic class Trie {\n    private final TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word) {\n        TrieNode curr = root;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (curr.children[idx] == null) {\n                curr.children[idx] = new TrieNode();\n            }\n            curr = curr.children[idx];\n        }\n        curr.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        TrieNode node = searchPrefix(word);\n        return node != null && node.isEndOfWord;\n    }\n\n    public boolean startsWith(String prefix) {\n        return searchPrefix(prefix) != null;\n    }\n\n    private TrieNode searchPrefix(String prefix) {\n        TrieNode curr = root;\n        for (char c : prefix.toCharArray()) {\n            int idx = c - 'a';\n            if (curr.children[idx] == null) {\n                return null;\n            }\n            curr = curr.children[idx];\n        }\n        return curr;\n    }\n}"
    }
  },
  "209": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int minSubArrayLen(int target, int[] nums) {\n        int n = nums.length;\n        int minLength = Integer.MAX_VALUE;\n        int left = 0;\n        int sum = 0;\n        \n        for (int right = 0; right < n; right++) {\n            sum += nums[right];\n            \n            while (sum >= target) {\n                minLength = Math.min(minLength, right - left + 1);\n                sum -= nums[left];\n                left++;\n            }\n        }\n        \n        return (minLength == Integer.MAX_VALUE) ? 0 : minLength;\n    }\n}\n"
    }
  },
  "210": {
    "solution": {
      "topological-sort": "class Solution {\n    public int[] findOrder(int numCourses, int[][] prerequisites) {\n        List<List<Integer>> adjList = new ArrayList<>();\n        Queue<Integer> queue = new LinkedList<>();\n        List<Integer> result = new ArrayList<>();\n\n        for (int i = 0; i < numCourses; i++) {\n            adjList.add(new ArrayList<>());\n        }\n\n        int[] in_degree = new int[numCourses];\n        int visitedCount = 0;\n\n        for (int[] prerequisite : prerequisites) {\n            int course = prerequisite[0];\n            int preRequisiteCourse = prerequisite[1];\n            adjList.get(preRequisiteCourse).add(course);\n            in_degree[course]++;\n        }\n\n        for (int i = 0; i < numCourses; i++) {\n            if (in_degree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int course = queue.poll();\n            result.add(course);\n            visitedCount++;\n            for (int neighbor : adjList.get(course)) {\n                if (--in_degree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        if (visitedCount == numCourses) {\n            return result.stream().mapToInt(Integer::intValue).toArray();\n        }\n\n        return new int[0];\n    }\n}"
    }
  },
  "211": {
    "solution": {
      "trie": "class WordDictionary {\n\n    private static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        boolean isEndOfWord = false;\n    }\n\n    private final TrieNode root;\n\n    public WordDictionary() {\n        root = new TrieNode();\n    }\n\n    public void addWord(String word) {\n        TrieNode currentNode = root;\n        for (char character : word.toCharArray()) {\n            int charIndex = character - 'a';\n            if (currentNode.children[charIndex] == null) {\n                currentNode.children[charIndex] = new TrieNode();\n            }\n            currentNode = currentNode.children[charIndex];\n        }\n        currentNode.isEndOfWord = true;\n    }\n\n    public boolean search(String word) {\n        return searchFromNode(word, 0, root);\n    }\n\n    private boolean searchFromNode(String word, int wordIndex, TrieNode currentNode) {\n        if (currentNode == null) return false;\n\n        if (wordIndex == word.length()) {\n            return currentNode.isEndOfWord;\n        }\n\n        char currentChar = word.charAt(wordIndex);\n\n        if (currentChar == '.') {\n            // Try all possible children for wildcard\n            for (TrieNode childNode : currentNode.children) {\n                if (childNode != null && searchFromNode(word, wordIndex + 1, childNode)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            int charIndex = currentChar - 'a';\n            return searchFromNode(word, wordIndex + 1, currentNode.children[charIndex]);\n        }\n    }\n}\n\n/**\n * Your WordDictionary object will be instantiated and called as such:\n * WordDictionary obj = new WordDictionary();\n * obj.addWord(word);\n * boolean param_2 = obj.search(word);\n */"
    }
  },
  "212": {
    "solution": {
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\n    public List<String> findWords(char[][] board, String[] words) {\n        List<String> result = new ArrayList<>();\n        if (board == null || board.length == 0 || words == null || words.length == 0) {\n            return result;\n        }\n\n        TrieNode root = buildTrie(words);\n        int rows = board.length;\n        int cols = board[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                dfs(board, i, j, root, result);\n            }\n        }\n\n        return result;\n    }\n\n    private void dfs(char[][] board, int row, int col, TrieNode node, List<String> result) {\n        char c = board[row][col];\n        if (c == '#' || node.children[c - 'a'] == null) {\n            return;\n        }\n\n        node = node.children[c - 'a'];\n        if (node.word != null) { // Found a word\n            result.add(node.word);\n            node.word = null; // To avoid duplicate results\n        }\n\n        board[row][col] = '#';\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n            if (newRow >= 0 && newRow < board.length && newCol >= 0 && newCol < board[0].length) {\n                dfs(board, newRow, newCol, node, result);\n            }\n        }\n        board[row][col] = c;\n    }\n\n    private TrieNode buildTrie(String[] words) {\n        TrieNode root = new TrieNode();\n        for (String word : words) {\n            TrieNode node = root;\n            for (char c : word.toCharArray()) {\n                int index = c - 'a';\n                if (node.children[index] == null) {\n                    node.children[index] = new TrieNode();\n                }\n                node = node.children[index];\n            }\n            node.word = word;\n        }\n        return root;\n    }\n\n    static class TrieNode {\n        TrieNode[] children = new TrieNode[26];\n        String word;\n    }\n}\n"
    }
  },
  "213": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public static int rob(int[] nums) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n        if (nums.length == 1) {\n            return nums[0];\n        }\n        int n = nums.length;\n\n        // case-1: Rob the first house, not the last one.\n        int[] dp = new int[n + 1];\n        dp[0] = 0;\n        dp[1] = nums[0];\n        for (int i = 2; i < n; i++) {\n            dp[i] = Math.max(dp[i - 1], dp[i - 2] + nums[i - 1]);\n        }\n        dp[n] = dp[n - 1]; // not robbing last one\n\n        // case-2: Not rob the first, might or may not rob the last one\n        int[] dp2 = new int[n + 1];\n        dp2[0] = 0;\n        dp2[1] = 0;\n        for (int i = 2; i < n + 1; i++) {\n            dp2[i] = Math.max(dp2[i - 1], dp2[i - 2] + nums[i - 1]);\n        }\n        System.out.println(Arrays.toString(dp));\n        System.out.println(Arrays.toString(dp2));\n        return Math.max(dp[n], dp2[n]);\n    }\n}"
    }
  },
  "214": {
    "solution": {
      "rolling-hash": "",
      "hash-function": "class Solution {\n    public String shortestPalindrome(String s) {\n        String rev = new StringBuilder(s).reverse().toString();\n        String combined = s + \"#\" + rev;\n\n        int[] prefix = new int[combined.length()];\n\n        for (int i = 1; i < combined.length(); i++) {\n            int j = prefix[i - 1];\n            while (j > 0 && combined.charAt(i) != combined.charAt(j)) {\n                j = prefix[j - 1];\n            }\n            if (combined.charAt(i) == combined.charAt(j)) {\n                j++;\n            }\n            prefix[i] = j;\n        }\n\n        int longestPrefix = prefix[combined.length() - 1];\n        String suffixToAdd = rev.substring(0, s.length() - longestPrefix);\n        return suffixToAdd + s;\n    }\n}"
    }
  },
  "215": {
    "solution": {
      "quickselect": "public class Solution {\n    public int findKthLargest(int[] nums, int k) {\n        int left = 0, right = nums.length - 1;\n        Random rand = new Random();\n        while (true) {\n            int pivot_index = left + rand.nextInt(right - left + 1);\n            int new_pivot_index = partition(nums, left, right, pivot_index);\n            if (new_pivot_index == nums.length - k) {\n                return nums[new_pivot_index];\n            } else if (new_pivot_index > nums.length - k) {\n                right = new_pivot_index - 1;\n            } else {\n                left = new_pivot_index + 1;\n            }\n        }\n    }\n\n    private int partition(int[] nums, int left, int right, int pivot_index) {\n        int pivot = nums[pivot_index];\n        swap(nums, pivot_index, right);\n        int stored_index = left;\n        for (int i = left; i < right; i++) {\n            if (nums[i] < pivot) {\n                swap(nums, i, stored_index);\n                stored_index++;\n            }\n        }\n        swap(nums, right, stored_index);\n        return stored_index;\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}",
      "heap-(priority-queue)": "class Solution {\n  public int findKthLargest(int[] nums, int k) {\n    Queue<Integer> minHeap = new PriorityQueue<>();\n\n    for (final int num : nums) {\n      minHeap.offer(num);\n      while (minHeap.size() > k)\n        minHeap.poll();\n    }\n\n    return minHeap.peek();\n  }\n}"
    }
  },
  "216": {
    "solution": {
      "backtracking": "class Solution {\n    public List<List<Integer>> combinationSum3(int k, int n) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(1, k, n, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int start, int k, int target, List<Integer> combination, List<List<Integer>> result) {\n        if (combination.size() == k) {\n            if (target == 0) {\n                result.add(new ArrayList<>(combination));\n            }\n            return;\n        }\n\n        for (int i = start; i <= 9; i++) {\n            if (i > target) break;\n            combination.add(i);\n            backtrack(i + 1, k, target - i, combination, result);\n            combination.remove(combination.size() - 1);\n        }\n    }\n}"
    }
  },
  "217": {
    "solution": {
      "hash-table": "import java.util.HashSet;\n\nclass Solution {\n    public boolean containsDuplicate(int[] numbers) {\n        HashSet<Integer> uniqueNumbers = new HashSet<>();\n        \n        for (int number : numbers) {\n            if (!uniqueNumbers.add(number)) {\n                return true; // Duplicate found\n            }\n        }\n        \n        return false; // No duplicates found\n    }\n}"
    }
  },
  "218": {
    "solution": {
      "line-sweep": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> getSkyline(int[][] buildings) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<int[]> heights = new ArrayList<>();\n        \n        // Step 1: Collect Events\n        for (int[] building : buildings) {\n            heights.add(new int[]{building[0], -building[2]}); // start event\n            heights.add(new int[]{building[1], building[2]});  // end event\n        }\n        \n        // Step 2: Sort Events\n        Collections.sort(heights, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            }\n            return a[1] - b[1];\n        });\n        \n        // Step 3: Process Events\n        PriorityQueue<Integer> pq = new PriorityQueue<>((a, b) -> b - a);\n        pq.offer(0);\n        int prevHeight = 0;\n        \n        for (int[] h : heights) {\n            if (h[1] < 0) {\n                pq.offer(-h[1]); // start event\n            } else {\n                pq.remove(h[1]); // end event\n            }\n            int currHeight = pq.peek();\n            if (prevHeight != currHeight) {\n                result.add(Arrays.asList(h[0], currHeight));\n                prevHeight = currHeight;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "219": {
    "solution": {
      "sliding-window": "import java.util.HashSet;\n\npublic class Solution {\n    public boolean containsNearbyDuplicate(int[] nums, int k) {\n        if (nums == null || nums.length == 0 || k <= 0) {\n            return false;\n        }\n        \n        HashSet<Integer> set = new HashSet<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (set.contains(nums[i])) {\n                return true;\n            }\n            \n            set.add(nums[i]);\n            \n            if (set.size() > k) {\n                set.remove(nums[i - k]);\n            }\n        }\n        \n        return false;\n    }\n}\n"
    }
  },
  "220": {
    "solution": {
      "bucket-sort": "import java.util.*;\n\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k <= 0 || t < 0) return false;\n\n        Map<Long, Long> bucketMap = new HashMap<>();\n        long bucketSize = (long) t + 1;\n\n        for (int i = 0; i < nums.length; i++) {\n            long num = (long) nums[i];\n            long bucket = getBucket(num, bucketSize);\n\n            if (bucketMap.containsKey(bucket)) return true;\n\n            if (bucketMap.containsKey(bucket - 1) && Math.abs(num - bucketMap.get(bucket - 1)) < bucketSize)\n                return true;\n\n            if (bucketMap.containsKey(bucket + 1) && Math.abs(num - bucketMap.get(bucket + 1)) < bucketSize)\n                return true;\n\n            bucketMap.put(bucket, num);\n\n            if (i >= k) {\n                long oldBucket = getBucket((long) nums[i - k], bucketSize);\n                bucketMap.remove(oldBucket);\n            }\n        }\n\n        return false;\n    }\n\n    private long getBucket(long num, long bucketSize) {\n        return num < 0 ? (num + 1) / bucketSize - 1 : num / bucketSize;\n    }\n}",
      "sliding-window": "import java.util.TreeSet;\n\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (nums == null || nums.length == 0 || k <= 0 || t < 0) return false;\n\n        TreeSet<Long> set = new TreeSet<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            long num = (long) nums[i];\n\n            Long floor = set.floor(num + t);\n            if (floor != null && floor >= num - t) return true;\n\n            set.add(num);\n            if (set.size() > k) {\n                set.remove((long) nums[i - k]);\n            }\n        }\n\n        return false;\n    }\n}",
      "ordered-set": "import java.util.*;\n\nclass Solution {\n    public boolean containsNearbyAlmostDuplicate(int[] nums, int k, int t) {\n        if (k <= 0 || t < 0) return false;\n\n        TreeSet<Long> window = new TreeSet<>();\n        for (int i = 0; i < nums.length; i++) {\n            Long lower = window.ceiling((long) nums[i] - (long) t);\n            if (lower != null && lower <= (long) nums[i] + (long) t) {\n                return true;\n            }\n\n            window.add((long) nums[i]);\n\n            if (window.size() > k) {\n                window.remove((long) nums[i - k]);\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "221": {
    "solution": {
      "dynamic_programming": "import java.util.Arrays;\n\nclass Solution {\n    // dp[i][j]: Represents the side length of the largest square ending at the cell (i, j).\n    public int maximalSquare(char[][] matrix) {\n        final int rows = matrix.length;\n        final int cols = matrix[0].length;\n        int[][] dp = new int[rows][cols];\n        int maxLength = 0;\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (i == 0 || j == 0 || matrix[i][j] == '0') {\n                    dp[i][j] = matrix[i][j] == '1' ? 1 : 0;\n                } else {\n                    dp[i][j] = Math.min(dp[i - 1][j - 1],\n                            Math.min(dp[i - 1][j], dp[i][j - 1])) + 1;\n                }\n                maxLength = Math.max(maxLength, dp[i][j]);\n            }\n        }\n        return maxLength * maxLength;\n    }\n}"
    }
  },
  "222": {
    "solution": {
      "binary-tree": "/*\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n*/\n\nclass Solution {\n    public int countNodes(TreeNode root) {\n        if (root == null) return 0;\n\n        int height = getHeight(root);\n        if (height == -1) return 1;\n\n        return (1 << height) - 1 + countLastLevelNodes(root, height);\n    }\n\n    private int getHeight(TreeNode node) {\n        int height = 0;\n        while (node != null) {\n            node = node.left;\n            height++;\n        }\n        return height - 1;\n    }\n\n    private int countLastLevelNodes(TreeNode root, int height) {\n        int left = 0, right = (1 << height) - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (exists(root, height, mid)) {\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n\n    private boolean exists(TreeNode root, int height, int index) {\n        int left = 0, right = (1 << height) - 1;\n        for (int i = 0; i < height; i++) {\n            int mid = left + (right - left) / 2;\n            if (index <= mid) {\n                root = root.left;\n                right = mid;\n            } else {\n                root = root.right;\n                left = mid + 1;\n            }\n        }\n        return root != null;\n    }\n}"
    }
  },
  "223": {
    "solution": {
      "math": "class Solution {\n    public int computeArea(int ax1, int ay1, int ax2, int ay2,\n                           int bx1, int by1, int bx2, int by2) {\n        int area1 = (ax2 - ax1) * (ay2 - ay1);\n        int area2 = (bx2 - bx1) * (by2 - by1);\n\n        int overlapWidth = Math.max(0, Math.min(ax2, bx2) - Math.max(ax1, bx1));\n        int overlapHeight = Math.max(0, Math.min(ay2, by2) - Math.max(ay1, by1));\n        int overlapArea = overlapWidth * overlapHeight;\n\n        return area1 + area2 - overlapArea;\n    }\n}"
    }
  },
  "224": {
    "solution": {
      "stack": "import java.util.Stack;\n\npublic class Solution {\n    public int calculate(String s) {\n        Stack<Integer> stack = new Stack<>();\n        int result = 0;\n        int number = 0;\n        int sign = 1; \n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (Character.isDigit(c)) {\n                number = number * 10 + (c - '0');\n            } else if (c == '+') {\n                result += sign * number;\n                number = 0;\n                sign = 1;\n            } else if (c == '-') {\n                result += sign * number;\n                number = 0;\n                sign = -1;\n            } else if (c == '(') {\n                stack.push(result);\n                stack.push(sign);\n                result = 0;\n                sign = 1;\n            } else if (c == ')') {\n                result += sign * number;\n                number = 0;\n                result *= stack.pop();\n                result += stack.pop();\n            }\n        }\n\n        if (number != 0) {\n            result += sign * number;\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "225": {
    "solution": {
      "queue": "import java.util.LinkedList;\nimport java.util.Queue;\n\nclass MyStack {\n\n    private Queue<Integer> queue1;\n    private Queue<Integer> queue2;\n\n    public MyStack() {\n        queue1 = new LinkedList<>();\n        queue2 = new LinkedList<>();\n    }\n    \n    public void push(int x) {\n        queue2.offer(x);\n        while (!queue1.isEmpty()) {\n            queue2.offer(queue1.poll());\n        }\n        Queue<Integer> temp = queue1;\n        queue1 = queue2;\n        queue2 = temp;\n    }\n    \n    public int pop() {\n        if (queue1.isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");\n        }\n        return queue1.poll();\n    }\n    \n    public int top() {\n        if (queue1.isEmpty()) {\n            throw new RuntimeException(\"Stack is empty\");\n        }\n        return queue1.peek();\n    }\n    \n    public boolean empty() {\n        return queue1.isEmpty();\n    }\n}\n\n/**\n * Your MyStack object will be instantiated and called as such:\n * MyStack obj = new MyStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * boolean param_4 = obj.empty();\n */\n"
    }
  },
  "226": {
    "solution": {
      "breadth-first-search": "class Solution {\n    public TreeNode invertTree(TreeNode root) {\n        if (root == null) return null;\n\n        TreeNode temp = root.left;\n        root.left = root.right;\n        root.right = temp;\n\n        invertTree(root.left);\n        invertTree(root.right);\n\n        return root;\n    }\n}"
    }
  },
  "227": {
    "solution": {
      "stack": "import java.util.Stack;\n\nclass Solution {\n    public int calculate(String expression) {\n        Stack<Integer> valuesStack = new Stack<>();\n        int currentNumber = 0;\n        char previousOperator = '+';\n\n        for (int index = 0; index < expression.length(); index++) {\n            char currentChar = expression.charAt(index);\n\n            if (Character.isDigit(currentChar)) {\n                currentNumber = currentNumber * 10 + (currentChar - '0');\n            }\n\n            if ((!Character.isDigit(currentChar) && currentChar != ' ') || index == expression.length() - 1) {\n                if (previousOperator == '+') {\n                    valuesStack.push(currentNumber);\n                } else if (previousOperator == '-') {\n                    valuesStack.push(-currentNumber);\n                } else if (previousOperator == '*') {\n                    valuesStack.push(valuesStack.pop() * currentNumber);\n                } else if (previousOperator == '/') {\n                    valuesStack.push(valuesStack.pop() / currentNumber);\n                }\n                previousOperator = currentChar;\n                currentNumber = 0;\n            }\n        }\n\n        int result = 0;\n        while (!valuesStack.isEmpty()) {\n            result += valuesStack.pop();\n        }\n        return result;\n    }\n}"
    }
  },
  "228": {
    "solution": {
      "array": "class Solution {\n    public List<String> summaryRanges(int[] nums) {\n        List<String> result = new ArrayList<>();\n        if (nums.length == 0) return result;\n\n        int start = nums[0];\n\n        for (int i = 1; i <= nums.length; i++) {\n            if (i == nums.length || nums[i] != nums[i - 1] + 1) {\n                if (start == nums[i - 1]) {\n                    result.add(String.valueOf(start));\n                } else {\n                    result.add(start + \"->\" + nums[i - 1]);\n                }\n                if (i < nums.length) start = nums[i];\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "229": {
    "solution": {
      "counting": "class Solution {\n  public List<Integer> majorityElement(int[] nums) {\n    List<Integer> ans = new ArrayList<>();\n    int candidate1 = 0;\n    int candidate2 = 1;  \n    int countSoFar1 = 0;\n    int countSoFar2 = 0; \n\n    for (final int num : nums)\n      if (num == candidate1) {\n        ++countSoFar1;\n      } else if (num == candidate2) {\n        ++countSoFar2;\n      } else if (countSoFar1 == 0) { \n        candidate1 = num;\n        ++countSoFar1;\n      } else if (countSoFar2 == 0) {\n        candidate2 = num;\n        ++countSoFar2;\n      } else { \n        --countSoFar1;\n        --countSoFar2;\n      }\n\n    int count1 = 0;\n    int count2 = 0;\n\n    for (final int num : nums)\n      if (num == candidate1)\n        ++count1;\n      else if (num == candidate2)\n        ++count2;\n\n    if (count1 > nums.length / 3)\n      ans.add(candidate1);\n    if (count2 > nums.length / 3)\n      ans.add(candidate2);\n    return ans;\n  }\n}"
    }
  },
  "230": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int count = 0;\n    private int result = 0;\n\n    public int kthSmallest(TreeNode root, int k) {\n        inorder(root, k);\n        return result;\n    }\n\n    private void inorder(TreeNode root, int k) {\n        if (root == null) {\n            return;\n        }\n\n        inorder(root.left, k);\n\n        count++;\n        if (count == k) {\n            result = root.val;\n            return;\n        }\n\n        inorder(root.right, k);\n    }\n}"
    }
  },
  "231": {
    "solution": {
      "math": "class Solution {\n    public boolean isPowerOfTwo(int n) {\n        return n > 0 && (n & (n - 1)) == 0;\n    }\n}"
    }
  },
  "232": {
    "solution": {
      "queue": "import java.util.Stack;\n\nclass MyQueue {\n\n    private Stack<Integer> stack1;\n    private Stack<Integer> stack2;\n\n    public MyQueue() {\n        stack1 = new Stack<>();\n        stack2 = new Stack<>();\n    }\n    \n    public void push(int x) {\n        stack1.push(x);\n    }\n    \n    public int pop() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.pop();\n    }\n    \n    public int peek() {\n        if (stack2.isEmpty()) {\n            while (!stack1.isEmpty()) {\n                stack2.push(stack1.pop());\n            }\n        }\n        return stack2.peek();\n    }\n    \n    public boolean empty() {\n        return stack1.isEmpty() && stack2.isEmpty();\n    }\n}\n\n/**\n * Your MyQueue object will be instantiated and called as such:\n * MyQueue obj = new MyQueue();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.peek();\n * boolean param_4 = obj.empty();\n */\n"
    }
  },
  "233": {
    "solution": {
      "math": "class Solution {\n    public int countDigitOne(int n) {\n        if (n <= 0)\n            return 0;\n\n        int count = 0;\n        for (long i = 1; i <= n; i *= 10) {\n            long divider = i * 10;\n            count += (n / divider) * i + Math.min(Math.max(n % divider - i + 1, 0), i);\n            // (n / divider) * i counts the full repetitions of the pattern.\n            // Math.min(Math.max(n % divider - i + 1, 0), i) accounts for any remaining\n            // partial repetition and calculates the count of 1s in that portion.\n        }\n\n        return count;\n    }\n\n}"
    }
  },
  "234": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n\n    public boolean isPalindrome(ListNode head) {\n        if (head == null || head.next == null)\n            return true;\n\n        ListNode slow = head, fast = head;\n        while (fast.next != null && fast.next.next != null) {\n            slow = slow.next;\n            fast = fast.next.next;\n        }\n\n        ListNode secondHalf = reverseLinkedList(slow.next);\n        \n        ListNode p1 = head;\n        ListNode p2 = secondHalf;\n        while (p2 != null) {\n            if (p1.val != p2.val)\n                return false;\n            p1 = p1.next;\n            p2 = p2.next;\n        }\n        \n        reverseLinkedList(secondHalf);\n\n        return true;\n    }\n\n    private ListNode reverseLinkedList(ListNode head) {\n        ListNode prev = null;\n        ListNode curr = head;\n        while (curr != null) {\n            ListNode nextNode = curr.next;\n            curr.next = prev;\n            prev = curr;\n            curr = nextNode;\n        }\n        return prev;\n    }\n\n}"
    }
  },
  "235": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\n\npublic class Solution {\n\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null) {\n            return null;\n        }\n\n        if (p.val < root.val && q.val < root.val) {\n            return lowestCommonAncestor(root.left, p, q);\n        } else if (p.val > root.val && q.val > root.val) {\n            return lowestCommonAncestor(root.right, p, q);\n        } else {\n            return root;\n        }\n    }\n\n}\n"
    }
  },
  "236": {
    "solution": {
      "depth-first-search": "class Solution {\n    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) {\n        if (root == null || root == p || root == q) return root;\n\n        TreeNode left = lowestCommonAncestor(root.left, p, q);\n        TreeNode right = lowestCommonAncestor(root.right, p, q);\n\n        if (left != null && right != null) return root;\n\n        return left != null ? left : right;\n    }\n}"
    }
  },
  "237": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public void deleteNode(ListNode node) {\n        if (node == null || node.next == null) {\n            return; // Edge case: If it's the last node, deletion is not possible\n        }\n        \n        node.val = node.next.val; // Copy the value of the next node\n        node.next = node.next.next; // Delete the next node by skipping it\n    }\n}"
    }
  },
  "238": {
    "solution": {
      "prefix-sum": "public class Solution {\n    public int[] productExceptSelf(int[] nums) {\n        int n = nums.length;\n        \n        int[] answer = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            answer[i] = 1;\n        }\n        \n        int prefix = 1;\n        for (int i = 0; i < n; i++) {\n            answer[i] = prefix;\n            prefix *= nums[i];\n        }\n        \n        int postfix = 1;\n        for (int i = n - 1; i >= 0; i--) {\n            answer[i] *= postfix;\n            postfix *= nums[i];\n        }\n        \n        return answer;\n    }\n}\n"
    }
  },
  "239": {
    "solution": {
      "monotonic-queue": "import java.util.*;\n\nclass Solution {\n    public int[] maxSlidingWindow(int[] nums, int k) {\n        int n = nums.length;\n        if (n * k == 0) return new int[0]; \n        if (k == 1) return nums; \n        Deque<Integer> deque = new LinkedList<>();\n        int[] result = new int[n - k + 1]; \n        for (int i = 0; i < n; i++) {\n            while (!deque.isEmpty() && deque.peek() < i - k + 1) {\n                deque.poll();\n            }\n            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {\n                deque.pollLast();\n            }\n            deque.offer(i); \n            if (i - k + 1 >= 0) {\n                result[i - k + 1] = nums[deque.peek()];\n            }\n        }\n        return result;\n    }\n}\n"
    }
  },
  "240": {
    "solution": {
      "matrix": "class Solution {\n    public boolean searchMatrix(int[][] matrix, int target) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return false;\n        }\n        \n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        \n        int row = 0;\n        int col = cols - 1;\n        \n        while (row < rows && col >= 0) {\n            if (matrix[row][col] == target) {\n                return true;\n            } else if (matrix[row][col] > target) {\n                col--;  // Moving left (reduce column)\n            } else {\n                row++;  // Moving down (increase row)\n            }\n        }\n        \n        return false;\n    }\n}\n"
    }
  },
  "241": {
    "solution": {
      "memoization": "class Solution {\n    public List<Integer> diffWaysToCompute(String expression) {\n        Map<String, List<Integer>> memo = new HashMap<>();\n        return helper(expression, memo);\n    }\n\n    private List<Integer> helper(String expr, Map<String, List<Integer>> memo) {\n        if (memo.containsKey(expr)) return memo.get(expr);\n\n        List<Integer> results = new ArrayList<>();\n        boolean isNumber = true;\n\n        for (int i = 0; i < expr.length(); i++) {\n            char c = expr.charAt(i);\n            if (c == '+' || c == '-' || c == '*') {\n                isNumber = false;\n\n                List<Integer> left = helper(expr.substring(0, i), memo);\n                List<Integer> right = helper(expr.substring(i + 1), memo);\n\n                for (int l : left) {\n                    for (int r : right) {\n                        if (c == '+') results.add(l + r);\n                        else if (c == '-') results.add(l - r);\n                        else results.add(l * r);\n                    }\n                }\n            }\n        }\n\n        if (isNumber) {\n            results.add(Integer.parseInt(expr));\n        }\n\n        memo.put(expr, results);\n        return results;\n    }\n}"
    }
  },
  "242": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public boolean isAnagram(String s, String t) {\n        if (s.length() != t.length()) {\n            return false; // Anagrams must have the same length\n        }\n        \n        int[] charCount = new int[26]; // Array to store character counts\n\n        for (char ch : s.toCharArray()) {\n            charCount[ch - 'a']++; // Increment count for character in s\n        }\n\n        for (char ch : t.toCharArray()) {\n            charCount[ch - 'a']--; // Decrement count for character in t\n        }\n\n        for (int count : charCount) {\n            if (count != 0) {\n                return false; // If any count is nonzero, not an anagram\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "243": {
    "solution": {
      "string": "class Solution {\n    public int shortestDistance(String[] wordsDict, String word1, String word2) {\n        int i = -1, j = -1, min = Integer.MAX_VALUE;\n\n        for (int k = 0; k < wordsDict.length; k++) {\n            if (wordsDict[k].equals(word1)) i = k;\n            if (wordsDict[k].equals(word2)) j = k;\n            if (i != -1 && j != -1) {\n                min = Math.min(min, Math.abs(i - j));\n            }\n        }\n\n        return min;\n    }\n}"
    }
  },
  "244": {
    "solution": {
      "string": "class WordDistance {\n    private Map<String, List<Integer>> wordIndices = new HashMap<>();\n\n    public WordDistance(String[] wordsDict) {\n        for (int i = 0; i < wordsDict.length; i++) {\n            wordIndices.computeIfAbsent(wordsDict[i], k -> new ArrayList<>()).add(i);\n        }\n    }\n\n    public int shortest(String word1, String word2) {\n        List<Integer> list1 = wordIndices.get(word1);\n        List<Integer> list2 = wordIndices.get(word2);\n\n        int i = 0, j = 0, min = Integer.MAX_VALUE;\n        while (i < list1.size() && j < list2.size()) {\n            min = Math.min(min, Math.abs(list1.get(i) - list2.get(j)));\n            if (list1.get(i) < list2.get(j)) i++;\n            else j++;\n        }\n        return min;\n    }\n}"
    }
  },
  "245": {
    "solution": {
      "string": "class Solution {\n    public int shortestWordDistance(String[] wordsDict, String word1, String word2) {\n        int min = wordsDict.length;\n        int i = -1, j = -1;\n\n        if (word1.equals(word2)) {\n            for (int k = 0; k < wordsDict.length; k++) {\n                if (wordsDict[k].equals(word1)) {\n                    if (i != -1) min = Math.min(min, k - i);\n                    i = k;\n                }\n            }\n        } else {\n            for (int k = 0; k < wordsDict.length; k++) {\n                if (wordsDict[k].equals(word1)) i = k;\n                else if (wordsDict[k].equals(word2)) j = k;\n\n                if (i != -1 && j != -1) {\n                    min = Math.min(min, Math.abs(i - j));\n                }\n            }\n        }\n\n        return min;\n    }\n}"
    }
  },
  "246": {
    "solution": {
      "string": "class Solution {\n    private boolean isValid(char a, char b) {\n        return a == b && (a == '0' || a == '1' || a == '8');\n    }\n\n    private boolean match(char a, char b) {\n        if (a > b) {\n            char temp = a;\n            a = b;\n            b = temp;\n        }\n        return isValid(a, b) || (a == '6' && b == '9');\n    }\n\n    public boolean isStrobogrammatic(String num) {\n        int i = 0, j = num.length() - 1;\n        while (i <= j) {\n            if ((i != j && !match(num.charAt(i), num.charAt(j))) ||\n                (i == j && !isValid(num.charAt(i), num.charAt(j)))) {\n                return false;\n            }\n            i++;\n            j--;\n        }\n        return true;\n    }\n}"
    }
  },
  "247": {
    "solution": {
      "recursion": "class Solution {\n    private final char[][] pairs = {\n        {'0', '0'}, {'1', '1'}, {'8', '8'}, {'6', '9'}, {'9', '6'}\n    };\n\n    public List<String> findStrobogrammatic(int n) {\n        List<String> result = new ArrayList<>();\n        char[] s = new char[n];\n        dfs(result, s, 0, n);\n        return result;\n    }\n\n    private void dfs(List<String> result, char[] s, int i, int n) {\n        if (i == (n + 1) / 2) {\n            result.add(new String(s));\n            return;\n        }\n        for (char[] p : pairs) {\n            if (i == n - 1 - i && p[0] != p[1]) continue;\n            if (i == 0 && n > 1 && p[0] == '0') continue;\n            s[i] = p[0];\n            s[n - 1 - i] = p[1];\n            dfs(result, s, i + 1, n);\n        }\n    }\n}"
    }
  },
  "248": {
    "solution": {
      "string": "class Solution {\n    private final char[][] pairs = {\n        {'0', '0'}, {'1', '1'}, {'8', '8'}, {'6', '9'}, {'9', '6'}\n    };\n\n    public int strobogrammaticInRange(String low, String high) {\n        long l = Long.parseLong(low), r = Long.parseLong(high);\n        int count = 0;\n\n        for (int len = low.length(); len <= high.length(); len++) {\n            List<String> candidates = generate(len, len);\n            for (String s : candidates) {\n                if ((s.length() > 1 && s.charAt(0) == '0') || Long.parseLong(s) < l || Long.parseLong(s) > r) {\n                    continue;\n                }\n                count++;\n            }\n        }\n        return count;\n    }\n\n    private List<String> generate(int n, int totalLen) {\n        if (n == 0) return Arrays.asList(\"\");\n        if (n == 1) return Arrays.asList(\"0\", \"1\", \"8\");\n\n        List<String> subList = generate(n - 2, totalLen);\n        List<String> result = new ArrayList<>();\n\n        for (String s : subList) {\n            for (char[] p : pairs) {\n                if (n != totalLen || p[0] != '0') {\n                    result.add(p[0] + s + p[1]);\n                }\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "249": {
    "solution": {
      "hash-table": "class Solution {\n    public List<List<String>> groupStrings(String[] strings) {\n        Map<String, List<String>> map = new HashMap<>();\n        for (String str : strings) {\n            StringBuilder key = new StringBuilder();\n            int shift = str.charAt(0) - 'a';\n            for (char c : str.toCharArray()) {\n                char shifted = (char) (c - shift);\n                if (shifted < 'a') shifted += 26;\n                key.append(shifted);\n            }\n            map.computeIfAbsent(key.toString(), x -> new ArrayList<>()).add(str);\n        }\n        return new ArrayList<>(map.values());\n    }\n}"
    }
  },
  "250": {
    "solution": {
      "tree": "class Solution {\n    private int ans;\n\n    public int countUnivalSubtrees(TreeNode root) {\n        dfs(root);\n        return ans;\n    }\n\n    private boolean dfs(TreeNode root) {\n        if (root == null) {\n            return true;\n        }\n        boolean l = dfs(root.left);\n        boolean r = dfs(root.right);\n        if (!l || !r) {\n            return false;\n        }\n        int a = root.left == null ? root.val : root.left.val;\n        int b = root.right == null ? root.val : root.right.val;\n        if (a == b && b == root.val) {\n            ++ans;\n            return true;\n        }\n        return false;\n    }\n}"
    }
  },
  "251": {
    "solution": {
      "iterator": "class Vector2D {\n    private int i;\n    private int j;\n    private int[][] vec;\n\n    public Vector2D(int[][] vec) {\n        this.vec = vec;\n    }\n\n    public int next() {\n        forward();\n        return vec[i][j++];\n    }\n\n    public boolean hasNext() {\n        forward();\n        return i < vec.length;\n    }\n\n    private void forward() {\n        while (i < vec.length && j >= vec[i].length) {\n            ++i;\n            j = 0;\n        }\n    }\n}\n\n/**\n * Your Vector2D object will be instantiated and called as such:\n * Vector2D obj = new Vector2D(vec);\n * int param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
    }
  },
  "252": {
    "solution": {
      "sorting": "class Solution {\n    public boolean canAttendMeetings(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[0], b[0]));\n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] < intervals[i - 1][1]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "253": {
    "solution": {
      "two-pointers": "class Solution {\n    public int minMeetingRooms(int[][] intervals) {\n        int n = 1000010;\n        int[] delta = new int[n];\n        for (int[] e : intervals) {\n            ++delta[e[0]];\n            --delta[e[1]];\n        }\n        int res = delta[0];\n        for (int i = 1; i < n; ++i) {\n            delta[i] += delta[i - 1];\n            res = Math.max(res, delta[i]);\n        }\n        return res;\n    }\n}"
    }
  },
  "254": {
    "solution": {
      "backtracking": "class Solution {\n    public List<List<Integer>> getFactors(int n) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(n, 2, new ArrayList<>(), result);\n        return result;\n    }\n\n    private void backtrack(int n, int start, List<Integer> current, List<List<Integer>> result) {\n        if (!current.isEmpty()) {\n            List<Integer> temp = new ArrayList<>(current);\n            temp.add(n);\n            result.add(temp);\n        }\n\n        for (int i = start; i <= Math.sqrt(n); i++) {\n            if (n % i == 0) {\n                current.add(i);\n                backtrack(n / i, i, current, result);\n                current.remove(current.size() - 1);\n            }\n        }\n    }\n}"
    }
  },
  "255": {
    "solution": {
      "binary-search-tree": "class Solution {\n    public boolean verifyPreorder(int[] preorder) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        int last = Integer.MIN_VALUE;\n        for (int x : preorder) {\n            if (x < last) {\n                return false;\n            }\n            while (!stack.isEmpty() && stack.peek() < x) {\n                last = stack.poll();\n            }\n            stack.push(x);\n        }\n        return true;\n    }\n}"
    }
  },
  "256": {
    "solution": {
      "dynamic-programming": "// dp[i][j] represents the minimum cost to paint house i with color j, considering all houses from 0 to i. \npublic int minCost(int[][] costs) {\n    int len = costs.length;\n    if (costs != null && len == 0)\n        return 0;\n\n    int[][] dp = costs;\n    // dp[i][j], for house-i, three colors j (0 or 1 or 2)\n\n    // no need dp[m+1][n+1], just i=1 is good enough\n    for (int i = 1; i < len; i++) {\n        dp[i][0] = costs[i][0] + Math.min(costs[i - 1][1], costs[i - 1][2]);\n        dp[i][1] = costs[i][1] + Math.min(costs[i - 1][0], costs[i - 1][2]);\n        dp[i][2] = costs[i][2] + Math.min(costs[i - 1][0], costs[i - 1][1]);\n    }\n    return Math.min(dp[len - 1][0], Math.min(dp[len - 1][1], dp[len - 1][2]));\n}"
    }
  },
  "257": {
    "solution": {
      "tree": "",
      "backtracking": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<String> binaryTreePaths(TreeNode root) {\n        List<String> result = new ArrayList<>();\n        dfs(root, result, \"\");\n        return result;\n    }\n\n    private void dfs(TreeNode root, List<String> res, String path) {\n        if (root == null) return;\n        if (root.left == null && root.right == null) {\n            res.add(path + root.val);\n            return;\n        }\n        if (root.left != null) {\n            dfs(root.left, res, path + root.val + \"->\");\n        }\n        if (root.right != null) {\n            dfs(root.right, res, path + root.val + \"->\");\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        TreeNode t = new TreeNode(1);\n        t.left = new TreeNode(2);\n        t.left.right = new TreeNode(5);\n        t.right = new TreeNode(3);\n\n        List<String> paths = solution.binaryTreePaths(t);\n        for (String path : paths) {\n            System.out.println(path);\n        }\n    }\n}\n"
    }
  },
  "258": {
    "solution": {
      "number-theory": "class Solution {\n    public int addDigits(int num) {\n        if (num == 0) return 0;\n        return 1 + (num - 1) % 9;\n    }\n}"
    }
  },
  "259": {
    "solution": {
      "binary-search": "import java.util.Arrays;\n\nclass Solution {\n    public int threeSumSmaller(int[] nums, int target) {\n        Arrays.sort(nums);\n        int count = 0;\n\n        for (int i = 0; i < nums.length - 2; i++) {\n            int left = i + 1, right = nums.length - 1;\n\n            while (left < right) {\n                int sum = nums[i] + nums[left] + nums[right];\n\n                if (sum < target) {\n                    count += right - left;\n                    left++;\n                } else {\n                    right--;\n                }\n            }\n        }\n\n        return count;\n    }\n}"
    }
  },
  "260": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int[] singleNumber(int[] nums) {\n        int xor = 0;\n        for (int num : nums) {\n            xor ^= num;\n        }\n\n        int diffBit = xor & -xor;\n        int x = 0;\n        for (int num : nums) {\n            if ((num & diffBit) != 0) {\n                x ^= num;\n            }\n        }\n\n        return new int[] {x, xor ^ x};\n    }\n}"
    }
  },
  "261": {
    "solution": {
      "union-find": "import java.util.*;\n\nclass UnionFind {\n    int[] parent;\n    int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            parent[i] = i;\n            rank[i] = 0;\n        }\n    }\n\n    public int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);  // Path compression\n        }\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n\n        if (rootX != rootY) {\n            // Union by rank\n            if (rank[rootX] > rank[rootY]) {\n                parent[rootY] = rootX;\n            } else if (rank[rootX] < rank[rootY]) {\n                parent[rootX] = rootY;\n            } else {\n                parent[rootX] = rootY;\n                rank[rootY]++;\n            }\n        }\n    }\n}\n\npublic class Solution {\n    public int countComponents(int n, int[][] edges) {\n        UnionFind uf = new UnionFind(n);\n\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            uf.union(u, v);\n        }\n\n        // Count the number of unique root nodes (i.e., the number of connected components)\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (uf.find(i) == i) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        int n = 5;\n        int[][] edges = {{0, 1}, {1, 2}, {3, 4}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 2\n\n        // Test Case 2\n        n = 4;\n        edges = {{0, 1}, {2, 3}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 2\n\n        // Test Case 3\n        n = 6;\n        edges = {{0, 1}, {0, 2}, {3, 4}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 3\n    }\n}"
    }
  },
  "262": {
    "solution": {
      "database": "SELECT \nt1.Day\n,ROUND(SUM(t1.not_completed)/COUNT(*),2) AS \"Cancellation Rate\"\nFROM\n(SELECT \n    t.request_at AS Day\n    ,(CASE\n        WHEN status<>'completed' THEN 1\n        ELSE 0 END) AS not_completed\n    \n \nFROM\n Trips t\nWHERE client_id IN (SELECT users_id FROM Users WHERE banned='No' AND role='client')\n      AND driver_id IN (SELECT users_id FROM Users WHERE banned='No' AND role='driver')\n        ) t1\nWHERE (t1.Day BETWEEN '2013-10-01' AND '2013-10-03')\n\nGROUP BY t1.Day"
    }
  },
  "263": {
    "solution": {
      "math": "class Solution {\n    public boolean isUgly(int n) {\n        if (n <= 0) return false;\n        while (n % 2 == 0) n /= 2;\n        while (n % 3 == 0) n /= 3;\n        while (n % 5 == 0) n /= 5;\n        return n == 1;\n    }\n}"
    }
  },
  "264": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int nthUglyNumber(int n) {\n        int[] dp = new int[n];\n        dp[0] = 1;\n        int p2 = 0, p3 = 0, p5 = 0;\n        for (int i = 1; i < n; i++) {\n            dp[i] = Math.min(Math.min(dp[p2] * 2, dp[p3] * 3), dp[p5] * 5);\n            p2 = (dp[i] == dp[p2] * 2) ? p2 + 1 : p2;\n            p3 = (dp[i] == dp[p3] * 3) ? p3 + 1 : p3;\n            p5 = (dp[i] == dp[p5] * 5) ? p5 + 1 : p5;\n        }\n        System.out.println(Arrays.toString(dp));\n        return dp[n - 1];\n    }\n}"
    }
  },
  "265": {
    "solution": {
      "dynamic-programming": "//dp[i][j]: Represents the minimum cost of painting house i with color j, considering previous houses. \npublic static int minCost(int[][] costs) {\n        if (costs != null && costs.length == 0) {\n            return 0;\n        }\n        int[][] dp = costs;\n        int min1 = -1, min2 = -1;\n        for (int i = 0; i < dp.length; i++) {\n            int last1 = min1;\n            int last2 = min2;\n            min1 = -1;\n            min2 = -1;\n            for (int j = 0; j < dp[i].length; j++) {\n                if (j != last1) {\n                    dp[i][j] += last1 < 0 ? 0 : dp[i - 1][last1];\n                } else {\n                    dp[i][j] += last2 < 0 ? 0 : dp[i - 1][last2];\n                }\n\n                if (min1 < 0 || dp[i][j] < dp[i][min1]) {\n                    min2 = min1;\n                    min1 = j;\n                } else if (min2 < 0 || dp[i][j] < dp[i][min2]) {\n                    min2 = j;\n                }\n            }\n        }\n        System.out.println(Arrays.deepToString(dp).replace(\"]],\", \"]],\\n\"));\n        return dp[dp.length - 1][min1];\n    }\n"
    }
  },
  "266": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public boolean canPermutePalindrome(String s) {\n        int[] cnt = new int[26];\n        for (char c : s.toCharArray()) {\n            ++cnt[c - 'a'];\n        }\n        int odd = 0;\n        for (int x : cnt) {\n            odd += x & 1;\n        }\n        return odd < 2;\n    }\n}"
    }
  },
  "267": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    private List<String> res = new ArrayList<>();\n    private Map<Character, Integer> countMap = new HashMap<>();\n    private int n;\n\n    public List<String> generatePalindromes(String s) {\n        n = s.length();\n        for (char c : s.toCharArray()) {\n            countMap.put(c, countMap.getOrDefault(c, 0) + 1);\n        }\n\n        String mid = \"\";\n        for (Map.Entry<Character, Integer> entry : countMap.entrySet()) {\n            if (entry.getValue() % 2 == 1) {\n                if (!mid.isEmpty()) return res;\n                mid = String.valueOf(entry.getKey());\n            }\n        }\n\n        dfs(mid);\n        return res;\n    }\n\n    private void dfs(String cur) {\n        if (cur.length() == n) {\n            res.add(cur);\n            return;\n        }\n\n        for (char ch : countMap.keySet()) {\n            int cnt = countMap.get(ch);\n            if (cnt >= 2) {\n                countMap.put(ch, cnt - 2);\n                dfs(ch + cur + ch);\n                countMap.put(ch, cnt);\n            }\n        }\n    }\n}"
    }
  },
  "268": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int missingNumber(int[] nums) {\n        int n = nums.length;\n        int expected = n * (n + 1) / 2;\n        int actual = 0;\n        for (int num : nums) actual += num;\n        return expected - actual;\n    }\n}"
    }
  },
  "269": {
    "solution": {
      "topological-sort": "class Solution {\n public:\n  string alienOrder(vector<string>& words) {\n    unordered_map<char, unordered_set<char>> graph;\n    vector<int> inDegrees(26);\n    buildGraph(graph, words, inDegrees);\n    return topology(graph, inDegrees);\n  }\n\n private:\n  void buildGraph(unordered_map<char, unordered_set<char>>& graph,\n                  const vector<string>& words, vector<int>& inDegrees) {\n    for (const string& word : words)\n      for (const char c : word)\n        if (!graph.contains(c))\n          graph[c] = unordered_set<char>();\n\n    for (int i = 1; i < words.size(); ++i) {\n      const string& first = words[i - 1];\n      const string& second = words[i];\n      const int length = min(first.length(), second.length());\n      for (int j = 0; j < length; ++j) {\n        const char u = first[j];\n        const char v = second[j];\n        if (u != v) {\n          if (!graph[u].contains(v)) {\n            graph[u].insert(v);\n            ++inDegrees[v - 'a'];\n          }\n          break;\n        }\n        if (j == length - 1 && first.length() > second.length()) {\n          graph.clear();\n          return;\n        }\n      }\n    }\n  }\n\n  string topology(unordered_map<char, unordered_set<char>>& graph,\n                  vector<int>& inDegrees) {\n    string s;\n    queue<char> q;\n\n    for (const auto& [c, _] : graph)\n      if (inDegrees[c - 'a'] == 0)\n        q.push(c);\n\n    while (!q.empty()) {\n      const char u = q.front();\n      q.pop();\n      s += u;\n      for (const char v : graph[u])\n        if (--inDegrees[v - 'a'] == 0)\n          q.push(v);\n    }\n\n    return s.length() == graph.size() ? s : \"\";\n  }\n};"
    }
  },
  "270": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public int closestValue(TreeNode root, double target) {\n        int ans = root.val;\n        double max = Double.MAX_VALUE;\n        while (root != null) {\n            double t = Math.abs(root.val - target);\n            if (t < max || (t == max && root.val < ans)) {\n                max = t;\n                ans = root.val;\n            }\n            if (root.val > target) {\n                root = root.left;\n            } else {\n                root = root.right;\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "271": {
    "solution": {
      "design": "public class Codec {\n\n    // Encodes a list of strings to a single string.\n    public String encode(List<String> strs) {\n        StringBuilder ans = new StringBuilder();\n        for (String s : strs) {\n            ans.append((char) s.length()).append(s);\n        }\n        return ans.toString();\n    }\n\n    // Decodes a single string to a list of strings.\n    public List<String> decode(String s) {\n        List<String> ans = new ArrayList<>();\n        int i = 0, n = s.length();\n        while (i < n) {\n            int size = s.charAt(i++);\n            ans.add(s.substring(i, i + size));\n            i += size;\n        }\n        return ans;\n    }\n}"
    }
  },
  "272": {
    "solution": {
      "two-pointers": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<Integer> ans;\n    private double target;\n    private int k;\n\n    public List<Integer> closestKValues(TreeNode root, double target, int k) {\n        ans = new LinkedList<>();\n        this.target = target;\n        this.k = k;\n        dfs(root);\n        return ans;\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (ans.size() < k) {\n            ans.add(root.val);\n        } else {\n            if (Math.abs(root.val - target) >= Math.abs(ans.get(0) - target)) {\n                return;\n            }\n            ans.remove(0);\n            ans.add(root.val);\n        }\n        dfs(root.right);\n    }\n}"
    }
  },
  "273": {
    "solution": {
      "recursion": "class Solution {\n    private final String[] belowTwenty = {\"\", \"One\", \"Two\", \"Three\", \"Four\", \"Five\", \"Six\", \"Seven\", \"Eight\", \"Nine\", \"Ten\",\n        \"Eleven\", \"Twelve\", \"Thirteen\", \"Fourteen\", \"Fifteen\", \"Sixteen\", \"Seventeen\", \"Eighteen\", \"Nineteen\"};\n    private final String[] tens = {\"\", \"\", \"Twenty\", \"Thirty\", \"Forty\", \"Fifty\", \"Sixty\", \"Seventy\", \"Eighty\", \"Ninety\"};\n    private final String[] scales = {\"\", \"Thousand\", \"Million\", \"Billion\"};\n\n    public String numberToWords(int num) {\n        if (num == 0) return \"Zero\";\n\n        String result = \"\";\n        int i = 0;\n        while (num > 0) {\n            if (num % 1000 != 0) {\n                result = helper(num % 1000) + (scales[i].isEmpty() ? \"\" : \" \" + scales[i]) + (result.isEmpty() ? \"\" : \" \" + result);\n            }\n            num /= 1000;\n            i++;\n        }\n        return result.trim();\n    }\n\n    private String helper(int num) {\n        if (num == 0) return \"\";\n        if (num < 20) return belowTwenty[num];\n        if (num < 100) return tens[num / 10] + (num % 10 == 0 ? \"\" : \" \" + belowTwenty[num % 10]);\n        return belowTwenty[num / 100] + \" Hundred\" + (num % 100 == 0 ? \"\" : \" \" + helper(num % 100));\n    }\n}"
    }
  },
  "274": {
    "solution": {
      "counting-sort": "class Solution {\n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int[] count = new int[n + 1];\n        \n        for (int c : citations) {\n            if (c >= n) {\n                count[n]++;\n            } else {\n                count[c]++;\n            }\n        }\n        \n        // Calculate the H-Index\n        int total = 0;\n        for (int i = n; i >= 0; i--) {\n            total += count[i];\n            if (total >= i) {\n                return i;\n            }\n        }\n        \n        return 0;\n    }\n}\n"
    }
  },
  "275": {
    "solution": {
      "array": "class Solution {\n    public int hIndex(int[] citations) {\n        int n = citations.length;\n        int left = 0, right = n;\n        while (left < right) {\n            int mid = (left + right + 1) >> 1;\n            if (citations[n - mid] >= mid) {\n                left = mid;\n            } else {\n                right = mid - 1;\n            }\n        }\n        return left;\n    }\n}"
    }
  },
  "276": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numWays(int n, int k) {\n        if (n == 0) return 0;\n        if (n == 1) return k;\n        \n        int same = 0, diff = k;\n        for (int i = 2; i <= n; i++) {\n            int prevDiff = diff;\n            diff = (same + diff) * (k - 1);\n            same = prevDiff;\n        }\n        return same + diff;\n    }\n}"
    }
  },
  "277": {
    "solution": {
      "interactive": "/* The knows API is defined in the problem statement */\npublic class Solution {\n    public int findCelebrity(int n) {\n        int cand = 0;\n        \n        // Step 1: Select the candidate\n        for (int i = 1; i < n; i++) {\n            if (knows(cand, i)) {\n                cand = i; // If cand knows i, cand cannot be a celebrity.\n            }\n        }\n\n        // Step 2: Verify if the selected candidate is a celebrity\n        for (int i = 0; i < n; i++) {\n            if (i != cand) {\n                if (knows(cand, i) || !knows(i, cand)) {\n                    return -1; // Not a celebrity\n                }\n            }\n        }\n        \n        return cand;\n    }\n}"
    }
  },
  "278": {
    "solution": {
      "interactive": "/* The isBadVersion API is defined in the parent class VersionControl.\n      boolean isBadVersion(int version); */\n\npublic class Solution extends VersionControl {\n    public int firstBadVersion(int n) {\n        int left = 1, right = n;\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2; // Avoids integer overflow\n            \n            if (isBadVersion(mid)) {\n                right = mid; // The first bad version is at mid or before\n            } else {\n                left = mid + 1; // The first bad version is after mid\n            }\n        }\n        \n        return left; // 'left' will point to the first bad version\n    }\n}"
    }
  },
  "279": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numSquares(int n) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, n);\n        dp[0] = 0;\n        dp[1] = 1;\n        for (int i = 2; i <= n; ++i)\n            for (int j = 1; j * j <= i; ++j)\n                dp[i] = Math.min(dp[i], dp[i - j * j] + 1);\n        System.out.println(Arrays.toString(dp));\n        return dp[n];\n    }\n}"
    }
  },
  "280": {
    "solution": {
      "greedy": "class Solution {\n    public void wiggleSort(int[] nums) {\n        for (int i = 1; i < nums.length; ++i) {\n            if ((i % 2 == 1 && nums[i] < nums[i - 1]) || (i % 2 == 0 && nums[i] > nums[i - 1])) {\n                swap(nums, i, i - 1);\n            }\n        }\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int t = nums[i];\n        nums[i] = nums[j];\n        nums[j] = t;\n    }\n}"
    }
  },
  "281": {
    "solution": {
      "iterator": "public class ZigzagIterator {\n    private int curr;\n    private int size;\n    private List<Integer> indexes = new ArrayList<>();\n    private List<List<Integer>> vectors = new ArrayList<>();\n\n    public ZigzagIterator(List<Integer> v1, List<Integer> v2) {\n        curr = 0;\n        size = 2;\n        indexes.add(0);\n        indexes.add(0);\n        vectors.add(v1);\n        vectors.add(v2);\n    }\n\n    public int next() {\n        List<Integer> vector = vectors.get(curr);\n        int index = indexes.get(curr);\n        int res = vector.get(index);\n        indexes.set(curr, index + 1);\n        curr = (curr + 1) % size;\n        return res;\n    }\n\n    public boolean hasNext() {\n        int start = curr;\n        while (indexes.get(curr) == vectors.get(curr).size()) {\n            curr = (curr + 1) % size;\n            if (start == curr) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n\n/**\n * Your ZigzagIterator object will be instantiated and called as such:\n * ZigzagIterator i = new ZigzagIterator(v1, v2);\n * while (i.hasNext()) v[dp()] = i.next();\n */"
    }
  },
  "282": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<String> addOperators(String num, int target) {\n        List<String> result = new ArrayList<>();\n        dfs(result, num, target, new StringBuilder(), 0, 0, 0);\n        return result;\n    }\n\n    private void dfs(List<String> result, String num, int target, StringBuilder expr, int index, long eval, long prevNum) {\n        if (index == num.length()) {\n            if (eval == target) {\n                result.add(expr.toString());\n            }\n            return;\n        }\n\n        for (int i = index; i < num.length(); i++) {\n            if (i != index && num.charAt(index) == '0') break; // Prevent numbers with leading zeros\n            \n            long currNum = Long.parseLong(num.substring(index, i + 1));\n            int exprLen = expr.length();\n            \n            if (index == 0) {\n                // First number in the expression, no operator needed\n                dfs(result, num, target, expr.append(currNum), i + 1, currNum, currNum);\n                expr.setLength(exprLen);\n            } else {\n                // Addition\n                dfs(result, num, target, expr.append(\"+\").append(currNum), i + 1, eval + currNum, currNum);\n                expr.setLength(exprLen);\n\n                // Subtraction\n                dfs(result, num, target, expr.append(\"-\").append(currNum), i + 1, eval - currNum, -currNum);\n                expr.setLength(exprLen);\n\n                // Multiplication\n                dfs(result, num, target, expr.append(\"*\").append(currNum), i + 1, eval - prevNum + prevNum * currNum, prevNum * currNum);\n                expr.setLength(exprLen);\n            }\n        }\n    }\n}"
    }
  },
  "283": {
    "solution": {
      "two-pointers": "public class Solution {\n    public void moveZeroes(int[] nums) {\n        int slow = 0;\n\n        for (int fast = 0; fast < nums.length; fast++) {\n            if (nums[fast] != 0) {\n                int temp = nums[slow];\n                nums[slow] = nums[fast];\n                nums[fast] = temp;\n                slow++;\n            }\n        }\n    }\n}\n"
    }
  },
  "284": {
    "solution": {
      "iterator": "import java.util.*;\n\nclass PeekingIterator implements Iterator<Integer> {\n    private Iterator<Integer> iterator;\n    private Integer nextElement;\n    private boolean hasNext;\n\n    public PeekingIterator(Iterator<Integer> iterator) {\n        this.iterator = iterator;\n        if (iterator.hasNext()) {\n            nextElement = iterator.next();\n            hasNext = true;\n        } else {\n            hasNext = false;\n        }\n    }\n\n    public Integer peek() {\n        return nextElement;\n    }\n    \n    @Override\n    public Integer next() {\n        if (!hasNext) {\n            throw new NoSuchElementException();\n        }\n        Integer result = nextElement;\n        if (iterator.hasNext()) {\n            nextElement = iterator.next();\n        } else {\n            hasNext = false;\n        }\n        return result;\n    }\n    \n    @Override\n    public boolean hasNext() {\n        return hasNext;\n    }\n}\n"
    }
  },
  "285": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    public TreeNode inorderSuccessor(TreeNode root, TreeNode p) {\n        TreeNode ans = null;\n        while (root != null) {\n            if (root.val > p.val) {\n                ans = root;\n                root = root.left;\n            } else {\n                root = root.right;\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "286": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public void wallsAndGates(int[][] rooms) {\n        int m = rooms.length, n = rooms[0].length;\n        Queue<int[]> q = new LinkedList<>();\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (rooms[i][j] == 0) q.offer(new int[]{i, j});\n            }\n        }\n\n        int[][] directions = {{-1,0}, {1,0}, {0,-1}, {0,1}};\n        while (!q.isEmpty()) {\n            int[] curr = q.poll();\n            for (int[] d : directions) {\n                int r = curr[0] + d[0];\n                int c = curr[1] + d[1];\n                if (r < 0 || c < 0 || r >= m || c >= n || rooms[r][c] != Integer.MAX_VALUE) continue;\n                rooms[r][c] = rooms[curr[0]][curr[1]] + 1;\n                q.offer(new int[]{r, c});\n            }\n        }\n    }\n}"
    }
  },
  "287": {
    "solution": {
      "two-pointers": "class Solution {\n    // Floyd's Tortoise and Hare Algorithm\n   public int findDuplicate(int[] nums) {\n        int slow = nums[0];\n        int fast = nums[nums[0]];\n\n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[nums[fast]];\n        }\n\n        slow = 0; \n        while (slow != fast) {\n            slow = nums[slow];\n            fast = nums[fast];\n        }\n\n        return slow;\n    }\n}\n"
    }
  },
  "288": {
    "solution": {
      "design": "class ValidWordAbbr {\n    private Map<String, Set<String>> d = new HashMap<>();\n\n    public ValidWordAbbr(String[] dictionary) {\n        for (var s : dictionary) {\n            d.computeIfAbsent(abbr(s), k -> new HashSet<>()).add(s);\n        }\n    }\n\n    public boolean isUnique(String word) {\n        var ws = d.get(abbr(word));\n        return ws == null || (ws.size() == 1 && ws.contains(word));\n    }\n\n    private String abbr(String s) {\n        int n = s.length();\n        return n < 3 ? s : s.substring(0, 1) + (n - 2) + s.substring(n - 1);\n    }\n}\n\n/**\n * Your ValidWordAbbr object will be instantiated and called as such:\n * ValidWordAbbr obj = new ValidWordAbbr(dictionary);\n * boolean param_1 = obj.isUnique(word);\n */"
    }
  },
  "289": {
    "solution": {
      "matrix": "class Solution {\n    public void gameOfLife(int[][] board) {\n        int numRows = board.length;\n        int numCols = board[0].length;\n      \n        for (int row = 0; row < numRows; ++row) {\n            for (int col = 0; col < numCols; ++col) {\n                // Count live neighbors, initializing at -board[row][col] to offset self-counting if alive\n                int liveNeighbors = -board[row][col];\n                for (int i = row - 1; i <= row + 1; ++i) {\n                    for (int j = col - 1; j <= col + 1; ++j) {\n                        // Check if neighbor is within bounds and alive\n                        if (i >= 0 && i < numRows && j >= 0 && j < numCols && board[i][j] > 0) {\n                            liveNeighbors++;\n                        }\n                    }\n                }\n                            \n                // Rule 1 or Rule 3: Any live cell with fewer than two live neighbors\n                // or with more than three live neighbors dies (set to 2 for temporary state)\n                if (board[row][col] == 1 && (liveNeighbors < 2 || liveNeighbors > 3)) {\n                    board[row][col] = 2;\n                }\n              \n                // Rule 4: Any dead cell with exactly three live neighbors becomes a live cell\n                // (set to -1 for temporary state)\n                if (board[row][col] == 0 && liveNeighbors == 3) {\n                    board[row][col] = -1;\n                }\n            }\n        }\n      \n        for (int row = 0; row < numRows; ++row) {\n            for (int col = 0; col < numCols; ++col) {\n                // A value of 2 means the cell was previously alive and now is dead\n                if (board[row][col] == 2) {\n                    board[row][col] = 0;\n                }\n                // A value of -1 means the cell was previously dead and now is alive\n                else if (board[row][col] == -1) {\n                    board[row][col] = 1;\n                }\n            }\n        }\n    }\n}"
    }
  },
  "290": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public boolean wordPattern(String pattern, String s) {\n        String[] words = s.split(\" \");\n        if (pattern.length() != words.length) return false;\n\n        Map<Character, String> charToWord = new HashMap<>();\n        Map<String, Character> wordToChar = new HashMap<>();\n\n        for (int i = 0; i < pattern.length(); i++) {\n            char c = pattern.charAt(i);\n            String word = words[i];\n\n            if (charToWord.containsKey(c)) {\n                if (!charToWord.get(c).equals(word)) return false;\n            } else {\n                charToWord.put(c, word);\n            }\n\n            if (wordToChar.containsKey(word)) {\n                if (wordToChar.get(word) != c) return false;\n            } else {\n                wordToChar.put(word, c);\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "291": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    private Set<String> visitedWords;\n    private Map<Character, String> patternMap;\n    private String pattern;\n    private String str;\n    private int patternLength;\n    private int strLength;\n\n    public boolean wordPatternMatch(String pattern, String str) {\n        visitedWords = new HashSet<>();\n        patternMap = new HashMap<>();\n        this.pattern = pattern;\n        this.str = str;\n        patternLength = pattern.length();\n        strLength = str.length();\n        return backtrack(0, 0);\n    }\n\n    private boolean backtrack(int patternIndex, int strIndex) {\n        if (patternIndex == patternLength && strIndex == strLength) {\n            return true; // Both pattern and string are fully matched\n        }\n        if (patternIndex == patternLength || strIndex == strLength || patternLength - patternIndex > strLength - strIndex) {\n            return false; // Mismatch in length constraints\n        }\n\n        char currentPatternChar = pattern.charAt(patternIndex);\n        for (int endIndex = strIndex + 1; endIndex <= strLength; ++endIndex) {\n            String currentSubstring = str.substring(strIndex, endIndex);\n\n            // Case: Pattern character already mapped to the same substring\n            if (patternMap.getOrDefault(currentPatternChar, \"\").equals(currentSubstring)) {\n                if (backtrack(patternIndex + 1, endIndex)) {\n                    return true;\n                }\n            }\n\n            // Case: New mapping for pattern character\n            if (!patternMap.containsKey(currentPatternChar) && !visitedWords.contains(currentSubstring)) {\n                patternMap.put(currentPatternChar, currentSubstring);\n                visitedWords.add(currentSubstring);\n\n                if (backtrack(patternIndex + 1, endIndex)) {\n                    return true;\n                }\n\n                // Backtrack: Remove mapping\n                visitedWords.remove(currentSubstring);\n                patternMap.remove(currentPatternChar);\n            }\n        }\n        return false;\n    }\n}"
    }
  },
  "292": {
    "solution": {
      "brainteaser": "class Solution {\n    public boolean canWinNim(int n) {\n        return n % 4 != 0;\n    }\n}\n"
    }
  },
  "293": {
    "solution": {
      "string": "import java.util.*;\n\nclass Solution {\n    public List<String> generatePossibleNextMoves(String s) {\n        List<String> result = new ArrayList<>();\n        char[] chars = s.toCharArray();\n\n        for (int i = 0; i < chars.length - 1; i++) {\n            if (chars[i] == '+' && chars[i + 1] == '+') {\n                chars[i] = chars[i + 1] = '-';\n                result.add(new String(chars));\n                chars[i] = chars[i + 1] = '+';\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "294": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    private Map<Long, Boolean> memo = new HashMap<>();\n    private int n;\n\n    public boolean canWin(String currentState) {\n        n = currentState.length();\n        long mask = 0L;\n        for (int i = 0; i < n; i++) {\n            if (currentState.charAt(i) == '+') {\n                mask |= 1L << i;\n            }\n        }\n        return dfs(mask);\n    }\n\n    private boolean dfs(long mask) {\n        if (memo.containsKey(mask)) return memo.get(mask);\n\n        for (int i = 0; i < n - 1; i++) {\n            if (((mask >> i) & 3L) == 3L) {\n                if (!dfs(mask ^ (3L << i))) {\n                    memo.put(mask, true);\n                    return true;\n                }\n            }\n        }\n\n        memo.put(mask, false);\n        return false;\n    }\n}"
    }
  },
  "295": {
    "solution": {
      "two-pointers": "",
      "ordered-set": "import java.util.Collections;\nimport java.util.PriorityQueue;\n\nclass MedianFinder {\n    private PriorityQueue<Integer> maxHeap; // To store the smaller half of the numbers\n    private PriorityQueue<Integer> minHeap; // To store the larger half of the numbers\n\n    public MedianFinder() {\n        maxHeap = new PriorityQueue<>(Collections.reverseOrder()); // Max-heap for the left side\n        minHeap = new PriorityQueue<>(); // Min-heap for the right side\n    }\n\n    public void addNum(int num) {\n        if (maxHeap.isEmpty() || num <= maxHeap.peek()) {\n            maxHeap.offer(num);\n        } else {\n            minHeap.offer(num);\n        }\n\n        if (maxHeap.size() < minHeap.size()) {\n            maxHeap.offer(minHeap.poll());\n        } else if (maxHeap.size() - minHeap.size() > 1) {\n            minHeap.offer(maxHeap.poll());\n        }\n    }\n\n    public double findMedian() {\n        if (maxHeap.size() == minHeap.size()) {\n            return (double) (maxHeap.peek() + minHeap.peek()) / 2.0;\n        }\n        return (double) maxHeap.peek();\n    }\n}\n\n/**\n * Your MedianFinder object will be instantiated and called as such:\n * MedianFinder obj = new MedianFinder();\n * obj.addNum(num);\n * double param_2 = obj.findMedian();\n */\n"
    }
  },
  "296": {
    "solution": {
      "matrix": "class Solution {\n  public int minTotalDistance(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    List<Integer> rows = new ArrayList<>(); // i indices s.t. grid[i][j] == 1\n    List<Integer> cols = new ArrayList<>(); // j indices s.t. grid[i][j] == 1\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (grid[i][j] == 1)\n          rows.add(i);\n\n    for (int j = 0; j < n; ++j)\n      for (int i = 0; i < m; ++i)\n        if (grid[i][j] == 1)\n          cols.add(j);\n\n    // sum(i - median(rows)) + sum(j - median(cols))\n    return minTotalDistance(rows) + minTotalDistance(cols);\n  }\n\n  private int minTotalDistance(List<Integer> grid) {\n    int sum = 0;\n    int i = 0;\n    int j = grid.size() - 1;\n    while (i < j)\n      sum += grid.get(j--) - grid.get(i++);\n    return sum;\n  }\n}"
    }
  },
  "297": {
    "solution": {
      "design": "import java.util.*;\n\npublic class Codec {\n    public String serialize(TreeNode root) {\n        if (root == null) return \"null\";\n\n        StringBuilder sb = new StringBuilder();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            TreeNode node = queue.poll();\n            if (node != null) {\n                sb.append(node.val).append(\",\");\n                queue.offer(node.left);\n                queue.offer(node.right);\n            } else {\n                sb.append(\"null,\");\n            }\n        }\n\n        sb.setLength(sb.length() - 1);\n        return sb.toString();\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data.equals(\"null\")) return null;\n\n        String[] nodes = data.split(\",\");\n        TreeNode root = new TreeNode(Integer.parseInt(nodes[0]));\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int i = 1;\n\n        while (!queue.isEmpty()) {\n            TreeNode current = queue.poll();\n            if (!nodes[i].equals(\"null\")) {\n                current.left = new TreeNode(Integer.parseInt(nodes[i]));\n                queue.offer(current.left);\n            }\n            i++;\n            if (!nodes[i].equals(\"null\")) {\n                current.right = new TreeNode(Integer.parseInt(nodes[i]));\n                queue.offer(current.right);\n            }\n            i++;\n        }\n\n        return root;\n    }\n}"
    }
  },
  "298": {
    "solution": {
      "depth-first-search": "class Solution {\n    private int maxLength = 0;\n\n    public int longestConsecutive(TreeNode root) {\n        dfs(root);\n        return maxLength;\n    }\n\n    private int dfs(TreeNode node) {\n        if (node == null) return 0;\n\n        int left = dfs(node.left) + 1;\n        int right = dfs(node.right) + 1;\n\n        if (node.left != null && node.left.val != node.val + 1) {\n            left = 1;\n        }\n        if (node.right != null && node.right.val != node.val + 1) {\n            right = 1;\n        }\n\n        int current = Math.max(left, right);\n        maxLength = Math.max(maxLength, current);\n\n        return current;\n    }\n}"
    }
  },
  "299": {
    "solution": {
      "counting": "class Solution {\n    public String getHint(String secret, String guess) {\n        int bulls = 0, cows = 0;\n        int[] count1 = new int[10];\n        int[] count2 = new int[10];\n\n        for (int i = 0; i < secret.length(); i++) {\n            if (secret.charAt(i) == guess.charAt(i)) {\n                bulls++;\n            } else {\n                count1[secret.charAt(i) - '0']++;\n                count2[guess.charAt(i) - '0']++;\n            }\n        }\n\n        for (int i = 0; i < 10; i++) {\n            cows += Math.min(count1[i], count2[i]);\n        }\n\n        return bulls + \"A\" + cows + \"B\";\n    }\n}"
    }
  },
  "300": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int lengthOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, 1);\n\n        int maxLen = 1;\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] > nums[j]) {\n                    dp[i] = Math.max(dp[i], dp[j] + 1);\n                }\n            }\n            maxLen = Math.max(maxLen, dp[i]);\n        }\n\n        return maxLen;\n    }\n}"
    }
  },
  "301": {
    "solution": {
      "backtracking": "class Solution {\n    public List<String> removeInvalidParentheses(String s) {\n        List<String> result = new ArrayList<>();\n        if (s == null) return result;\n\n        Set<String> visited = new HashSet<>();\n        Queue<String> queue = new LinkedList<>();\n        boolean found = false;\n\n        queue.offer(s);\n        visited.add(s);\n\n        while (!queue.isEmpty()) {\n            String curr = queue.poll();\n            if (isValid(curr)) {\n                result.add(curr);\n                found = true;\n            }\n\n            if (found) continue;\n\n            for (int i = 0; i < curr.length(); i++) {\n                if (curr.charAt(i) != '(' && curr.charAt(i) != ')') continue;\n                String next = curr.substring(0, i) + curr.substring(i + 1);\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    queue.offer(next);\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private boolean isValid(String s) {\n        int count = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') count++;\n            else if (c == ')') {\n                count--;\n                if (count < 0) return false;\n            }\n        }\n        return count == 0;\n    }\n}"
    }
  },
  "302": {
    "solution": {
      "matrix": "class Solution {\n    public int minArea(char[][] image, int x, int y) {\n        int top = findTop(image, 0, x);\n        int bottom = findBottom(image, x, image.length - 1);\n        int left = findLeft(image, 0, y);\n        int right = findRight(image, y, image[0].length - 1);\n        return (bottom - top + 1) * (right - left + 1);\n    }\n\n    private int findTop(char[][] image, int low, int high) {\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (hasBlack(image[mid])) high = mid;\n            else low = mid + 1;\n        }\n        return low;\n    }\n\n    private int findBottom(char[][] image, int low, int high) {\n        while (low < high) {\n            int mid = (low + high + 1) / 2;\n            if (hasBlack(image[mid])) low = mid;\n            else high = mid - 1;\n        }\n        return low;\n    }\n\n    private int findLeft(char[][] image, int low, int high) {\n        while (low < high) {\n            int mid = (low + high) / 2;\n            if (hasBlackColumn(image, mid)) high = mid;\n            else low = mid + 1;\n        }\n        return low;\n    }\n\n    private int findRight(char[][] image, int low, int high) {\n        while (low < high) {\n            int mid = (low + high + 1) / 2;\n            if (hasBlackColumn(image, mid)) low = mid;\n            else high = mid - 1;\n        }\n        return low;\n    }\n\n    private boolean hasBlack(char[] row) {\n        for (char c : row) if (c == '1') return true;\n        return false;\n    }\n\n    private boolean hasBlackColumn(char[][] image, int col) {\n        for (int i = 0; i < image.length; i++) {\n            if (image[i][col] == '1') return true;\n        }\n        return false;\n    }\n}"
    }
  },
  "303": {
    "solution": {
      "prefix-sum": "class NumArray {\n    private int[] prefixSum;\n\n    public NumArray(int[] nums) {\n        int n = nums.length;\n        prefixSum = new int[n + 1]; // One extra space for convenience\n        prefixSum[0] = 0; // Base case: sum of no elements is 0\n\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n    }\n\n    // Query: Compute the sum of the range [left, right]\n    public int sumRange(int left, int right) {\n        return prefixSum[right + 1] - prefixSum[left];\n    }\n}\n\n/**\n * Your NumArray object will be instantiated and called as such:\n * NumArray obj = new NumArray(nums);\n * int param_1 = obj.sumRange(left,right);\n */"
    }
  },
  "304": {
    "solution": {
      "matrix": "class NumMatrix {\n  public NumMatrix(int[][] matrix) {\n    if (matrix.length == 0)\n      return;\n\n    int m = matrix.length;\n    int n = matrix[0].length;\n\n    // prefix[i][j] := sum of matrix[0..i)[0..j)\n    prefix = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        prefix[i + 1][j + 1] = matrix[i][j] + prefix[i][j + 1] + prefix[i + 1][j] - prefix[i][j];\n  }\n\n  public int sumRegion(int row1, int col1, int row2, int col2) {\n    return prefix[row2 + 1][col2 + 1] - prefix[row1][col2 + 1]\n         - prefix[row2 + 1][col1] + prefix[row1][col1];\n  }\n\n  private int[][] prefix;\n}\n"
    }
  },
  "305": {
    "solution": {
      "union-find": "class UnionFind {\n    private final int[] p;\n    private final int[] size;\n\n    public UnionFind(int n) {\n        p = new int[n];\n        size = new int[n];\n        for (int i = 0; i < n; ++i) {\n            p[i] = i;\n            size[i] = 1;\n        }\n    }\n\n    public int find(int x) {\n        if (p[x] != x) {\n            p[x] = find(p[x]);\n        }\n        return p[x];\n    }\n\n    public boolean union(int a, int b) {\n        int pa = find(a), pb = find(b);\n        if (pa == pb) {\n            return false;\n        }\n        if (size[pa] > size[pb]) {\n            p[pb] = pa;\n            size[pa] += size[pb];\n        } else {\n            p[pa] = pb;\n            size[pb] += size[pa];\n        }\n        return true;\n    }\n}\n\nclass Solution {\n    public List<Integer> numIslands2(int m, int n, int[][] positions) {\n        int[][] grid = new int[m][n];\n        UnionFind uf = new UnionFind(m * n);\n        int[] dirs = {-1, 0, 1, 0, -1};\n        int cnt = 0;\n        List<Integer> ans = new ArrayList<>();\n        for (var p : positions) {\n            int i = p[0], j = p[1];\n            if (grid[i][j] == 1) {\n                ans.add(cnt);\n                continue;\n            }\n            grid[i][j] = 1;\n            ++cnt;\n            for (int k = 0; k < 4; ++k) {\n                int x = i + dirs[k], y = j + dirs[k + 1];\n                if (x >= 0 && x < m && y >= 0 && y < n && grid[x][y] == 1\n                    && uf.union(i * n + j, x * n + y)) {\n                    --cnt;\n                }\n            }\n            ans.add(cnt);\n        }\n        return ans;\n    }\n}"
    }
  },
  "306": {
    "solution": {
      "backtracking": "class Solution {\n  public boolean isAdditiveNumber(String num) {\n    final int n = num.length();\n\n    // num[0..i] = firstNum\n    for (int i = 0; i < n / 2; ++i) {\n      if (i > 0 && num.charAt(0) == '0')\n        return false;\n      final long firstNum = Long.parseLong(num.substring(0, i + 1));\n      // num[i + 1..j] = secondNum\n      // |thirdNum| >= max(|firstNum|, |secondNum|)\n      for (int j = i + 1; Math.max(i, j - i) < n - j; ++j) {\n        if (j > i + 1 && num.charAt(i + 1) == '0')\n          break;\n        final long secondNum = Long.parseLong(num.substring(i + 1, j + 1));\n        if (dfs(num, firstNum, secondNum, j + 1))\n          return true;\n      }\n    }\n\n    return false;\n  }\n\n  private boolean dfs(final String num, long firstNum, long secondNum, long s) {\n    if (s == num.length())\n      return true;\n\n    final long thirdNum = firstNum + secondNum;\n    final String thirdNumStr = String.valueOf(thirdNum);\n    return num.indexOf(thirdNumStr, (int) s) == s &&\n        dfs(num, secondNum, thirdNum, s + thirdNumStr.length());\n  }\n}"
    }
  },
  "307": {
    "solution": {
      "design": "class NumArray {\n    private int[] tree;\n    private int n;\n\n    public NumArray(int[] nums) {\n        n = nums.length;\n        tree = new int[4 * n];\n        buildTree(nums, 0, n - 1, 0);\n    }\n\n    private void buildTree(int[] nums, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = nums[start];\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        buildTree(nums, start, mid, 2 * node + 1);\n        buildTree(nums, mid + 1, end, 2 * node + 2);\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    public void update(int index, int val) {\n        updateTree(0, n - 1, index, val, 0);\n    }\n\n    private void updateTree(int start, int end, int idx, int val, int node) {\n        if (start == end) {\n            tree[node] = val;\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        if (idx <= mid) {\n            updateTree(start, mid, idx, val, 2 * node + 1);\n        } else {\n            updateTree(mid + 1, end, idx, val, 2 * node + 2);\n        }\n        tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n    }\n\n    public int sumRange(int left, int right) {\n        return queryTree(0, n - 1, left, right, 0);\n    }\n\n    private int queryTree(int start, int end, int left, int right, int node) {\n        if (left > end || right < start) return 0;\n        if (left <= start && end <= right) return tree[node];\n        int mid = start + (end - start) / 2;\n        return queryTree(start, mid, left, right, 2 * node + 1) +\n               queryTree(mid + 1, end, left, right, 2 * node + 2);\n    }\n}",
      "binary-indexed-tree": "/* The Fenwick Tree only stores incremental differences, so updates must be done by adding/subtracting instead of overwriting values.\n\n      Without using delta, the tree would not maintain correct prefix sums.\n      */\n      \n      class NumArray {\n          private int[] nums;\n          private int[] bit;\n          private int n;\n      \n          public NumArray(int[] nums) {\n              this.nums = nums;\n              this.n = nums.length;\n              this.bit = new int[n + 1]; \n      \n              for (int i = 0; i < n; i++) {\n                  add(i + 1, nums[i]); \n              }\n          }\n      \n          public void update(int index, int val) {\n              int delta = val - nums[index]; // add the difference in the fenwick tree\n              nums[index] = val;\n              add(index + 1, delta); \n          }\n      \n          public int sumRange(int left, int right) {\n              return getSum(right + 1) - getSum(left);\n          }\n      \n          private void add(int i, int delta) {\n              while (i <= n) {\n                  bit[i] += delta;\n                  i += i & -i; \n              }\n          }\n      \n          private int getSum(int i) {\n              int sum = 0;\n              while (i > 0) {\n                  sum += bit[i];\n                  i -= i & -i;\n              }\n              return sum;\n          }\n      }\n      \n      /**\n       * Your NumArray object will be instantiated and called as such:\n       * NumArray obj = new NumArray(nums);\n       * obj.update(index,val);\n       * int param_2 = obj.sumRange(left,right);\n       */",
      "segment-tree": "class NumArray {\n    int[] tree;\n    int n;\n\n    public NumArray(int[] nums) {\n        n = nums.length;\n        tree = new int[4 * n];\n        build(nums, 0, n - 1, 0);\n    }\n\n    // Build segment tree\n    private void build(int[] nums, int start, int end, int node) {\n        if (start == end) {\n            tree[node] = nums[start];\n        } else {\n            int mid = (start + end) / 2;\n            build(nums, start, mid, 2 * node + 1);\n            build(nums, mid + 1, end, 2 * node + 2);\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    // Update a value at index\n    public void update(int index, int val) {\n        updateUtil(0, n - 1, index, val, 0);\n    }\n\n    private void updateUtil(int start, int end, int idx, int val, int node) {\n        if (start == end) {\n            tree[node] = val;\n        } else {\n            int mid = (start + end) / 2;\n            if (idx <= mid) {\n                updateUtil(start, mid, idx, val, 2 * node + 1);\n            } else {\n                updateUtil(mid + 1, end, idx, val, 2 * node + 2);\n            }\n            tree[node] = tree[2 * node + 1] + tree[2 * node + 2];\n        }\n    }\n\n    // Query sum from left to right\n    public int sumRange(int left, int right) {\n        return queryUtil(0, n - 1, left, right, 0);\n    }\n\n    private int queryUtil(int start, int end, int l, int r, int node) {\n        if (r < start || end < l) return 0; // no overlap\n        if (l <= start && end <= r) return tree[node]; // complete overlap\n\n        // partial overlap\n        int mid = (start + end) / 2;\n        int leftSum = queryUtil(start, mid, l, r, 2 * node + 1);\n        int rightSum = queryUtil(mid + 1, end, l, r, 2 * node + 2);\n        return leftSum + rightSum;\n    }\n}"
    }
  },
  "308": {
    "solution": {
      "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int m, int n) : sums(m + 1, vector<int>(n + 1)) {}\n\n  void add(int row, int col, int delta) {\n    for (int i = row; i < sums.size(); i += lowbit(i))\n      for (int j = col; j < sums[0].size(); j += lowbit(j))\n        sums[i][j] += delta;\n  }\n\n  int get(int row, int col) {\n    int sum = 0;\n    for (int i = row; i > 0; i -= lowbit(i))\n      for (int j = col; j > 0; j -= lowbit(j))\n        sum += sums[i][j];\n    return sum;\n  }\n\n private:\n  vector<vector<int>> sums;\n\n  static inline int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass NumMatrix {\n public:\n  NumMatrix(vector<vector<int>>& matrix)\n      : matrix(matrix), tree(matrix.size(), matrix[0].size()) {\n    for (int i = 0; i < matrix.size(); ++i)\n      for (int j = 0; j < matrix[0].size(); ++j)\n        tree.add(i + 1, j + 1, matrix[i][j]);\n  }\n\n  void update(int row, int col, int val) {\n    tree.add(row + 1, col + 1, val - matrix[row][col]);\n    matrix[row][col] = val;\n  }\n\n  int sumRegion(int row1, int col1, int row2, int col2) {\n    return tree.get(row2 + 1, col2 + 1) - tree.get(row1, col2 + 1) -\n           tree.get(row2 + 1, col1) + tree.get(row1, col1);\n  }\n\n private:\n  vector<vector<int>> matrix;\n  FenwickTree tree;\n};"
    }
  },
  "309": {
    "solution": {
      "dynamic-programming": "class Solution {\n   public int maxProfit(int[] prices) {\n        int n = prices.length;\n        if (n <= 1) return 0;\n\n        int[] buy = new int[n]; // Maximum profit on each day when a stock is bought\n        int[] sell = new int[n]; // Maximum profit on each day when a stock is sold\n        int[] cooldown = new int[n]; // Maximum profit on each day when a cooldown is in effect\n\n        // Base case initialization\n        buy[0] = -prices[0];\n\n        // Dynamic programming to calculate the maximum profit on each day\n        for (int i = 1; i < n; i++) {\n            buy[i] = Math.max(buy[i - 1], cooldown[i - 1] - prices[i]);\n            sell[i] = Math.max(sell[i - 1], buy[i - 1] + prices[i]);\n            cooldown[i] = Math.max(cooldown[i - 1], sell[i - 1]);\n        }\n\n        // The maximum profit will be the maximum of the last day's sell and cooldown\n        return Math.max(sell[n - 1], cooldown[n - 1]);\n    }\n}"
    }
  },
  "310": {
    "solution": {
      "graph": "/*\nThis Java solution finds the root(s) of the Minimum Height Tree (MHT) in a given tree graph.\nIt efficiently finds the centroids of the tree by trimming the leaf nodes iteratively. \nThe approach is based on Topological Sorting (BFS-based approach).\n*/\n\nimport java.util.*;\n\nclass Solution {\n    public List<Integer> findMinHeightTrees(int n, int[][] edges) {\n        if (n == 1) return Collections.singletonList(0); \n        \n        List<Set<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new HashSet<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n        \n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (graph.get(i).size() == 1) {\n                queue.offer(i);\n            }\n        }\n        \n        while (n > 2) {\n            int size = queue.size();\n            n -= size; \n            \n            for (int i = 0; i < size; i++) {\n                int leaf = queue.poll();\n                int neighbor = graph.get(leaf).iterator().next(); \n                \n                graph.get(neighbor).remove(leaf); \n                if (graph.get(neighbor).size() == 1) { \n                    queue.offer(neighbor);\n                }\n            }\n        }\n        \n        return new ArrayList<>(queue);\n    }\n}"
    }
  },
  "311": {
    "solution": {
      "matrix": "class Solution {\n  public int[][] multiply(int[][] mat1, int[][] mat2) {\n    int m = mat1.length;\n    int n = mat2.length;\n    int l = mat2[0].length;\n    int[][] ans = new int[m][l];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < l; ++j)\n        for (int k = 0; k < n; ++k)\n          ans[i][j] += mat1[i][k] * mat2[k][j];\n\n    return ans;\n  }\n}"
    }
  },
  "312": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int maxCoins(int[] balloonValues) {\n        int numBalloons = balloonValues.length;\n        List<Integer> balloons = new ArrayList<>(Arrays.stream(balloonValues).boxed().toList());\n\n        // Adding 1 at both ends to simplify calculations\n        balloons.add(0, 1);\n        balloons.add(1);\n\n        // dp[left][right] represents the maximum coins obtainable by bursting all balloons between indices left and right.\n        int[][] dp = new int[numBalloons + 2][numBalloons + 2];\n\n        // Iterate over different balloon subsequence lengths\n        for (int length = 0; length < numBalloons; ++length) {\n            for (int left = 1; left < numBalloons - length + 1; ++left) {\n                int right = left + length;\n                // Try bursting each balloon in the range [left, right] last\n                for (int burst = left; burst <= right; ++burst) {\n                    dp[left][right] = Math.max(dp[left][right],\n                            dp[left][burst - 1] + dp[burst + 1][right] + balloons.get(left - 1) * balloons.get(burst) * balloons.get(right + 1));\n                }\n            }\n        }\n\n        System.out.println(Arrays.deepToString(dp));\n        return dp[1][numBalloons];\n    }\n}"
    }
  },
  "313": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int nthSuperUglyNumber(int n, int[] primes) {\n        int k = primes.length;\n        int[] indices = new int[k]; // pointers to track multiplication positions\n        int[] ugly = new int[n];\n        ugly[0] = 1;\n\n        for (int i = 1; i < n; i++) {\n            int min = Integer.MAX_VALUE;\n            for (int j = 0; j < k; j++) {\n                min = Math.min(min, primes[j] * ugly[indices[j]]);\n            }\n            ugly[i] = min;\n\n            for (int j = 0; j < k; j++) {\n                if (primes[j] * ugly[indices[j]] == min) {\n                    indices[j]++;\n                }\n            }\n        }\n\n        return ugly[n - 1];\n    }\n}"
    }
  },
  "314": {
    "solution": {
      "binary-tree": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> verticalOrder(TreeNode root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Map<Integer, List<Integer>> columnMap = new TreeMap<>();\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0));\n\n        while (!queue.isEmpty()) {\n            Pair<TreeNode, Integer> pair = queue.poll();\n            TreeNode node = pair.getKey();\n            int col = pair.getValue();\n\n            columnMap.putIfAbsent(col, new ArrayList<>());\n            columnMap.get(col).add(node.val);\n\n            if (node.left != null) queue.offer(new Pair<>(node.left, col - 1));\n            if (node.right != null) queue.offer(new Pair<>(node.right, col + 1));\n        }\n\n        for (List<Integer> col : columnMap.values()) {\n            result.add(col);\n        }\n        return result;\n    }\n\n    // Helper Pair class for compatibility (if not using JavaFX or javafx.util.Pair)\n    private static class Pair<K, V> {\n        private final K key;\n        private final V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n}"
    }
  },
  "315": {
    "solution": {
      "merge-sort": "class Solution {\n    public List<Integer> countSmaller(int[] nums) {\n        int n = nums.length;\n        int[] countSmaller = new int[n];\n        int[] indices = new int[n];\n        for (int i = 0; i < n; i++) {\n            indices[i] = i;\n        }\n        mergeSort(nums, indices, countSmaller, 0, n - 1);\n        List<Integer> result = new ArrayList<>();\n        for (int count : countSmaller) {\n            result.add(count);\n        }\n        return result;\n    }\n    \n    private void mergeSort(int[] nums, int[] indices, int[] countSmaller, int start, int end) {\n        if (start >= end) {\n            return;\n        }\n        int mid = start + (end - start) / 2;\n        mergeSort(nums, indices, countSmaller, start, mid);\n        mergeSort(nums, indices, countSmaller, mid + 1, end);\n        merge(nums, indices, countSmaller, start, mid, end);\n    }\n    \n    private void merge(int[] nums, int[] indices, int[] countSmaller, int start, int mid, int end) {\n        int leftIndex = start;\n        int rightIndex = mid + 1;\n        int rightCount = 0;\n        int[] newIndices = new int[end - start + 1];\n        int newIndex = 0;\n        \n        while (leftIndex <= mid && rightIndex <= end) {\n            if (nums[indices[rightIndex]] < nums[indices[leftIndex]]) {\n                newIndices[newIndex] = indices[rightIndex];\n                rightCount++;\n                rightIndex++;\n            } else {\n                newIndices[newIndex] = indices[leftIndex];\n                countSmaller[indices[leftIndex]] += rightCount;\n                leftIndex++;\n            }\n            newIndex++;\n        }\n        \n        while (leftIndex <= mid) {\n            newIndices[newIndex] = indices[leftIndex];\n            countSmaller[indices[leftIndex]] += rightCount;\n            leftIndex++;\n            newIndex++;\n        }\n        \n        while (rightIndex <= end) {\n            newIndices[newIndex] = indices[rightIndex];\n            rightIndex++;\n            newIndex++;\n        }\n        \n        System.arraycopy(newIndices, 0, indices, start, end - start + 1);\n    }\n}\n",
      "segment-tree": "import java.util.*;\n\npublic class Solution {\n    class SegmentTree {\n        int[] tree;\n        int size;\n\n        public SegmentTree(int size) {\n            this.size = size;\n            this.tree = new int[4 * size];\n        }\n\n        // Increment count at index\n        public void update(int index, int start, int end, int pos) {\n            if (start == end) {\n                tree[index]++;\n            } else {\n                int mid = (start + end) / 2;\n                if (pos <= mid) {\n                    update(2 * index + 1, start, mid, pos);\n                } else {\n                    update(2 * index + 2, mid + 1, end, pos);\n                }\n                tree[index] = tree[2 * index + 1] + tree[2 * index + 2];\n            }\n        }\n\n        // Query how many numbers < pos\n        public int query(int index, int start, int end, int l, int r) {\n            if (r < start || end < l) return 0; // no overlap\n            if (l <= start && end <= r) return tree[index]; // full overlap\n\n            int mid = (start + end) / 2;\n            int left = query(2 * index + 1, start, mid, l, r);\n            int right = query(2 * index + 2, mid + 1, end, l, r);\n            return left + right;\n        }\n    }\n\n    public List<Integer> countSmaller(int[] nums) {\n        List<Integer> result = new ArrayList<>();\n\n        // 1. Coordinate Compression\n        TreeSet<Integer> set = new TreeSet<>();\n        for (int num : nums) set.add(num);\n\n        Map<Integer, Integer> map = new HashMap<>();\n        int rank = 0;\n        for (int num : set) {\n            map.put(num, rank++);\n        }\n\n        // 2. Build segment tree\n        SegmentTree segTree = new SegmentTree(rank);\n\n        // 3. Traverse from right to left\n        for (int i = nums.length - 1; i >= 0; i--) {\n            int index = map.get(nums[i]);\n            int count = segTree.query(0, 0, rank - 1, 0, index - 1);\n            result.add(count);\n            segTree.update(0, 0, rank - 1, index);\n        }\n\n        // Reverse the result\n        Collections.reverse(result);\n        return result;\n    }\n}"
    }
  },
  "316": {
    "solution": {
      "monotonic-stack": "import java.util.Stack;\n\nclass Solution {\n    public String removeDuplicateLetters(String s) {\n        int[] count = new int[26];\n        for (char c : s.toCharArray()) {\n            count[c - 'a']++;\n        }\n\n        boolean[] visited = new boolean[26];\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            count[c - 'a']--;\n\n            if (visited[c - 'a']) {\n                continue;\n            }\n\n            while (!stack.isEmpty() && stack.peek() > c\n                    && count[stack.peek() - 'a'] > 0) {\n                visited[stack.pop() - 'a'] = false;\n            }\n\n            stack.push(c);\n            visited[c - 'a'] = true;\n        }\n\n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.insert(0, stack.pop());\n        }\n\n        return result.toString();\n    }\n}\n"
    }
  },
  "317": {
    "solution": {
      "matrix": "import java.util.Deque;\nimport java.util.LinkedList;\n\nclass Solution {\n    public int shortestDistance(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        Deque<int[]> queue = new LinkedList<>();\n        int totalBuildings = 0;\n        int[][] reachCount = new int[rows][cols];\n        int[][] distanceSum = new int[rows][cols];\n        int[] directions = {-1, 0, 1, 0, -1};\n\n        for (int row = 0; row < rows; ++row) {\n            for (int col = 0; col < cols; ++col) {\n                if (grid[row][col] == 1) {\n                    ++totalBuildings;\n                    queue.offer(new int[]{row, col});\n                    int distance = 0;\n                    boolean[][] visited = new boolean[rows][cols];\n\n                    while (!queue.isEmpty()) {\n                        ++distance;\n                        for (int levelSize = queue.size(); levelSize > 0; --levelSize) {\n                            int[] cell = queue.poll();\n                            for (int dir = 0; dir < 4; ++dir) {\n                                int newRow = cell[0] + directions[dir];\n                                int newCol = cell[1] + directions[dir + 1];\n\n                                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols \n                                    && grid[newRow][newCol] == 0 && !visited[newRow][newCol]) {\n                                    ++reachCount[newRow][newCol];\n                                    distanceSum[newRow][newCol] += distance;\n                                    queue.offer(new int[]{newRow, newCol});\n                                    visited[newRow][newCol] = true;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        int minDistance = Integer.MAX_VALUE;\n        for (int row = 0; row < rows; ++row) {\n            for (int col = 0; col < cols; ++col) {\n                if (grid[row][col] == 0 && reachCount[row][col] == totalBuildings) {\n                    minDistance = Math.min(minDistance, distanceSum[row][col]);\n                }\n            }\n        }\n        return minDistance == Integer.MAX_VALUE ? -1 : minDistance;\n    }\n}"
    }
  },
  "318": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int maxProduct(String[] words) {\n        int n = words.length;\n        int[] bitMasks = new int[n]; // Store bitmask representation of each word\n        int[] lengths = new int[n]; // Store word lengths\n\n        // Precompute bitmasks and lengths\n        for (int i = 0; i < n; i++) {\n            int mask = 0;\n            for (char ch : words[i].toCharArray()) {\n                mask |= (1 << (ch - 'a')); // Set bit for the character\n            }\n            bitMasks[i] = mask;\n            lengths[i] = words[i].length();\n        }\n\n        int maxProduct = 0;\n\n        // Compare every pair of words\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                if ((bitMasks[i] & bitMasks[j]) == 0) { // No common characters\n                    maxProduct = Math.max(maxProduct, lengths[i] * lengths[j]);\n                }\n            }\n        }\n        return maxProduct;\n    }\n}"
    }
  },
  "319": {
    "solution": {
      "brainteaser": "class Solution {\n    public int bulbSwitch(int n) {\n        return (int) Math.sqrt(n);\n    }\n}\n"
    }
  },
  "320": {
    "solution": {
      "backtracking": "class Solution {\n    public List<String> generateAbbreviations(String word) {\n        int wordLength = word.length();\n        List<String> abbreviations = new ArrayList<>();\n\n        // Iterate through all possible bitmask representations\n        for (int bitmask = 0; bitmask < (1 << wordLength); ++bitmask) {\n            StringBuilder abbreviation = new StringBuilder();\n            int consecutiveOnesCount = 0;\n\n            for (int position = 0; position < wordLength; ++position) {\n                if ((bitmask >> position & 1) == 1) {\n                    // If the bit is set, increase count for abbreviation\n                    ++consecutiveOnesCount;\n                } else {\n                    // If transitioning from a sequence of ones, append the count\n                    if (consecutiveOnesCount > 0) {\n                        abbreviation.append(consecutiveOnesCount);\n                        consecutiveOnesCount = 0;\n                    }\n                    // Append the character from the original word\n                    abbreviation.append(word.charAt(position));\n                }\n            }\n\n            // Append any remaining abbreviation count at the end\n            if (consecutiveOnesCount > 0) {\n                abbreviation.append(consecutiveOnesCount);\n            }\n\n            abbreviations.add(abbreviation.toString());\n        }\n\n        return abbreviations;\n    }\n}"
    }
  },
  "321": {
    "solution": {
      "two-pointers": "class Solution {\n    public int[] maxNumber(int[] nums1, int[] nums2, int k) {\n        int n = nums1.length;\n        int m = nums2.length;\n        int[] maxNum = new int[k];\n        \n        for (int i = Math.max(0, k - m); i <= k && i <= n; ++i) {\n            int[] candidate = merge(maxSubsequence(nums1, i), maxSubsequence(nums2, k - i), k);\n            if (greater(candidate, 0, maxNum, 0)) {\n                maxNum = candidate;\n            }\n        }\n        \n        return maxNum;\n    }\n    \n    private int[] maxSubsequence(int[] nums, int k) {\n        int n = nums.length;\n        int[] stack = new int[k];\n        int top = -1;\n        int remain = n - k; // number of elements to remove\n        for (int num : nums) {\n            while (top >= 0 && stack[top] < num && remain > 0) {\n                top--;\n                remain--;\n            }\n            if (top < k - 1) {\n                stack[++top] = num;\n            } else {\n                remain--; // skip num since top == k - 1\n            }\n        }\n        return stack;\n    }\n    \n    private int[] merge(int[] nums1, int[] nums2, int k) {\n        int[] result = new int[k];\n        int i = 0, j = 0;\n        for (int r = 0; r < k; r++) {\n            if (greater(nums1, i, nums2, j)) {\n                result[r] = nums1[i++];\n            } else {\n                result[r] = nums2[j++];\n            }\n        }\n        return result;\n    }\n    \n    private boolean greater(int[] nums1, int i, int[] nums2, int j) {\n        while (i < nums1.length && j < nums2.length && nums1[i] == nums2[j]) {\n            i++;\n            j++;\n        }\n        return j == nums2.length || (i < nums1.length && nums1[i] > nums2[j]);\n    }\n}\n"
    }
  },
  "322": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int coinChange(int[] coins, int amount) {\n        // Edge case: If amount is 0, we need 0 coins\n        if (amount == 0) return 0;\n\n        // Initialize dp array, set to a large value (amount + 1 is effectively \"infinity\")\n        int[] dp = new int[amount + 1];\n        Arrays.fill(dp, amount + 1);\n        dp[0] = 0; // Base case: 0 coins needed for amount 0\n\n        // Process each amount from 1 to target amount\n        for (int currentAmount = 1; currentAmount <= amount; currentAmount++) {\n            for (int coin : coins) {\n                if (currentAmount >= coin) {\n                    dp[currentAmount] = Math.min(dp[currentAmount], dp[currentAmount - coin] + 1);\n                }\n            }\n        }\n\n        // If dp[amount] remains unchanged, it means we cannot make the amount\n        return dp[amount] == amount + 1 ? -1 : dp[amount];\n    }\n}"
    }
  },
  "323": {
    "solution": {
      "union-find": "import java.util.*;\n\npublic class Solution {\n\n    static class UnionFind {\n        int[] parent;\n        int[] rank;\n\n        public UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        public int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);  // Path compression\n            }\n            return parent[x];\n        }\n\n        public void union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n\n            if (rootX != rootY) {\n                // Union by rank\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootX] = rootY;\n                    rank[rootY]++;\n                }\n            }\n        }\n    }\n\n    public int countComponents(int n, int[][] edges) {\n        UnionFind uf = new UnionFind(n);\n\n        for (int[] edge : edges) {\n            int u = edge[0];\n            int v = edge[1];\n            uf.union(u, v);\n        }\n\n        // Count the number of unique root nodes (i.e., the number of connected components)\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            if (uf.find(i) == i) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test Case 1\n        int n = 5;\n        int[][] edges = {{0, 1}, {1, 2}, {3, 4}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 2\n\n        // Test Case 2\n        n = 4;\n        edges = new int[][]{{0, 1}, {2, 3}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 2\n\n        // Test Case 3\n        n = 6;\n        edges = new int[][]{{0, 1}, {0, 2}, {3, 4}};\n        System.out.println(solution.countComponents(n, edges));  // Output: 3\n    }\n}",
      "depth-first-search": "import java.util.*;\n\nclass Solution {\n    public int countComponents(int n, int[][] edges) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            graph.get(edge[0]).add(edge[1]);\n            graph.get(edge[1]).add(edge[0]);\n        }\n\n        boolean[] visited = new boolean[n];\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (!visited[i]) {\n                count++; \n                dfs(graph, visited, i);\n            }\n        }\n\n        return count;\n    }\n\n    private void dfs(List<List<Integer>> graph, boolean[] visited, int node) {\n        visited[node] = true;\n        for (int neighbor : graph.get(node)) {\n            if (!visited[neighbor]) {\n                dfs(graph, visited, neighbor);\n            }\n        }\n    }\n}"
    }
  },
  "324": {
    "solution": {
      "quickselect": "import java.util.Arrays;\n\npublic class Solution {\n    public void wiggleSort(int[] nums) {\n        int n = nums.length;\n        \n        int median = quickselect(nums, 0, n - 1, n / 2);\n        \n        // Three-way partitioning: Elements less than median go to the left,\n        // Elements equal to median go to the middle, Elements greater than median go to the right\n        int left = 0, right = n - 1, i = 0;\n        while (i <= right) {\n            if (nums[newIndex(i, n)] > median) {\n                swap(nums, newIndex(left++, n), newIndex(i++, n));\n            } else if (nums[newIndex(i, n)] < median) {\n                swap(nums, newIndex(right--, n), newIndex(i, n));\n            } else {\n                i++;\n            }\n        }\n    }\n    \n    // Quickselect to find the k-th smallest element\n    private int quickselect(int[] nums, int left, int right, int k) {\n        while (left < right) {\n            int pivot = partition(nums, left, right);\n            if (pivot == k) {\n                return nums[k];\n            } else if (pivot < k) {\n                left = pivot + 1;\n            } else {\n                right = pivot - 1;\n            }\n        }\n        return nums[left];\n    }\n    \n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (nums[j] < pivot) {\n                swap(nums, i++, j);\n            }\n        }\n        swap(nums, i, right);\n        return i;\n    }\n    \n    private int newIndex(int index, int n) {\n        return (1 + 2 * index) % (n | 1);\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"
    }
  },
  "325": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int maxSubArrayLen(int[] nums, int targetSum) {\n        Map<Long, Integer> prefixSumIndices = new HashMap<>();\n        prefixSumIndices.put(0L, -1); \n        \n        int maxLength = 0;\n        long currentSum = 0;\n\n        for (int index = 0; index < nums.length; ++index) {\n            currentSum += nums[index];\n\n            if (prefixSumIndices.containsKey(currentSum - targetSum)) {\n                maxLength = Math.max(maxLength, index - prefixSumIndices.get(currentSum - targetSum));\n            }\n\n            prefixSumIndices.putIfAbsent(currentSum, index);\n        }\n        return maxLength;\n    }\n}"
    }
  },
  "326": {
    "solution": {
      "math": "class Solution {\n    public boolean isPowerOfThree(int n) {\n        if (n <= 0) return false;\n        while (n % 3 == 0) {\n            n /= 3;\n        }\n        return n == 1;\n    }\n}"
    }
  },
  "327": {
    "solution": {
      "merge-sort": "class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        long[] prefixSum = new long[nums.length + 1];\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        return mergeSortAndCount(prefixSum, 0, prefixSum.length - 1, lower, upper);\n    }\n    \n    private int mergeSortAndCount(long[] prefixSum, int left, int right, int lower, int upper) {\n        if (left >= right) return 0;\n        \n        int mid = left + (right - left) / 2;\n        int count = 0;\n        \n        count += mergeSortAndCount(prefixSum, left, mid, lower, upper);\n        count += mergeSortAndCount(prefixSum, mid + 1, right, lower, upper);\n        count += mergeAndCount(prefixSum, left, mid, right, lower, upper);\n        \n        return count;\n    }\n    \n    private int mergeAndCount(long[] prefixSum, int left, int mid, int right, int lower, int upper) {\n        int count = 0;\n        int i = left;\n        int j = mid + 1;\n        int k = mid + 1;\n        \n        while (i <= mid) {\n            while (j <= right && prefixSum[j] - prefixSum[i] < lower) j++;\n            while (k <= right && prefixSum[k] - prefixSum[i] <= upper) k++;\n            count += (k - j);\n            i++;\n        }\n        \n        long[] sorted = new long[right - left + 1];\n        int p1 = left, p2 = mid + 1, p = 0;\n        while (p1 <= mid || p2 <= right) {\n            if (p2 > right || (p1 <= mid && prefixSum[p1] <= prefixSum[p2])) {\n                sorted[p++] = prefixSum[p1++];\n            } else {\n                sorted[p++] = prefixSum[p2++];\n            }\n        }\n        \n        System.arraycopy(sorted, 0, prefixSum, left, sorted.length);\n        \n        return count;\n    }\n}\n",
      "binary-indexed-tree": "import java.util.*;\n\npublic class Solution {\n    public int countRangeSum(int[] nums, int lower, int upper) {\n        if (nums == null || nums.length == 0) {\n            return 0;\n        }\n\n        int n = nums.length;\n        long[] prefixSums = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSums[i + 1] = prefixSums[i] + nums[i];\n        }\n\n        // Create a sorted list of all possible prefix sums.\n        Set<Long> allSums = new TreeSet<>();\n        for (long sum : prefixSums) {\n            allSums.add(sum);\n            allSums.add(sum - lower);\n            allSums.add(sum - upper);\n        }\n\n        // Map each prefix sum to an index for use in the Fenwick Tree.\n        Map<Long, Integer> sumToIndex = new HashMap<>();\n        int index = 0;\n        for (long sum : allSums) {\n            sumToIndex.put(sum, index++);\n        }\n\n        FenwickTree fenwickTree = new FenwickTree(sumToIndex.size());\n        int count = 0;\n        for (long sum : prefixSums) {\n            int left = sumToIndex.get(sum - upper);\n            int right = sumToIndex.get(sum - lower);\n            count += fenwickTree.query(right) - fenwickTree.query(left - 1);\n            fenwickTree.update(sumToIndex.get(sum), 1);\n        }\n\n        return count;\n    }\n\n    class FenwickTree {\n        private int[] tree;\n        \n        public FenwickTree(int size) {\n            tree = new int[size + 1];\n        }\n        \n        public void update(int index, int delta) {\n            index++;\n            while (index < tree.length) {\n                tree[index] += delta;\n                index += index & -index;\n            }\n        }\n        \n        public int query(int index) {\n            index++;\n            int sum = 0;\n            while (index > 0) {\n                sum += tree[index];\n                index -= index & -index;\n            }\n            return sum;\n        }\n    }\n}\n"
    }
  },
  "328": {
    "solution": {
      "linked-list": "class Solution {\n    public ListNode oddEvenList(ListNode head) {\n        if (head == null || head.next == null) return head;\n\n        ListNode odd = head;\n        ListNode even = head.next;\n        ListNode evenHead = even;\n\n        while (even != null && even.next != null) {\n            odd.next = even.next;\n            odd = odd.next;\n            even.next = odd.next;\n            even = even.next;\n        }\n\n        odd.next = evenHead;\n        return head;\n    }\n\n    // Definition for singly-linked list.\n    public class ListNode {\n        int val;\n        ListNode next;\n        ListNode() {}\n        ListNode(int val) { this.val = val; }\n        ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n    }\n}"
    }
  },
  "329": {
    "solution": {
      "matrix": "class Solution {\n    private int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int[][] memo;\n    private int m, n;\n\n    public int longestIncreasingPath(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return 0;\n        }\n\n        m = matrix.length;\n        n = matrix[0].length;\n        memo = new int[m][n];\n        int maxPath = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                maxPath = Math.max(maxPath, dfs(matrix, i, j));\n            }\n        }\n\n        return maxPath;\n    }\n\n    private int dfs(int[][] matrix, int i, int j) {\n        if (memo[i][j] != 0) {\n            return memo[i][j];\n        }\n\n        int maxLength = 1; \n        for (int[] direction : directions) {\n            int x = i + direction[0];\n            int y = j + direction[1];\n\n            if (x >= 0 && x < m && y >= 0 && y < n && matrix[x][y] > matrix[i][j]) {\n                maxLength = Math.max(maxLength, 1 + dfs(matrix, x, y));\n            }\n        }\n\n        memo[i][j] = maxLength;\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] matrix = {\n            {9, 9, 4},\n            {6, 6, 8},\n            {2, 1, 1}\n        };\n\n        int result = solution.longestIncreasingPath(matrix);\n        System.out.println(\"Longest Increasing Path: \" + result); // Output: 4\n    }\n}\n"
    }
  },
  "330": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int candy(int[] ratings) {\n        int n = ratings.length;\n        int[] candies = new int[n];\n        Arrays.fill(candies, 1);\n\n        // Pass 1: left to right\n        for (int i = 1; i < n; i++) {\n            if (ratings[i] > ratings[i - 1]) {\n                candies[i] = candies[i - 1] + 1;\n            }\n        }\n\n        // Pass 2: right to left\n        for (int i = n - 2; i >= 0; i--) {\n            if (ratings[i] > ratings[i + 1]) {\n                candies[i] = Math.max(candies[i], candies[i + 1] + 1);\n            }\n        }\n\n        int total = 0;\n        for (int candy : candies) {\n            total += candy;\n        }\n\n        return total;\n    }\n}"
    }
  },
  "331": {
    "solution": {
      "string": "class Solution {\n    public boolean isValidSerialization(String preorder) {\n        String[] nodes = preorder.split(\",\");\n        int availableSlots = 1; // Start with one slot for the root\n\n        for (String node : nodes) {\n            // Every node must consume one slot\n            availableSlots--;\n\n            // If at any point slots become negative, the serialization is invalid\n            if (availableSlots < 0) {\n                return false;\n            }\n\n            // If the node is not null, it creates two additional slots for children\n            if (!node.equals(\"#\")) {\n                availableSlots += 2;\n            }\n        }\n\n        // A valid serialization should use exactly all slots\n        return availableSlots == 0;\n    }\n}"
    }
  },
  "332": {
    "solution": {
      "eulerian-circuit": "import java.util.*;\n\npublic class Solution {\n\n    public List<String> findItinerary(List<List<String>> tickets) {\n              Map<String, PriorityQueue<String>> graph = new HashMap<>();\n              for (List<String> ticket : tickets) {\n                  graph.computeIfAbsent(ticket.get(0), k -> new PriorityQueue<>()).add(ticket.get(1));\n              }\n      \n              LinkedList<String> itinerary = new LinkedList<>();\n              // dfs('JFK', graph, itinerary); or else use stack\n      \n              Stack<String> stack = new Stack<>();\n              stack.push('JFK');\n      \n              while (!stack.isEmpty()) {\n                  String currentAirport = stack.peek();\n                  PriorityQueue<String> nextAirports = graph.get(currentAirport);\n      \n                  // If the current airport has any destinations left to visit\n                  if (nextAirports != null && !nextAirports.isEmpty()) {\n                      stack.push(nextAirports.poll());\n                  } else {\n                      // If no destinations left, add to itinerary and backtrack\n                      itinerary.addFirst(stack.pop());\n                  }\n              }\n      \n              return itinerary;\n          }\n\n    private void dfs(String airport, Map<String, PriorityQueue<String>> graph, LinkedList<String> itinerary) {\n        PriorityQueue<String> nextAirports = graph.get(airport);\n        while (nextAirports != null && !nextAirports.isEmpty()) {\n            dfs(nextAirports.poll(), graph, itinerary);\n        }\n        itinerary.addFirst(airport);\n    }\n\n    public static void main(String[] args) {\n              Solution solution = new Solution();\n              List<List<String>> tickets = Arrays.asList(\n                      Arrays.asList('MUC', 'LHR'),\n                      Arrays.asList('JFK', 'MUC'),\n                      Arrays.asList('SFO', 'SJC'),\n                      Arrays.asList('LHR', 'SFO'));\n              List<String> itinerary = solution.findItinerary(tickets);\n              System.out.println(itinerary); // Output: [JFK, MUC, LHR, SFO, SJC]\n          }\n}\n"
    }
  },
  "333": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int ans;\n\n    public int largestBSTSubtree(TreeNode root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    private int[] dfs(TreeNode root) {\n        if (root == null) {\n            return new int[] {Integer.MAX_VALUE, Integer.MIN_VALUE, 0};\n        }\n        int[] left = dfs(root.left);\n        int[] right = dfs(root.right);\n        if (left[1] < root.val && root.val < right[0]) {\n            ans = Math.max(ans, left[2] + right[2] + 1);\n            return new int[] {\n                Math.min(root.val, left[0]), Math.max(root.val, right[1]), left[2] + right[2] + 1};\n        }\n        return new int[] {Integer.MIN_VALUE, Integer.MAX_VALUE, 0};\n    }\n}"
    }
  },
  "334": {
    "solution": {
      "greedy": "class Solution {\n    public boolean increasingTriplet(int[] nums) {\n        int first = Integer.MAX_VALUE;\n        int second = Integer.MAX_VALUE;\n\n        for (int num : nums) {\n            if (num <= first) {\n                first = num;\n            } else if (num <= second) {\n                second = num;\n            } else {\n                return true; // found num > second > first\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "335": {
    "solution": {
      "geometry": "class Solution {\n    public boolean isSelfCrossing(int[] distance) {\n        int n = distance.length;\n        if (n < 4) return false; // A path with fewer than 4 moves cannot cross itself\n\n        for (int i = 3; i < n; i++) {\n            // Case 1: Fourth step crosses the first step\n            if (distance[i] >= distance[i - 2] && distance[i - 1] <= distance[i - 3]) {\n                return true;\n            }\n\n            // Case 2: Fifth step crosses the first step\n            if (i >= 4 && distance[i - 1] == distance[i - 3] && \n                distance[i] + distance[i - 4] >= distance[i - 2]) {\n                return true;\n            }\n\n            // Case 3: Sixth step crosses the first step\n            if (i >= 5 && distance[i - 2] >= distance[i - 4] &&\n                distance[i] + distance[i - 4] >= distance[i - 2] &&\n                distance[i - 1] <= distance[i - 3] &&\n                distance[i - 1] + distance[i - 5] >= distance[i - 3]) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "336": {
    "solution": {
      "hash-table": "class Solution {\n    public List<List<Integer>> palindromePairs(String[] words) {\n        List<List<Integer>> result = new ArrayList<>();\n        Map<String, Integer> wordMap = new HashMap<>();\n        \n        // Store words in a map with their index for quick lookup\n        for (int i = 0; i < words.length; i++) {\n            wordMap.put(words[i], i);\n        }\n\n        for (int i = 0; i < words.length; i++) {\n            String word = words[i];\n            int len = word.length();\n            \n            // Split the word into prefix and suffix\n            for (int j = 0; j <= len; j++) {\n                String prefix = word.substring(0, j);\n                String suffix = word.substring(j);\n\n                // Case 1: If suffix is a palindrome, check reversed prefix\n                if (isPalindrome(suffix)) {\n                    String reversedPrefix = new StringBuilder(prefix).reverse().toString();\n                    if (wordMap.containsKey(reversedPrefix) && wordMap.get(reversedPrefix) != i) {\n                        result.add(Arrays.asList(i, wordMap.get(reversedPrefix)));\n                    }\n                }\n\n                // Case 2: If prefix is a palindrome, check reversed suffix (avoid duplicates when j=0)\n                if (j > 0 && isPalindrome(prefix)) {\n                    String reversedSuffix = new StringBuilder(suffix).reverse().toString();\n                    if (wordMap.containsKey(reversedSuffix) && wordMap.get(reversedSuffix) != i) {\n                        result.add(Arrays.asList(wordMap.get(reversedSuffix), i));\n                    }\n                }\n            }\n        }\n        return result;\n    }\n\n    private boolean isPalindrome(String str) {\n        int left = 0, right = str.length() - 1;\n        while (left < right) {\n            if (str.charAt(left++) != str.charAt(right--)) return false;\n        }\n        return true;\n    }\n}"
    }
  },
  "337": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int rob(TreeNode root) {\n        int[] result = dfs(root);\n        return Math.max(result[0], result[1]);\n    }\n\n    private int[] dfs(TreeNode node) {\n        if (node == null) return new int[2];\n\n        int[] left = dfs(node.left);\n        int[] right = dfs(node.right);\n\n        int rob = node.val + left[1] + right[1];\n        int notRob = Math.max(left[0], left[1]) + Math.max(right[0], right[1]);\n\n        return new int[]{rob, notRob};\n    }\n\n    public class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int x) { val = x; }\n    }\n}"
    }
  },
  "338": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int[] countBits(int n) {\n        int[] bitCounts = new int[n + 1];\n\n        for (int i = 1; i <= n; i++) {\n            bitCounts[i] = bitCounts[i >> 1] + (i & 1);\n        }\n\n        return bitCounts;\n    }\n}"
    }
  },
  "339": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int depthSum(List<NestedInteger> nestedList) {\n        return dfs(nestedList, 1);\n    }\n\n    private int dfs(List<NestedInteger> nestedList, int depth) {\n        int depthSum = 0;\n        for (NestedInteger item : nestedList) {\n            if (item.isInteger()) {\n                depthSum += item.getInteger() * depth;\n            } else {\n                depthSum += dfs(item.getList(), depth + 1);\n            }\n        }\n        return depthSum;\n    }\n}"
    }
  },
  "340": {
    "solution": {
      "sliding-window": "import java.util.HashMap;\n\npublic class Solution {\n    public int lengthOfLongestSubstringKDistinct(String s, int k) {\n        if (s == null || s.length() == 0 || k == 0) {\n            return 0;\n        }\n        \n        HashMap<Character, Integer> map = new HashMap<>();\n        int left = 0;\n        int maxLength = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            map.put(rightChar, map.getOrDefault(rightChar, 0) + 1);\n            \n            while (map.size() > k) {\n                char leftChar = s.charAt(left);\n                map.put(leftChar, map.get(leftChar) - 1);\n                if (map.get(leftChar) == 0) {\n                    map.remove(leftChar);\n                }\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n        \n        return maxLength;\n    }\n}\n"
    }
  },
  "341": {
    "solution": {
      "iterator": "public class NestedIterator implements Iterator<Integer> {\n    private Stack<NestedInteger> stack = new Stack<>();\n\n    public NestedIterator(List<NestedInteger> nestedList) {\n        addInteger(nestedList);\n    }\n\n    @Override\n    public Integer next() {\n        return stack.pop().getInteger();\n    }\n\n    @Override\n    public boolean hasNext() {\n        while (!stack.isEmpty() && !stack.peek().isInteger()) {\n          NestedInteger ni = stack.pop();\n            addInteger(ni.getList());\n        }\n        return !stack.isEmpty();\n    }\n\n    private void addInteger(final List<NestedInteger> nestedList) {\n        for (int i = nestedList.size() - 1; i >= 0; --i)\n            stack.push(nestedList.get(i));\n    }\n}\n"
    }
  },
  "342": {
    "solution": {
      "math": "class Solution {\n    public boolean isPowerOfFour(int n) {\n        return n > 0 && (n & (n - 1)) == 0 && (n - 1) % 3 == 0;\n    }\n}"
    }
  },
  "343": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int integerBreak(int n) {\n        if (n == 2) return 1;\n        if (n == 3) return 2;\n        \n        int[] dp = new int[n + 1];\n        dp[1] = 1;\n        dp[2] = 1;\n        dp[3] = 2;\n        \n        for (int i = 4; i <= n; i++) {\n            for (int j = 1; j < i; j++) {\n                dp[i] = Math.max(dp[i], Math.max(j * (i - j), j * dp[i - j]));\n            }\n        }\n        return dp[n];\n    }\n}"
    }
  },
  "344": {
    "solution": {
      "two-pointers": "public class Solution {\n    public void reverseString(char[] s) {\n        int left = 0;\n        int right = s.length - 1;\n        \n        while (left < right) {\n            char temp = s[left];\n            s[left] = s[right];\n            s[right] = temp;            \n            left++;\n            right--;\n        }\n    }\n}\n"
    }
  },
  "345": {
    "solution": {
      "two-pointers": "import java.util.HashSet;\n\npublic class Solution {\n    public String reverseVowels(String s) {\n        char[] chars = s.toCharArray();\n        HashSet<Character> vowels = new HashSet<>();\n        vowels.addAll(Set.of('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'));\n\n        int left = 0, right = chars.length - 1;\n        while (left < right) {\n            while (left < right && !vowels.contains(chars[left])) {\n                left++;\n            }\n            while (left < right && !vowels.contains(chars[right])) {\n                right--;\n            }\n            if (left < right) {\n                char temp = chars[left];\n                chars[left] = chars[right];\n                chars[right] = temp;\n                left++;\n                right--;\n            }\n        }\n\n        return new String(chars);\n    }\n}\n"
    }
  },
  "346": {
    "solution": {
      "queue": "class MovingAverage {\n    private int[] arr;\n    private int s;\n    private int cnt;\n\n    public MovingAverage(int size) {\n        arr = new int[size];\n    }\n\n    public double next(int val) {\n        int idx = cnt % arr.length;\n        s += val - arr[idx];\n        arr[idx] = val;\n        ++cnt;\n        return s * 1.0 / Math.min(cnt, arr.length);\n    }\n}\n\n/**\n * Your MovingAverage object will be instantiated and called as such:\n * MovingAverage obj = new MovingAverage(size);\n * double param_1 = obj.next(val);\n */"
    }
  },
  "347": {
    "solution": {
      "bucket-sort": "import java.util.*;\n\npublic class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer>[] buckets = new List[nums.length + 1];\n        for (int key : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(key);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(key);\n        }\n\n        // Step 3: Collect the top k frequent elements\n        List<Integer> result = new ArrayList<>();\n        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n            if (buckets[i] != null) {\n                result.addAll(buckets[i]);\n            }\n        }\n\n        int[] topK = new int[k];\n        for (int i = 0; i < k; i++) {\n            topK[i] = result.get(i);\n        }\n        \n        return topK;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = {1, 1, 1, 2, 2, 3};\n        int k1 = 2;\n        System.out.println(Arrays.toString(solution.topKFrequent(nums1, k1))); // Output: [1, 2]\n\n        int[] nums2 = {1};\n        int k2 = 1;\n        System.out.println(Arrays.toString(solution.topKFrequent(nums2, k2))); // Output: [1]\n    }\n}\n",
      "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        List<Integer> uniqueNums = new ArrayList<>(frequencyMap.keySet());\n        int[] result = new int[k];\n        int left = 0, right = uniqueNums.size() - 1;\n        \n        while (left <= right) {\n            int pivotIndex = partition(uniqueNums, frequencyMap, left, right);\n            if (pivotIndex == k - 1) {\n                for (int i = 0; i < k; i++) {\n                    result[i] = uniqueNums.get(i);\n                }\n                break;\n            } else if (pivotIndex < k - 1) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        \n        return result;\n    }\n    \n    private int partition(List<Integer> nums, Map<Integer, Integer> frequencyMap, int left, int right) {\n        int pivotFreq = frequencyMap.get(nums.get(right));\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (frequencyMap.get(nums.get(j)) >= pivotFreq) {\n                Collections.swap(nums, i, j);\n                i++;\n            }\n        }\n        Collections.swap(nums, i, right);\n        return i;\n    }\n}\n",
      "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public int[] topKFrequent(int[] nums, int k) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        PriorityQueue<Map.Entry<Integer, Integer>> heap = new PriorityQueue<>(\n            (a, b) -> a.getValue() - b.getValue()\n        );\n        \n        for (Map.Entry<Integer, Integer> entry : frequencyMap.entrySet()) {\n            heap.offer(entry);\n            if (heap.size() > k) {\n                heap.poll();\n            }\n        }\n        \n        int[] result = new int[k];\n        for (int i = k - 1; i >= 0; i--) {\n            result[i] = heap.poll().getKey();\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "348": {
    "solution": {
      "simulation": "class TicTacToe {\n    private int[] rows;\n    private int[] cols;\n    private int diagonal;\n    private int antiDiagonal;\n\n    public TicTacToe(int n) {\n        rows = new int[n];\n        cols = new int[n];\n        diagonal = 0;\n        antiDiagonal = 0;\n    }\n\n    public int move(int row, int col, int player) {\n        int add = (player == 1) ? 1 : -1;\n        rows[row] += add;\n        cols[col] += add;\n\n        if (row == col) diagonal += add;\n        if (row + col == rows.length - 1) antiDiagonal += add;\n\n        int n = rows.length;\n        if (Math.abs(rows[row]) == n ||\n            Math.abs(cols[col]) == n ||\n            Math.abs(diagonal) == n ||\n            Math.abs(antiDiagonal) == n) {\n            return player;\n        }\n\n        return 0;\n    }\n}"
    }
  },
  "349": {
    "solution": {
      "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int[] intersection(int[] nums1, int[] nums2) {\n        Set<Integer> set = new HashSet<>();\n        Set<Integer> intersect = new HashSet<>();\n        \n        for (int num : nums1) {\n            set.add(num);\n        }\n        \n        for (int num : nums2) {\n            if (set.contains(num)) {\n                intersect.add(num);\n            }\n        }\n        \n        int[] result = new int[intersect.size()];\n        int index = 0;\n        for (int num : intersect) {\n            result[index++] = num;\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "350": {
    "solution": {
      "two-pointers": "import java.util.*;\n\npublic class Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        for (int num : nums1) {\n            map.put(num, map.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer> intersect = new ArrayList<>();\n\n        for (int num : nums2) {\n            if (map.containsKey(num) && map.get(num) > 0) {\n                intersect.add(num);\n                map.put(num, map.get(num) - 1);\n            }\n        }\n\n        int[] result = new int[intersect.size()];\n        int index = 0;\n        for (int num : intersect) {\n            result[index++] = num;\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "351": {
    "solution": {
      "dynamic-programming": "class Solution {\n    private int m;\n    private int n;\n    private int[][] cross = new int[10][10];\n    private boolean[] vis = new boolean[10];\n\n    public int numberOfPatterns(int m, int n) {\n        this.m = m;\n        this.n = n;\n        cross[1][3] = cross[3][1] = 2;\n        cross[1][7] = cross[7][1] = 4;\n        cross[1][9] = cross[9][1] = 5;\n        cross[2][8] = cross[8][2] = 5;\n        cross[3][7] = cross[7][3] = 5;\n        cross[3][9] = cross[9][3] = 6;\n        cross[4][6] = cross[6][4] = 5;\n        cross[7][9] = cross[9][7] = 8;\n        return dfs(1, 1) * 4 + dfs(2, 1) * 4 + dfs(5, 1);\n    }\n\n    private int dfs(int i, int cnt) {\n        if (cnt > n) {\n            return 0;\n        }\n        vis[i] = true;\n        int ans = cnt >= m ? 1 : 0;\n        for (int j = 1; j < 10; ++j) {\n            int x = cross[i][j];\n            if (!vis[j] && (x == 0 || vis[x])) {\n                ans += dfs(j, cnt + 1);\n            }\n        }\n        vis[i] = false;\n        return ans;\n    }\n}"
    }
  },
  "352": {
    "solution": {
      "ordered-set": "class SummaryRanges {\n    private TreeMap<Integer, int[]> map;\n\n    public SummaryRanges() {\n        map = new TreeMap<>();\n    }\n\n    public void addNum(int val) {\n        Integer l = map.floorKey(val);\n        Integer r = map.ceilingKey(val);\n        if (l != null && r != null && map.get(l)[1] + 1 == val && map.get(r)[0] - 1 == val) {\n            map.get(l)[1] = map.get(r)[1];\n            map.remove(r);\n        } else if (l != null && val <= map.get(l)[1] + 1) {\n            map.get(l)[1] = Math.max(val, map.get(l)[1]);\n        } else if (r != null && val >= map.get(r)[0] - 1) {\n            map.get(r)[0] = Math.min(val, map.get(r)[0]);\n        } else {\n            map.put(val, new int[] {val, val});\n        }\n    }\n\n    public int[][] getIntervals() {\n        int[][] res = new int[map.size()][2];\n        int i = 0;\n        for (int[] range : map.values()) {\n            res[i++] = range;\n        }\n        return res;\n    }\n}\n\n/**\n * Your SummaryRanges object will be instantiated and called as such:\n * SummaryRanges obj = new SummaryRanges();\n * obj.addNum(val);\n * int[][] param_2 = obj.getIntervals();\n */"
    }
  },
  "353": {
    "solution": {
      "design": "import java.util.*;\n\nclass SnakeGame {\n    private int width, height, score;\n    private int[][] food;\n    private int foodIndex;\n    private Deque<int[]> snake;\n    private Set<String> snakeSet;\n\n    public SnakeGame(int width, int height, int[][] food) {\n        this.width = width;\n        this.height = height;\n        this.food = food;\n        this.foodIndex = 0;\n        this.score = 0;\n        this.snake = new LinkedList<>();\n        this.snake.add(new int[]{0, 0});\n        this.snakeSet = new HashSet<>();\n        this.snakeSet.add(\"0,0\");\n    }\n\n    public int move(String direction) {\n        int[] head = snake.peekFirst();\n        int x = head[0], y = head[1];\n\n        switch (direction) {\n            case \"U\": x--; break;\n            case \"D\": x++; break;\n            case \"L\": y--; break;\n            case \"R\": y++; break;\n        }\n\n        if (x < 0 || y < 0 || x >= height || y >= width) return -1;\n\n        int[] newHead = new int[]{x, y};\n        String key = x + \",\" + y;\n\n        // Remove tail first (temporary, will add back if eating food)\n        int[] tail = snake.pollLast();\n        snakeSet.remove(tail[0] + \",\" + tail[1]);\n\n        if (snakeSet.contains(key)) return -1;\n\n        snake.addFirst(newHead);\n        snakeSet.add(key);\n\n        if (foodIndex < food.length && x == food[foodIndex][0] && y == food[foodIndex][1]) {\n            score++;\n            foodIndex++;\n            snake.addLast(tail);\n            snakeSet.add(tail[0] + \",\" + tail[1]);\n        }\n\n        return score;\n    }\n}"
    }
  },
  "354": {
    "solution": {
      "dynamic-programming": "// dp[i]: The smallest possible ending height for an increasing subsequence of length i+1.\nimport java.util.Arrays;\n\nclass Solution {\n    public int maxEnvelopes(int[][] envelopes) {\n        int n = envelopes.length;\n        \n        Arrays.sort(envelopes, (a, b) -> {\n            if (a[0] != b[0]) {\n                return a[0] - b[0];\n            } else {\n                return b[1] - a[1];\n            }\n        });\n        \n        int[] heights = new int[n];\n        for (int i = 0; i < n; i++) {\n            heights[i] = envelopes[i][1];\n        }\n\n        int[] dp = new int[n];\n        int length = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int left = 0, right = length;\n            \n            while (left < right) {\n                int mid = left + (right - left) / 2;\n                if (dp[mid] < heights[i]) {\n                    left = mid + 1;\n                } else {\n                    right = mid;\n                }\n            }\n            \n            // If we found a position for the current height, update the dp array\n            dp[left] = heights[i];\n            \n            // If left equals the current length, it means we can extend the LIS\n            if (left == length) {\n                length++;\n            }\n        }\n        \n        return length;\n    }\n}"
    }
  },
  "355": {
    "solution": {
      "design": "class Tweet {\n  public int id;\n  public int time;\n  public Tweet next = null;\n  public Tweet(int id, int time) {\n    this.id = id;\n    this.time = time;\n  }\n}\n\nclass User {\n  private int id;\n  public Set<Integer> followeeIds = new HashSet<>();\n  public Tweet tweetHead = null;\n\n  public User(int id) {\n    this.id = id;\n    follow(id); \n  }\n\n  public void follow(int followeeId) {\n    followeeIds.add(followeeId);\n  }\n\n  public void unfollow(int followeeId) {\n    followeeIds.remove(followeeId);\n  }\n\n  public void post(int tweetId, int time) {\n    final Tweet oldTweetHead = tweetHead;\n    tweetHead = new Tweet(tweetId, time);\n    tweetHead.next = oldTweetHead;\n  }\n}\n\nclass Twitter {\n  public void postTweet(int userId, int tweetId) {\n    users.putIfAbsent(userId, new User(userId));\n    users.get(userId).post(tweetId, time++);\n  }\n\n  public List<Integer> getNewsFeed(int userId) {\n    if (!users.containsKey(userId))\n      return new ArrayList<>();\n\n    List<Integer> newsFeed = new ArrayList<>();\n    PriorityQueue<Tweet> pq = new PriorityQueue<>((a, b) -> b.time - a.time);\n\n    for (final int followeeId : users.get(userId).followeeIds) {\n      Tweet tweetHead = users.get(followeeId).tweetHead;\n      if (tweetHead != null)\n        pq.offer(tweetHead);\n    }\n\n    int count = 0;\n    while (!pq.isEmpty() && count++ < 10) {\n      Tweet tweet = pq.poll();\n      newsFeed.add(tweet.id);\n      if (tweet.next != null)\n        pq.offer(tweet.next);\n    }\n\n    return newsFeed;\n  }\n\n  public void follow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    users.putIfAbsent(followerId, new User(followerId));\n    users.putIfAbsent(followeeId, new User(followeeId));\n    users.get(followerId).follow(followeeId);\n  }\n\n  public void unfollow(int followerId, int followeeId) {\n    if (followerId == followeeId)\n      return;\n    if (users.containsKey(followerId) && users.containsKey(followeeId))\n      users.get(followerId).unfollow(followeeId);\n  }\n\n  private int time = 0;\n  private Map<Integer, User> users = new HashMap<>(); \n}\n\n/**\n * Your Twitter object will be instantiated and called as such:\n * Twitter obj = new Twitter();\n * obj.postTweet(userId,tweetId);\n * List<Integer> param_2 = obj.getNewsFeed(userId);\n * obj.follow(followerId,followeeId);\n * obj.unfollow(followerId,followeeId);\n */"
    }
  },
  "356": {
    "solution": {
      "geometry": "import java.util.*;\n\nclass Solution {\n    public boolean isReflected(int[][] points) {\n        Set<String> set = new HashSet<>();\n        int minX = Integer.MAX_VALUE;\n        int maxX = Integer.MIN_VALUE;\n\n        for (int[] p : points) {\n            minX = Math.min(minX, p[0]);\n            maxX = Math.max(maxX, p[0]);\n            set.add(p[0] + \",\" + p[1]);\n        }\n\n        double mid = (minX + maxX) / 2.0;\n        for (int[] p : points) {\n            int reflectedX = (int)(2 * mid - p[0]);\n            String reflected = reflectedX + \",\" + p[1];\n            if (!set.contains(reflected)) return false;\n        }\n\n        return true;\n    }\n}"
    }
  },
  "357": {
    "solution": {
      "math": "class Solution {\n    public int countNumbersWithUniqueDigits(int n) {\n        if (n == 0) return 1;\n        if (n == 1) return 10;\n\n        int count = 10;\n        int uniqueDigits = 9;\n        int available = 9;\n\n        for (int i = 2; i <= n && available > 0; i++) {\n            uniqueDigits *= available;\n            count += uniqueDigits;\n            available--;\n        }\n\n        return count;\n    }\n}"
    }
  },
  "358": {
    "solution": {
      "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public String rearrangeString(String s, int k) {\n        int stringLength = s.length();\n        int[] charFrequency = new int[26];\n\n        // Count the frequency of each character in the string\n        for (char character : s.toCharArray()) {\n            charFrequency[character - 'a']++;\n        }\n\n        // Max-heap to store characters sorted by frequency\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> b[0] - a[0]);\n        for (int i = 0; i < 26; i++) {\n            if (charFrequency[i] > 0) {\n                maxHeap.offer(new int[]{charFrequency[i], i});\n            }\n        }\n\n        // Queue to keep track of characters that need to wait before being reinserted\n        Deque<int[]> waitQueue = new ArrayDeque<>();\n        StringBuilder result = new StringBuilder();\n\n        while (!maxHeap.isEmpty()) {\n            int[] current = maxHeap.poll();\n            int frequency = current[0];\n            int characterIndex = current[1];\n\n            // Append the most frequent character to the result\n            result.append((char) ('a' + characterIndex));\n\n            // Reduce the frequency and add it to the waiting queue\n            waitQueue.offer(new int[]{frequency - 1, characterIndex});\n\n            // If we have at least k elements in the queue, process the front one\n            if (waitQueue.size() >= k) {\n                int[] front = waitQueue.pollFirst();\n                if (front[0] > 0) {\n                    maxHeap.offer(front);\n                }\n            }\n        }\n\n        return result.length() == stringLength ? result.toString() : \"\";\n    }\n}"
    }
  },
  "359": {
    "solution": {
      "design": "class Logger {\n\n    private Map<String, Integer> limiter;\n\n    /** Initialize your data structure here. */\n    public Logger() {\n        limiter = new HashMap<>();\n    }\n\n    /**\n       Returns true if the message should be printed in the given timestamp, otherwise returns\n       false. If this method returns false, the message will not be printed. The timestamp is in\n       seconds granularity.\n     */\n    public boolean shouldPrintMessage(int timestamp, String message) {\n        int t = limiter.getOrDefault(message, 0);\n        if (t > timestamp) {\n            return false;\n        }\n        limiter.put(message, timestamp + 10);\n        return true;\n    }\n}\n\n/**\n * Your Logger object will be instantiated and called as such:\n * Logger obj = new Logger();\n * boolean param_1 = obj.shouldPrintMessage(timestamp,message);\n */"
    }
  },
  "360": {
    "solution": {
      "two-pointers": "class Solution {\n    public int[] sortTransformedArray(int[] nums, int a, int b, int c) {\n        int n = nums.length;\n        int left = 0, right = n - 1, k = a < 0 ? 0 : n - 1;\n        int[] res = new int[n];\n        while (left <= right) {\n            int v1 = fn(a, b, c, nums[left]), v2 = fn(a, b, c, nums[right]);\n            if (a < 0) {\n                if (v1 <= v2) {\n                    res[k] = v1;\n                    ++left;\n                } else {\n                    res[k] = v2;\n                    --right;\n                }\n                ++k;\n            } else {\n                if (v1 >= v2) {\n                    res[k] = v1;\n                    ++left;\n                } else {\n                    res[k] = v2;\n                    --right;\n                }\n                --k;\n            }\n        }\n        return res;\n    }\n\n    private int fn(int a, int b, int c, int x) {\n        return a * x * x + b * x + c;\n    }\n}\n"
    }
  },
  "361": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int maxKilledEnemies(char[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) return 0;\n        int rows = grid.length, cols = grid[0].length, max = 0;\n        int rowHits = 0;\n        int[] colHits = new int[cols];\n\n        for (int i = 0; i < rows; ++i) {\n            for (int j = 0; j < cols; ++j) {\n                if (j == 0 || grid[i][j - 1] == 'W') {\n                    rowHits = 0;\n                    for (int k = j; k < cols && grid[i][k] != 'W'; ++k) {\n                        if (grid[i][k] == 'E') rowHits++;\n                    }\n                }\n\n                if (i == 0 || grid[i - 1][j] == 'W') {\n                    colHits[j] = 0;\n                    for (int k = i; k < rows && grid[k][j] != 'W'; ++k) {\n                        if (grid[k][j] == 'E') colHits[j]++;\n                    }\n                }\n\n                if (grid[i][j] == '0') {\n                    max = Math.max(max, rowHits + colHits[j]);\n                }\n            }\n        }\n\n        return max;\n    }\n}"
    }
  },
  "362": {
    "solution": {
      "design": "import java.util.*;\n\nclass HitCounter {\n    Queue<Integer> queue;\n\n    public HitCounter() {\n        queue = new LinkedList<>();\n    }\n\n    public void hit(int timestamp) {\n        queue.offer(timestamp);\n    }\n\n    public int getHits(int timestamp) {\n        while (!queue.isEmpty() && queue.peek() <= timestamp - 300) {\n            queue.poll();\n        }\n        return queue.size();\n    }\n}"
    }
  },
  "363": {
    "solution": {
      "matrix": "import java.util.TreeSet;\n\npublic class Solution {\n    public int maxSumSubmatrix(int[][] matrix, int k) {\n        int rows = matrix.length, cols = matrix[0].length;\n        int maxSum = Integer.MIN_VALUE;\n\n        // Iterate over row start\n        for (int startRow = 0; startRow < rows; startRow++) {\n            int[] colSums = new int[cols];\n\n            // Iterate over row end\n            for (int endRow = startRow; endRow < rows; endRow++) {\n                // Compute column sums for this row range\n                for (int col = 0; col < cols; col++) {\n                    colSums[col] += matrix[endRow][col];\n                }\n                \n                // Find max subarray sum no greater than K\n                maxSum = Math.max(maxSum, getMaxSubarraySum(colSums, k));\n            }\n        }\n        return maxSum;\n    }\n\n    private int getMaxSubarraySum(int[] nums, int k) {\n        TreeSet<Integer> prefixSums = new TreeSet<>();\n        prefixSums.add(0);\n        int maxSum = Integer.MIN_VALUE, prefixSum = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n\n            // Find the smallest prefix sum such that (prefixSum - x) <= k\n            Integer target = prefixSums.ceiling(prefixSum - k);\n            if (target != null) {\n                maxSum = Math.max(maxSum, prefixSum - target);\n            }\n\n            // Insert current prefix sum into TreeSet\n            prefixSums.add(prefixSum);\n        }\n        return maxSum;\n    }\n}"
    }
  },
  "364": {
    "solution": {
      "stack": "class Solution {\n    public int depthSumInverse(List<NestedInteger> nestedList) {\n        int depth = maxDepth(nestedList);\n        return dfs(nestedList, depth);\n    }\n\n    private int maxDepth(List<NestedInteger> nestedList) {\n        int depth = 1;\n        for (NestedInteger item : nestedList) {\n            if (item.isInteger()) {\n                continue;\n            }\n            depth = Math.max(depth, 1 + maxDepth(item.getList()));\n        }\n        return depth;\n    }\n\n    private int dfs(List<NestedInteger> nestedList, int depth) {\n        int depthSum = 0;\n        for (NestedInteger item : nestedList) {\n            if (item.isInteger()) {\n                depthSum += item.getInteger() * depth;\n            } else {\n                depthSum += dfs(item.getList(), depth - 1);\n            }\n        }\n        return depthSum;\n    }\n}"
    }
  },
  "365": {
    "solution": {
      "breadth-first-search": "class Solution {\n    public boolean canMeasureWater(int jug1Capacity, int jug2Capacity, int targetCapacity) {\n        if (targetCapacity > jug1Capacity + jug2Capacity) {\n            return false; // The total capacity is not enough to measure the target\n        }\n        return targetCapacity % gcd(jug1Capacity, jug2Capacity) == 0;\n    }\n\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}"
    }
  },
  "366": {
    "solution": {
      "binary-tree": "class Solution {\n    public List<List<Integer>> findLeaves(TreeNode root) {\n        List<List<Integer>> res = new ArrayList<>();\n        dfs(root, res);\n        return res;\n    }\n\n    private int dfs(TreeNode node, List<List<Integer>> res) {\n        if (node == null) return -1;\n        int level = 1 + Math.max(dfs(node.left, res), dfs(node.right, res));\n        if (res.size() <= level) res.add(new ArrayList<>());\n        res.get(level).add(node.val);\n        return level;\n    }\n\n    public static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n    }\n}"
    }
  },
  "367": {
    "solution": {
      "math": "class Solution {\n    public boolean isPerfectSquare(int num) {\n        if (num < 2) return true;\n\n        long left = 2, right = num / 2;\n        while (left <= right) {\n            long mid = left + (right - left) / 2;\n            long guess = mid * mid;\n\n            if (guess == num) return true;\n            if (guess > num) right = mid - 1;\n            else left = mid + 1;\n        }\n        return false;\n    }\n}"
    }
  },
  "368": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public List<Integer> largestDivisibleSubset(int[] nums) {\n        if (nums == null || nums.length == 0) return new ArrayList<>();\n\n        Arrays.sort(nums);\n        int n = nums.length;\n        int[] dp = new int[n]; // dp[i] stores the size of the largest subset ending at index i\n        int[] prev = new int[n]; // prev[i] stores the previous index in the subset\n        Arrays.fill(dp, 1);\n        Arrays.fill(prev, -1);\n\n        int maxSize = 1, maxIndex = 0;\n\n        // Build the DP table\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < i; j++) {\n                if (nums[i] % nums[j] == 0 && dp[i] < dp[j] + 1) {\n                    dp[i] = dp[j] + 1;\n                    prev[i] = j;\n                }\n            }\n            if (dp[i] > maxSize) {\n                maxSize = dp[i];\n                maxIndex = i;\n            }\n        }\n\n        // Reconstruct the subset\n        List<Integer> result = new ArrayList<>();\n        while (maxIndex != -1) {\n            result.add(nums[maxIndex]);\n            maxIndex = prev[maxIndex];\n        }\n\n        Collections.reverse(result); // Since we traced back, we need to reverse the list\n        return result;\n    }\n}"
    }
  },
  "369": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode plusOne(ListNode head) {\n        ListNode dummy = new ListNode(0, head);\n        ListNode target = dummy;\n        while (head != null) {\n            if (head.val != 9) {\n                target = head;\n            }\n            head = head.next;\n        }\n        ++target.val;\n        target = target.next;\n        while (target != null) {\n            target.val = 0;\n            target = target.next;\n        }\n        return dummy.val == 1 ? dummy : dummy.next;\n    }\n}"
    }
  },
  "370": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int[] getModifiedArray(int length, int[][] updates) {\n        int[] result = new int[length];\n\n        // Apply the difference array technique\n        for (var update : updates) {\n            int startIndex = update[0];\n            int endIndex = update[1];\n            int increment = update[2];\n\n            result[startIndex] += increment;\n            if (endIndex + 1 < length) {\n                result[endIndex + 1] -= increment;\n            }\n        }\n\n        // Compute the prefix sum to get the final modified array\n        for (int i = 1; i < length; i++) {\n            result[i] += result[i - 1];\n        }\n\n        return result;\n    }\n}"
    }
  },
  "371": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int getSum(int a, int b) {\n        while (b != 0) {\n            int carry = a & b;\n            a = a ^ b;\n            b = carry << 1;\n        }\n        return a;\n    }\n}"
    }
  },
  "372": {
    "solution": {
      "divide-and-conquer": "class Solution {\n    private static final int MODULO = 1337;\n\n    public int superPow(int base, int[] exponent) {\n        base %= MODULO; // Reduce base within the modulo range\n        return powerMod(base, exponent, exponent.length);\n    }\n\n    private int powerMod(int base, int[] exponent, int length) {\n        if (length == 0) {\n            return 1; // Base case: any number to the power of 0 is 1\n        }\n\n        // Compute powerMod(base, exponent[0..n-2])\n        int partialResult = powerMod(base, exponent, length - 1);\n\n        // Current digit as an exponent\n        int lastDigit = exponent[length - 1];\n\n        // Compute (partialResult^10 * base^lastDigit) % MODULO\n        return (modularExponentiation(partialResult, 10) * modularExponentiation(base, lastDigit)) % MODULO;\n    }\n\n    private int modularExponentiation(int base, int exponent) {\n        int result = 1;\n        base %= MODULO;\n        while (exponent > 0) {\n            if (exponent % 2 == 1) { // If exponent is odd, multiply base\n                result = (result * base) % MODULO;\n            }\n            base = (base * base) % MODULO; // Square base\n            exponent /= 2;\n        }\n        return result;\n    }\n}"
    }
  },
  "373": {
    "solution": {
      "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> kSmallestPairs(int[] nums1, int[] nums2, int k) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (nums1.length == 0 || nums2.length == 0 || k == 0) {\n            return result;\n        }\n\n        // Min-heap to store pairs (sum, index1, index2)\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> (nums1[a[0]] + nums2[a[1]])));\n\n        // Push first k pairs from nums1 with the first element of nums2\n        for (int i = 0; i < Math.min(k, nums1.length); i++) {\n            minHeap.offer(new int[]{i, 0}); // (index in nums1, index in nums2)\n        }\n\n        while (k > 0 && !minHeap.isEmpty()) {\n            int[] indices = minHeap.poll();\n            int i = indices[0], j = indices[1];\n\n            // Add the smallest pair to the result\n            result.add(Arrays.asList(nums1[i], nums2[j]));\n            k--;\n\n            // Push the next pair (i, j+1) into the heap if within bounds\n            if (j + 1 < nums2.length) {\n                minHeap.offer(new int[]{i, j + 1});\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "374": {
    "solution": {
      "interactive": "/** \n * Forward declaration of guess API.\n * @param  num   your guess\n * @return       -1 if num is higher than the picked number\n *                1 if num is lower than the picked number\n *                otherwise return 0\n * int guess(int num);\n */\n\npublic class Solution extends GuessGame {\n    public int guessNumber(int n) {\n        int left = 1, right = n;\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2; // Prevents overflow\n            \n            int result = guess(mid);\n            if (result == 0) {\n                return mid;  // Found the correct number\n            } else if (result == -1) {\n                right = mid - 1;  // Target is smaller\n            } else {\n                left = mid + 1;  // Target is larger\n            }\n        }\n        \n        return -1; // This line should never be reached\n    }\n}"
    }
  },
  "375": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int getMoneyAmount(int n) {\n        int[][] dp = new int[n + 1][n + 1];\n\n        for (int len = 2; len <= n; ++len) {\n            for (int start = 1; start <= n - len + 1; ++start) {\n                int end = start + len - 1;\n                dp[start][end] = Integer.MAX_VALUE;\n                for (int pivot = start; pivot <= end; ++pivot) {\n                    int left = (pivot > start) ? dp[start][pivot - 1] : 0;\n                    int right = (pivot < end) ? dp[pivot + 1][end] : 0;\n                    int cost = pivot + Math.max(left, right);\n                    dp[start][end] = Math.min(dp[start][end], cost);\n                }\n            }\n        }\n\n        return dp[1][n];\n    }\n}"
    }
  },
  "376": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int wiggleMaxLength(int[] nums) {\n        if (nums.length < 2) return nums.length;\n\n        int up = 1, down = 1;\n        \n        for (int i = 1; i < nums.length; i++) {\n            if (nums[i] > nums[i - 1]) {\n                up = down + 1;\n            } else if (nums[i] < nums[i - 1]) {\n                down = up + 1;\n            }\n        }\n        \n        return Math.max(up, down);\n    }\n}"
    }
  },
  "377": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int combinationSum4(int[] nums, int target) {\n        long[] dp = new long[target + 1];\n        dp[0] = 1; // Base case: one way to form target 0\n\n        for (int i = 1; i <= target; i++) {\n            for (int num : nums) {\n                if (i >= num) {\n                    dp[i] += dp[i - num];\n                }\n            }\n        }\n\n        return (int) dp[target];\n    }\n}"
    }
  },
  "378": {
    "solution": {
      "matrix": "import java.util.PriorityQueue;\n\nclass Solution {\n    public int kthSmallest(int[][] matrix, int k) {\n        int n = matrix.length;\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]);\n        \n        for (int j = 0; j < n; j++) {\n            minHeap.offer(new int[]{matrix[0][j], 0, j}); // value, row, col\n        }\n        \n        for (int i = 0; i < k - 1; i++) {\n            int[] current = minHeap.poll();\n            int row = current[1];\n            int col = current[2];\n            \n            if (row < n - 1) {\n                minHeap.offer(new int[]{matrix[row + 1][col], row + 1, col});\n            }\n        }\n        \n        return minHeap.poll()[0];\n    }\n}\n"
    }
  },
  "379": {
    "solution": {
      "design": "import java.util.HashSet;\n\nclass PhoneDirectory {\n    private HashSet<Integer> pool;\n\n    public PhoneDirectory(int maxNumbers) {\n        pool = new HashSet<>();\n        for (int i = 0; i < maxNumbers; i++) {\n            pool.add(i);\n        }\n    }\n\n    public int get() {\n        if (pool.isEmpty()) {\n            return -1;\n        }\n        int number = pool.iterator().next();\n        pool.remove(number);\n        return number;\n    }\n\n    public boolean check(int number) {\n        return pool.contains(number);\n    }\n\n    public void release(int number) {\n        pool.add(number);\n    }\n}"
    }
  },
  "380": {
    "solution": {
      "randomized": "import java.util.*;\n\nclass RandomizedSet {\n    private List<Integer> nums;\n    private Map<Integer, Integer> pos;\n    private Random rand;\n\n    public RandomizedSet() {\n        nums = new ArrayList<>();\n        pos = new HashMap<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (pos.containsKey(val)) {\n            return false;\n        }\n        pos.put(val, nums.size());\n        nums.add(val);\n        return true;\n    }\n\n    public boolean remove(int val) {\n        if (!pos.containsKey(val)) {\n            return false;\n        }\n        int idx = pos.get(val);\n        int lastElement = nums.get(nums.size() - 1);\n        nums.set(idx, lastElement);\n        pos.put(lastElement, idx);\n        nums.remove(nums.size() - 1);\n        pos.remove(val);\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}\n/**\n * Your RandomizedSet object will be instantiated and called as such:\n * RandomizedSet obj = new RandomizedSet();\n * boolean param_1 = obj.insert(val);\n * boolean param_2 = obj.remove(val);\n * int param_3 = obj.getRandom();\n */"
    }
  },
  "381": {
    "solution": {
      "randomized": "import java.util.*;\n\nclass RandomizedCollection {\n    private List<Integer> nums;\n    private Map<Integer, Set<Integer>> pos;\n    private Random rand;\n\n    public RandomizedCollection() {\n        nums = new ArrayList<>();\n        pos = new HashMap<>();\n        rand = new Random();\n    }\n\n    public boolean insert(int val) {\n        if (!pos.containsKey(val)) {\n            pos.put(val, new HashSet<>());\n        }\n        pos.get(val).add(nums.size());\n        nums.add(val);\n        return pos.get(val).size() == 1;\n    }\n\n    public boolean remove(int val) {\n        if (!pos.containsKey(val) || pos.get(val).isEmpty()) {\n            return false;\n        }\n        int idxToRemove = pos.get(val).iterator().next();\n        pos.get(val).remove(idxToRemove);\n        int lastElement = nums.get(nums.size() - 1);\n        nums.set(idxToRemove, lastElement);\n        if (pos.get(lastElement) != null) {\n            pos.get(lastElement).add(idxToRemove);\n            pos.get(lastElement).remove(nums.size() - 1);\n        }\n        nums.remove(nums.size() - 1);\n        if (pos.get(val).isEmpty()) {\n            pos.remove(val);\n        }\n        return true;\n    }\n\n    public int getRandom() {\n        return nums.get(rand.nextInt(nums.size()));\n    }\n}\n"
    }
  },
  "382": {
    "solution": {
      "reservoir-sampling": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nimport java.util.Random;\n\npublic class Solution {\n    private ListNode head;\n    private Random rand;\n\n    public Solution(ListNode head) {\n        this.head = head;\n        this.rand = new Random();\n    }\n\n    /** Returns a random node's value. */\n    public int getRandom() {\n        ListNode current = head;\n        int reservoir = -1; \n        int count = 0;\n\n        while (current != null) {\n            count++;\n            // With probability 1/count, select the current node's value\n            if (rand.nextInt(count) == 0) {\n                reservoir = current.val;\n            }\n            current = current.next;\n        }\n\n        return reservoir;\n    }\n}\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(head);\n * int param_1 = obj.getRandom();\n */"
    }
  },
  "383": {
    "solution": {
      "counting": "class Solution {\n    public boolean canConstruct(String ransomNote, String magazine) {\n        int[] count = new int[26];\n\n        for (char c : magazine.toCharArray()) {\n            count[c - 'a']++;\n        }\n\n        for (char c : ransomNote.toCharArray()) {\n            if (count[c - 'a'] == 0) {\n                return false;\n            }\n            count[c - 'a']--;\n        }\n\n        return true;\n    }\n}"
    }
  },
  "384": {
    "solution": {
      "randomized": "import java.util.Random;\n\nclass Solution {\n    private int[] original;\n    private int[] array;\n    private Random rand;\n\n    public Solution(int[] nums) {\n        original = nums.clone();\n        array = nums.clone();\n        rand = new Random();\n    }\n\n    public int[] reset() {\n        array = original.clone();\n        return array;\n    }\n\n    public int[] shuffle() {\n        for (int i = 0; i < array.length; i++) {\n            int swapIdx = i + rand.nextInt(array.length - i);\n            int temp = array[i];\n            array[i] = array[swapIdx];\n            array[swapIdx] = temp;\n        }\n        return array;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int[] param_1 = obj.reset();\n * int[] param_2 = obj.shuffle();\n */"
    }
  },
  "385": {
    "solution": {
      "stack": "/**\n * // This is the interface that allows for creating nested lists.\n * // You should not implement it, or speculate about its implementation\n * public interface NestedInteger {\n *     // Constructor initializes an empty nested list.\n *     public NestedInteger();\n *\n *     // Constructor initializes a single integer.\n *     public NestedInteger(int value);\n *\n *     // @return true if this NestedInteger holds a single integer, rather than a nested list.\n *     public boolean isInteger();\n *\n *     // @return the single integer that this NestedInteger holds, if it holds a single integer\n *     // Return null if this NestedInteger holds a nested list\n *     public Integer getInteger();\n *\n *     // Set this NestedInteger to hold a single integer.\n *     public void setInteger(int value);\n *\n *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.\n *     public void add(NestedInteger ni);\n *\n *     // @return the nested list that this NestedInteger holds, if it holds a nested list\n *     // Return empty list if this NestedInteger holds a single integer\n *     public List<NestedInteger> getList();\n * }\n */\nclass Solution {\n    public NestedInteger deserialize(String s) {\n        if (s.isEmpty()) return null;\n        if (s.charAt(0) != '[') return new NestedInteger(Integer.parseInt(s)); // Single integer case\n\n        Stack<NestedInteger> stack = new Stack<>();\n        NestedInteger current = null;\n        int num = 0;\n        boolean negative = false;\n        boolean numStarted = false;\n\n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n\n            if (c == '[') {\n                if (current != null) {\n                    stack.push(current);\n                }\n                current = new NestedInteger();\n            } else if (c == '-') {\n                negative = true;\n            } else if (Character.isDigit(c)) {\n                num = num * 10 + (c - '0');\n                numStarted = true;\n            } else if (c == ',' || c == ']') {\n                if (numStarted) {\n                    current.add(new NestedInteger(negative ? -num : num));\n                    num = 0;\n                    negative = false;\n                    numStarted = false;\n                }\n                if (c == ']' && !stack.isEmpty()) {\n                    NestedInteger parent = stack.pop();\n                    parent.add(current);\n                    current = parent;\n                }\n            }\n        }\n        return current;\n    }\n}"
    }
  },
  "386": {
    "solution": {
      "trie": "class Solution {\n    public List<Integer> lexicalOrder(int n) {\n        List<Integer> result = new ArrayList<>(n);\n        int current = 1;\n        \n        for (int i = 0; i < n; i++) {\n            result.add(current);\n            if (current * 10 <= n) {\n                current *= 10;  // Go to next lexicographical level\n            } else {\n                while (current % 10 == 9 || current + 1 > n) {\n                    current /= 10;  // Backtrack\n                }\n                current++;  // Move to next number\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "387": {
    "solution": {
      "queue": "import java.util.HashMap;\n\npublic class Solution {\n    public int firstUniqChar(String s) {\n        HashMap<Character, Integer> count = new HashMap<>();\n        int n = s.length();\n\n        for (int i = 0; i < n; i++) {\n            char c = s.charAt(i);\n            count.put(c, count.getOrDefault(c, 0) + 1);\n        }\n\n        for (int i = 0; i < n; i++) {\n            if (count.get(s.charAt(i)) == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}\n"
    }
  },
  "388": {
    "solution": {
      "stack": "import java.util.HashMap;\n\npublic class Solution {\n    public int lengthLongestPath(String input) {\n        HashMap<Integer, Integer> pathLengths = new HashMap<>();\n        pathLengths.put(0, 0); \n        int maxLength = 0;\n\n        for (String part : input.split(\"\\n\")) {\n            int level = part.lastIndexOf('\t') + 1; \n            int len = part.length() - level; \n\n            if (part.contains(\".\")) { \n                maxLength = Math.max(maxLength, pathLengths.get(level) + len);\n            } else { \n                pathLengths.put(level + 1, pathLengths.get(level) + len + 1);\n            }\n        }\n\n        return maxLength;\n    }\n\n}\n"
    }
  },
  "389": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public char findTheDifference(String s, String t) {\n        int result = 0;\n        for (char c : s.toCharArray()) {\n            result ^= c;\n        }\n        for (char c : t.toCharArray()) {\n            result ^= c;\n        }\n        return (char) result;\n    }\n}"
    }
  },
  "390": {
    "solution": {
      "recursion": "class Solution {\n    public int lastRemaining(int n) {\n        return helper(n, true);\n    }\n\n    private int helper(int n, boolean leftToRight) {\n        if (n == 1) return 1;\n        if (leftToRight || n % 2 == 1) {\n            return 2 * helper(n / 2, false);\n        } else {\n            return 2 * helper(n / 2, true) - 1;\n        }\n    }\n}"
    }
  },
  "391": {
    "solution": {
      "line-sweep": "import java.util.*;\n\nclass Solution {\n    public boolean isRectangleCover(int[][] rectangles) {\n        int area = 0;\n        int x1 = Integer.MAX_VALUE;\n        int y1 = Integer.MAX_VALUE;\n        int x2 = Integer.MIN_VALUE;\n        int y2 = Integer.MIN_VALUE;\n\n        Set<String> corners = new HashSet<>();\n\n        for (int[] rect : rectangles) {\n            x1 = Math.min(x1, rect[0]);\n            y1 = Math.min(y1, rect[1]);\n            x2 = Math.max(x2, rect[2]);\n            y2 = Math.max(y2, rect[3]);\n\n            area += (rect[2] - rect[0]) * (rect[3] - rect[1]);\n\n            String[] cornerPoints = {\n                rect[0] + ' ' + rect[1], rect[0] + ' ' + rect[3],\n                rect[2] + ' ' + rect[1], rect[2] + ' ' + rect[3]\n            };\n\n            for (String point : cornerPoints) {\n                if (!corners.add(point)) {\n                    corners.remove(point);\n                }\n            }\n        }\n\n        if (!corners.contains(x1 + ' ' + y1) ||\n            !corners.contains(x1 + ' ' + y2) ||\n            !corners.contains(x2 + ' ' + y1) ||\n            !corners.contains(x2 + ' ' + y2) ||\n            corners.size() != 4) {\n            return false;\n        }\n\n        return area == (x2 - x1) * (y2 - y1);\n    }\n}\n"
    }
  },
  "392": {
    "solution": {
      "two-pointers": "class Solution {\n    public boolean isSubsequence(String s, String t) {\n        int i = 0, j = 0;\n        while (i < s.length() && j < t.length()) {\n            if (s.charAt(i) == t.charAt(j)) {\n                i++;\n            }\n            j++;\n        }\n        return i == s.length();\n    }\n}"
    }
  },
  "393": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public boolean validUtf8(int[] data) {\n        int remainingBytes = 0; // Number of expected continuation bytes\n        \n        for (int byteValue : data) {\n            if (remainingBytes == 0) {\n                // Determine the number of bytes in the current character\n                if ((byteValue >> 7) == 0b0) { // 1-byte character (0xxxxxxx)\n                    remainingBytes = 0;\n                } else if ((byteValue >> 5) == 0b110) { // 2-byte character (110xxxxx)\n                    remainingBytes = 1;\n                } else if ((byteValue >> 4) == 0b1110) { // 3-byte character (1110xxxx)\n                    remainingBytes = 2;\n                } else if ((byteValue >> 3) == 0b11110) { // 4-byte character (11110xxx)\n                    remainingBytes = 3;\n                } else {\n                    return false; // Invalid start byte\n                }\n            } else {\n                // Check if the byte is a valid continuation byte (10xxxxxx)\n                if ((byteValue >> 6) != 0b10) {\n                    return false;\n                }\n                remainingBytes--;\n            }\n        }\n        \n        return remainingBytes == 0; // Ensure no missing continuation bytes\n    }\n}"
    }
  },
  "394": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public String decodeString(String s) {\n        Stack<Integer> countStack = new Stack<>();  // Stores repetition counts\n        Stack<StringBuilder> stringStack = new Stack<>();  // Stores previous substrings\n        StringBuilder currentStr = new StringBuilder();\n        int num = 0;  // Stores current number\n        \n        for (char ch : s.toCharArray()) {\n            if (Character.isDigit(ch)) {\n                num = num * 10 + (ch - '0');  // Build the full number\n            } else if (ch == '[') {\n                countStack.push(num);  // Push repetition count\n                stringStack.push(currentStr);  // Save current state\n                currentStr = new StringBuilder();  // Start new substring\n                num = 0;  // Reset number\n            } else if (ch == ']') {\n                int count = countStack.pop();  // Get repeat count\n                StringBuilder decodedStr = stringStack.pop();  // Get previous string\n                while (count-- > 0) {\n                    decodedStr.append(currentStr);  // Repeat the current string\n                }\n                currentStr = decodedStr;  // Update current string\n            } else {\n                currentStr.append(ch);  // Append normal characters\n            }\n        }\n        \n        return currentStr.toString();\n    }\n}"
    }
  },
  "395": {
    "solution": {
      "sliding-window": "import java.util.HashMap;\n\npublic class Solution {\n    public int longestSubstring(String s, int k) {\n        int maxLength = 0;\n        \n        for (int uniqueCount = 1; uniqueCount <= 26; uniqueCount++) {\n            maxLength = Math.max(maxLength, longestSubstringWithNUniqueChars(s, k, uniqueCount));\n        }\n        \n        return maxLength;\n    }\n\n    private int longestSubstringWithNUniqueChars(String s, int k, int uniqueTarget) {\n        HashMap<Character, Integer> freqMap = new HashMap<>();\n        int left = 0, right = 0, maxLength = 0;\n        int uniqueChars = 0, countAtLeastack = 0;\n\n        while (right < s.length()) {\n            char rightChar = s.charAt(right);\n            freqMap.put(rightChar, freqMap.getOrDefault(rightChar, 0) + 1);\n            if (freqMap.get(rightChar) == 1) uniqueChars++;\n            if (freqMap.get(rightChar) == k) countAtLeastack++;\n            right++;\n\n            while (uniqueChars > uniqueTarget) {\n                char leftChar = s.charAt(left);\n                if (freqMap.get(leftChar) == k) countAtLeastack--;\n                freqMap.put(leftChar, freqMap.get(leftChar) - 1);\n                if (freqMap.get(leftChar) == 0) uniqueChars--;\n                left++;\n            }\n\n            if (uniqueChars == uniqueTarget && uniqueChars == countAtLeastack) {\n                maxLength = Math.max(maxLength, right - left);\n            }\n        }\n\n        return maxLength;\n    }\n\n}\n"
    }
  },
  "396": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int maxRotateFunction(int[] nums) {\n        int n = nums.length;\n        int sumNums = 0, currentF = 0;\n        \n        // Compute initial F(0) and sum(nums)\n        for (int i = 0; i < n; i++) {\n            sumNums += nums[i];\n            currentF += i * nums[i];\n        }\n        \n        int maxF = currentF;\n        \n        // Compute F(k) from F(k-1)\n        for (int k = 1; k < n; k++) {\n            currentF = currentF + sumNums - n * nums[n - k];\n            maxF = Math.max(maxF, currentF);\n        }\n        \n        return maxF;\n    }\n}"
    }
  },
  "397": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int integerReplacement(int n) {\n        int steps = 0;\n        long num = n; // Use long to handle Integer.MAX_VALUE\n\n        while (num > 1) {\n            if ((num & 1) == 0) { // Even case\n                num >>= 1;\n            } else if (num == 3 || (num & 2) == 0) { // Prefer decrement for n=3 or when (n+1) creates more 1s\n                num--;\n            } else {\n                num++;\n            }\n            steps++;\n        }\n\n        return steps;\n    }\n}"
    }
  },
  "398": {
    "solution": {
      "reservoir-sampling": "public class Solution {\n    private int[] nums;\n    private Random rand;\n\n    public Solution(int[] nums) {\n        this.nums = nums;\n        this.rand = new Random();\n    }\n\n    public int pick(int target) {\n        int count = 0;\n        int result = -1; // Variable to store the chosen index\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == target) {\n                count++;\n                // With probability 1/count, select the current index\n                if (rand.nextInt(count) == 0) {\n                    result = i;\n                }\n            }\n        }\n\n        return result;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(nums);\n * int param_1 = obj.pick(target);\n */"
    }
  },
  "399": {
    "solution": {
      "union-find": "class Solution {\n    public double[] calcEquation(List<List<String>> equations, double[] values, List<List<String>> queries) {\n        Map<String, Map<String, Double>> graph = new HashMap<>();\n        \n        // Step 1: Build the graph\n        for (int i = 0; i < equations.size(); i++) {\n            String numerator = equations.get(i).get(0);\n            String denominator = equations.get(i).get(1);\n            double value = values[i];\n\n            graph.putIfAbsent(numerator, new HashMap<>());\n            graph.putIfAbsent(denominator, new HashMap<>());\n            graph.get(numerator).put(denominator, value);\n            graph.get(denominator).put(numerator, 1.0 / value);\n        }\n\n        // Step 2: Process each query using DFS\n        double[] result = new double[queries.size()];\n        for (int i = 0; i < queries.size(); i++) {\n            String start = queries.get(i).get(0);\n            String end = queries.get(i).get(1);\n            if (!graph.containsKey(start) || !graph.containsKey(end)) {\n                result[i] = -1.0; // If either variable does not exist in graph\n            } else {\n                result[i] = dfs(graph, start, end, new HashSet<>());\n            }\n        }\n\n        return result;\n    }\n\n    private double dfs(Map<String, Map<String, Double>> graph, String current, String target, Set<String> visited) {\n        if (current.equals(target)) return 1.0; // Found the target\n        if (visited.contains(current)) return -1.0; // Avoid cycles\n        visited.add(current);\n        \n        for (Map.Entry<String, Double> neighbor : graph.get(current).entrySet()) {\n            double product = dfs(graph, neighbor.getKey(), target, visited);\n            if (product != -1.0) return product * neighbor.getValue();\n        }\n        \n        return -1.0; // No valid path found\n    }\n}"
    }
  },
  "400": {
    "solution": {
      "math": "class Solution {\n    public int findNthDigit(int n) {\n        long digitLength = 1;\n        long count = 9;\n        long start = 1;\n\n        while (n > digitLength * count) {\n            n -= digitLength * count;\n            digitLength++;\n            count *= 10;\n            start *= 10;\n        }\n\n        long targetNumber = start + (n - 1) / digitLength;\n        String targetStr = Long.toString(targetNumber);\n        int digitIndex = (n - 1) % (int)digitLength;\n\n        return targetStr.charAt(digitIndex) - '0';\n    }\n}"
    }
  },
  "401": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<String> readBinaryWatch(int turnedOn) {\n        List<String> result = new ArrayList<>();\n\n        for (int hour = 0; hour < 12; hour++) {\n            for (int minute = 0; minute < 60; minute++) {\n                if (Integer.bitCount(hour) + Integer.bitCount(minute) == turnedOn) {\n                    result.add(String.format(\"%d:%02d\", hour, minute));\n                }\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "402": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public String removeKdigits(String num, int k) {\n        if (k == num.length()) {\n            return \"0\";\n        }\n\n        Stack<Character> stack = new Stack<>();\n\n        for (char digit : num.toCharArray()) {\n            while (!stack.isEmpty() && k > 0 && stack.peek() > digit) {\n                stack.pop();\n                k--;\n            }\n            stack.push(digit);\n        }\n\n        while (k > 0) {\n            stack.pop();\n            k--;\n        }\n\n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.append(stack.pop());\n        }\n\n        result.reverse();\n        while (result.length() > 1 && result.charAt(0) == '0') {\n            result.deleteCharAt(0);\n        }\n\n        return result.toString();\n    }\n}\n"
    }
  },
  "403": {
    "solution": {
      "dynamic-programming": "class Solution {\n public:\n  bool canCross(vector<int>& stones) {\n    const int n = stones.size();\n    // dp[i][j] := true if a frog can make a size j jump to stones[i]\n    vector<vector<bool>> dp(n, vector<bool>(n + 1));\n    dp[0][0] = true;\n\n    for (int i = 1; i < n; ++i)\n      for (int j = 0; j < i; ++j) {\n        const int k = stones[i] - stones[j];\n        if (k > n)\n          continue;\n        for (const int x : {k - 1, k, k + 1})\n          if (0 <= x && x <= n)\n            dp[i][k] = dp[i][k] || dp[j][x];\n      }\n\n    return ranges::any_of(dp.back(), [](bool val) { return val; });\n  }\n};"
    }
  },
  "404": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int sumOfLeftLeaves(TreeNode root) {\n        if (root == null) return 0;\n\n        int sum = 0;\n        if (root.left != null && root.left.left == null && root.left.right == null) {\n            sum += root.left.val;\n        }\n\n        sum += sumOfLeftLeaves(root.left);\n        sum += sumOfLeftLeaves(root.right);\n        return sum;\n    }\n}\n\n// TreeNode class assumed to be:\n// public class TreeNode {\n//     int val;\n//     TreeNode left;\n//     TreeNode right;\n//     TreeNode() {}\n//     TreeNode(int val) { this.val = val; }\n//     TreeNode(int val, TreeNode left, TreeNode right) {\n//         this.val = val;\n//         this.left = left;\n//         this.right = right;\n//     }\n// }"
    }
  },
  "405": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public String toHex(int num) {\n        if (num == 0) return \"0\";\n\n        StringBuilder hex = new StringBuilder();\n        char[] hexMap = \"0123456789abcdef\".toCharArray();\n\n        while (num != 0 && hex.length() < 8) { // Process up to 8 hex digits\n            hex.append(hexMap[num & 15]);  // Get last 4 bits as hex\n            num >>>= 4;  // Unsigned right shift\n        }\n\n        return hex.reverse().toString();\n    }\n}"
    }
  },
  "406": {
    "solution": {
      "sorting": "class Solution {\n  public int[][] reconstructQueue(int[][] people) {\n    List<int[]> ans = new ArrayList<>();\n\n    Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);\n\n    for (final int[] p : people)\n      ans.add(p[1], p);\n\n    return ans.toArray(new int[ans.size()][]);\n  }\n}"
    }
  },
  "407": {
    "solution": {
      "priority_queue": "import java.util.PriorityQueue;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int trapRainWater(int[][] heightMap) {\n        if (heightMap == null || heightMap.length == 0 || heightMap[0].length == 0) {\n            return 0;\n        }\n        \n        int m = heightMap.length, n = heightMap[0].length;\n        boolean[][] visited = new boolean[m][n];\n        PriorityQueue<int[]> pq = new PriorityQueue<>((a, b) -> a[2] - b[2]);\n        \n        for (int i = 0; i < m; i++) {\n            pq.offer(new int[]{i, 0, heightMap[i][0]});\n            pq.offer(new int[]{i, n - 1, heightMap[i][n - 1]});\n            visited[i][0] = visited[i][n - 1] = true;\n        }\n        \n        for (int j = 1; j < n - 1; j++) {\n            pq.offer(new int[]{0, j, heightMap[0][j]});\n            pq.offer(new int[]{m - 1, j, heightMap[m - 1][j]});\n            visited[0][j] = visited[m - 1][j] = true;\n        }\n        \n        int water = 0;\n        while (!pq.isEmpty()) {\n            int[] cell = pq.poll();\n            int x = cell[0], y = cell[1], h = cell[2];\n            \n            for (int[] dir : DIRECTIONS) {\n                int nx = x + dir[0], ny = y + dir[1];\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {\n                    visited[nx][ny] = true;\n                    water += Math.max(0, h - heightMap[nx][ny]);\n                    pq.offer(new int[]{nx, ny, Math.max(h, heightMap[nx][ny])});\n                }\n            }\n        }\n        \n        return water;\n    }\n}"
    }
  },
  "408": {
    "solution": {
      "two-pointers": "class Solution {\n    public boolean validWordAbbreviation(String word, String abbreviation) {\n        int wordLength = word.length(), abbrLength = abbreviation.length();\n        int wordIndex = 0, abbrIndex = 0, numValue = 0;\n\n        for (; wordIndex < wordLength && abbrIndex < abbrLength; ++abbrIndex) {\n            char currentChar = abbreviation.charAt(abbrIndex);\n\n            if (Character.isDigit(currentChar)) {\n                if (currentChar == '0' && numValue == 0) {\n                    return false; // Leading zeros are not allowed in abbreviations\n                }\n                numValue = numValue * 10 + (currentChar - '0');\n            } else {\n                wordIndex += numValue;\n                numValue = 0;\n                if (wordIndex >= wordLength || word.charAt(wordIndex) != currentChar) {\n                    return false;\n                }\n                ++wordIndex;\n            }\n        }\n        return wordIndex + numValue == wordLength && abbrIndex == abbrLength;\n    }\n}"
    }
  },
  "409": {
    "solution": {
      "greedy": "class Solution {\n    public int longestPalindrome(String s) {\n        int[] charCount = new int[128]; // Covers all ASCII characters\n        int palindromeLength = 0;\n\n        for (char ch : s.toCharArray()) {\n            charCount[ch]++;\n            if (charCount[ch] % 2 == 0) {\n                palindromeLength += 2;\n            }\n        }\n\n        return palindromeLength + (palindromeLength < s.length() ? 1 : 0);\n    }\n}"
    }
  },
  "410": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int splitArray(int[] nums, int m) {\n        int left = 0, right = 0;\n\n        for (int num : nums) {\n            left = Math.max(left, num); // The largest single element\n            right += num; // The sum of all elements\n        }\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (canSplit(nums, m, mid)) {\n                right = mid; // Try for a smaller maximum subarray sum\n            } else {\n                left = mid + 1; // Increase the allowed sum\n            }\n        }\n        return left;\n    }\n\n    private boolean canSplit(int[] nums, int m, int maxSum) {\n        int subarrays = 1, currentSum = 0;\n\n        for (int num : nums) {\n            if (currentSum + num > maxSum) {\n                subarrays++;\n                currentSum = num;\n                if (subarrays > m) return false;\n            } else {\n                currentSum += num;\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "411": {
    "solution": {
      "backtracking": "class Solution {\n    public String minAbbreviation(String target, String[] dictionary) {\n        int length = target.length();\n        int totalCount = 1 << length;\n        String minAbbr = target;\n        int minLength = length;\n        for (int i = totalCount; i > 0; i--) {\n            String abbr = generateAbbreviation(target, i);\n            if (abbr.length() > minLength)\n                continue;\n            boolean flag = true;\n            for (String word : dictionary) {\n                if (word.length() == length) {\n                    String abbr2 = generateAbbreviation(word, i);\n                    if (abbr2.equals(abbr)) {\n                        flag = false;\n                        break;\n                    }\n                }\n            }\n            if (flag) {\n                if (abbr.length() < minLength) {\n                    minAbbr = abbr;\n                    minLength = abbr.length();\n                }\n            }\n        }\n        return minAbbr;\n    }\n\n    public String generateAbbreviation(String word, int num) {\n        StringBuffer sb = new StringBuffer();\n        int consecutiveCount = 0;\n        int length = word.length();\n        for (int i = 0; i < length; i++) {\n            int cur = num & 1;\n            if (cur == 1)\n                consecutiveCount++;\n            else {\n                if (consecutiveCount > 0) {\n                    sb.append(consecutiveCount);\n                    consecutiveCount = 0;\n                }\n                sb.append(word.charAt(i));\n            }\n            num >>= 1;\n        }\n        if (consecutiveCount > 0)\n            sb.append(consecutiveCount);\n        return sb.toString();\n    }\n}"
    }
  },
  "412": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public List<String> fizzBuzz(int n) {\n        List<String> result = new ArrayList<>();\n\n        for (int i = 1; i <= n; i++) {\n            if (i % 3 == 0 && i % 5 == 0) {\n                result.add(\"FizzBuzz\");\n            } else if (i % 3 == 0) {\n                result.add(\"Fizz\");\n            } else if (i % 5 == 0) {\n                result.add(\"Buzz\");\n            } else {\n                result.add(String.valueOf(i));\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "413": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        if (nums.length < 3) return 0;\n\n        int totalSlices = 0;\n        int currentSlices = 0; // dp[i], number of slices ending at index i\n\n        for (int i = 2; i < nums.length; i++) {\n            if (nums[i] - nums[i - 1] == nums[i - 1] - nums[i - 2]) {\n                currentSlices += 1;  // Extend the previous slices\n                totalSlices += currentSlices;  // Add to the result\n            } else {\n                currentSlices = 0; // Reset count if the sequence is broken\n            }\n        }\n        return totalSlices;\n    }\n}"
    }
  },
  "414": {
    "solution": {
      "sorting": "class Solution {\n    public int thirdMax(int[] nums) {\n        Long first = null, second = null, third = null;\n\n        for (int num : nums) {\n            long n = (long) num;\n            if (n == first || n == second || n == third) continue;\n\n            if (first == null || n > first) {\n                third = second;\n                second = first;\n                first = n;\n            } else if (second == null || n > second) {\n                third = second;\n                second = n;\n            } else if (third == null || n > third) {\n                third = n;\n            }\n        }\n\n        return third == null ? first.intValue() : third.intValue();\n    }\n}"
    }
  },
  "415": {
    "solution": {
      "string": "class Solution {\n    public String addStrings(String num1, String num2) {\n        StringBuilder result = new StringBuilder();\n        int i = num1.length() - 1, j = num2.length() - 1, carry = 0;\n\n        while (i >= 0 || j >= 0 || carry > 0) {\n            int digit1 = (i >= 0) ? num1.charAt(i--) - '0' : 0;\n            int digit2 = (j >= 0) ? num2.charAt(j--) - '0' : 0;\n            int sum = digit1 + digit2 + carry;\n            result.append(sum % 10);\n            carry = sum / 10;\n        }\n\n        return result.reverse().toString();\n    }\n}"
    }
  },
  "416": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public boolean canPartition(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        // If the total sum is odd, we cannot split it into equal subsets\n        if (totalSum % 2 != 0) return false;\n\n        int target = totalSum / 2;\n        boolean[] dp = new boolean[target + 1];\n        dp[0] = true; // Base case: a subset with sum 0 is always possible\n\n        for (int num : nums) {\n            for (int sum = target; sum >= num; sum--) {\n                dp[sum] = dp[sum] || dp[sum - num];\n            }\n        }\n\n        return dp[target];\n    }\n}"
    }
  },
  "417": {
    "solution": {
      "matrix": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> pacificAtlantic(int[][] heights) {\n        int rows = heights.length, cols = heights[0].length;\n        boolean[][] pacific = new boolean[rows][cols];\n        boolean[][] atlantic = new boolean[rows][cols];\n        List<List<Integer>> result = new ArrayList<>();\n\n        // Start DFS from the first and last rows (Pacific and Atlantic)\n        for (int col = 0; col < cols; col++) {\n            dfs(heights, 0, col, Integer.MIN_VALUE, pacific);\n            dfs(heights, rows - 1, col, Integer.MIN_VALUE, atlantic);\n        }\n\n        // Start DFS from the first and last columns (Pacific and Atlantic)\n        for (int row = 0; row < rows; row++) {\n            dfs(heights, row, 0, Integer.MIN_VALUE, pacific);\n            dfs(heights, row, cols - 1, Integer.MIN_VALUE, atlantic);\n        }\n\n        // Find intersection points (cells that can reach both oceans)\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (pacific[r][c] && atlantic[r][c]) {\n                    result.add(Arrays.asList(r, c));\n                }\n            }\n        }\n        return result;\n    }\n\n    private void dfs(int[][] heights, int r, int c, int prevHeight, boolean[][] visited) {\n        int rows = heights.length, cols = heights[0].length;\n\n        // Boundary checks and water flow condition\n        if (r < 0 || c < 0 || r >= rows || c >= cols || visited[r][c] || heights[r][c] < prevHeight) {\n            return;\n        }\n\n        // Mark as visited\n        visited[r][c] = true;\n\n        // DFS traversal in 4 directions\n        dfs(heights, r + 1, c, heights[r][c], visited); // Down\n        dfs(heights, r - 1, c, heights[r][c], visited); // Up\n        dfs(heights, r, c + 1, heights[r][c], visited); // Right\n        dfs(heights, r, c - 1, heights[r][c], visited); // Left\n    }\n}"
    }
  },
  "418": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int wordsTyping(String[] sentence, int rows, int cols) {\n        String combinedSentence = String.join(\" \", sentence) + \" \";\n        int sentenceLength = combinedSentence.length();\n        int position = 0;\n        \n        while (rows-- > 0) {\n            position += cols;\n            \n            if (combinedSentence.charAt(position % sentenceLength) == ' ') {\n                position++;\n            } else {\n                while (position > 0 && combinedSentence.charAt((position - 1) % sentenceLength) != ' ') {\n                    position--;\n                }\n            }\n        }\n        \n        return position / sentenceLength;\n    }\n}"
    }
  },
  "419": {
    "solution": {
      "matrix": "class Solution {\n    public int countBattleships(char[][] board) {\n        int rows = board.length, cols = board[0].length;\n        int battleships = 0;\n        \n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                // A battleship is only counted if it's the top-left part of a new ship\n                if (board[r][c] == 'X' \n                    && (r == 0 || board[r - 1][c] != 'X') \n                    && (c == 0 || board[r][c - 1] != 'X')) {\n                    battleships++;\n                }\n            }\n        }\n        \n        return battleships;\n    }\n}"
    }
  },
  "420": {
    "solution": {
      "strong-password-checker": "class Solution {\n    public int strongPasswordChecker(String password) {\n        int length = password.length();\n        boolean hasLower = false, hasUpper = false, hasDigit = false;\n        \n        char[] chars = password.toCharArray();\n        \n        int replaceCount = 0;\n        int oneMod = 0, twoMod = 0;\n\n        for (int i = 0; i < length; i++) {\n            char currentChar = chars[i];\n            if (Character.isLowerCase(currentChar)) hasLower = true;\n            if (Character.isUpperCase(currentChar)) hasUpper = true;\n            if (Character.isDigit(currentChar)) hasDigit = true;\n\n            int sequenceLength = 1;\n            while (i + 1 < length && chars[i] == chars[i + 1]) {\n                sequenceLength++;\n                i++;\n            }\n            \n            if (sequenceLength >= 3) {\n                replaceCount += sequenceLength / 3;\n                if (sequenceLength % 3 == 0) oneMod++;\n                else if (sequenceLength % 3 == 1) twoMod++;\n            }\n        }\n\n        int missingTypes = (hasLower ? 0 : 1) + (hasUpper ? 0 : 1) + (hasDigit ? 0 : 1);\n\n        if (length < 6) {\n            return Math.max(6 - length, missingTypes);\n        }\n\n        if (length <= 20) {\n            return Math.max(replaceCount, missingTypes);\n        }\n\n        int excessChars = length - 20;\n        int reduce = excessChars;\n\n        if (reduce > 0) {\n            int minReduce = Math.min(reduce, oneMod);\n            replaceCount -= minReduce;\n            reduce -= minReduce;\n        }\n\n        if (reduce > 0) {\n            int minReduce = Math.min(reduce, twoMod * 2) / 2;\n            replaceCount -= minReduce;\n            reduce -= minReduce * 2;\n        }\n\n        if (reduce > 0) {\n            int minReduce = Math.min(reduce, replaceCount * 3) / 3;\n            replaceCount -= minReduce;\n            reduce -= minReduce * 3;\n        }\n\n        return excessChars + Math.max(replaceCount, missingTypes);\n    }\n}"
    }
  },
  "421": {
    "solution": {
      "bit-manipulation": "import java.util.HashSet;\n\nclass Solution {\n    public int findMaximumXOR(int[] nums) {\n        int maxXor = 0, mask = 0;\n        \n        for (int i = 31; i >= 0; i--) {\n            mask |= (1 << i);\n            HashSet<Integer> prefixes = new HashSet<>();\n            \n            for (int num : nums) {\n                prefixes.add(num & mask);\n            }\n            \n            int potentialMax = maxXor | (1 << i);\n            \n            for (int prefix : prefixes) {\n                if (prefixes.contains(prefix ^ potentialMax)) {\n                    maxXor = potentialMax;\n                    break;\n                }\n            }\n        }\n        \n        return maxXor;\n    }\n}"
    }
  },
  "422": {
    "solution": {
      "matrix": "class Solution {\n    public boolean validWordSquare(List<String> words) {\n        int m = words.size();\n        for (int i = 0; i < m; ++i) {\n            int n = words.get(i).length();\n            for (int j = 0; j < n; ++j) {\n                if (j >= m || i >= words.get(j).length()) {\n                    return false;\n                }\n                if (words.get(i).charAt(j) != words.get(j).charAt(i)) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "423": {
    "solution": {
      "hashmap": "class Solution {\n  public String originalDigits(String s) {\n    StringBuilder sb = new StringBuilder();\n    int[] count = new int[10];\n\n    for (final char c : s.toCharArray()) {\n      if (c == 'z')\n        ++count[0];\n      if (c == 'o')\n        ++count[1];\n      if (c == 'w')\n        ++count[2];\n      if (c == 'h')\n        ++count[3];\n      if (c == 'u')\n        ++count[4];\n      if (c == 'f')\n        ++count[5];\n      if (c == 'x')\n        ++count[6];\n      if (c == 's')\n        ++count[7];\n      if (c == 'g')\n        ++count[8];\n      if (c == 'i')\n        ++count[9];\n    }\n\n    count[1] -= count[0] + count[2] + count[4];\n    count[3] -= count[8];\n    count[5] -= count[4];\n    count[7] -= count[6];\n    count[9] -= count[5] + count[6] + count[8];\n\n    for (int i = 0; i < 10; ++i)\n      for (int j = 0; j < count[i]; ++j)\n        sb.append(i);\n\n    return sb.toString();\n  }\n}"
    }
  },
  "424": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int characterReplacement(String s, int k) {\n        int[] count = new int[26];\n        int maxCount = 0, left = 0, maxLength = 0;\n\n        for (int right = 0; right < s.length(); right++) {\n            char rightChar = s.charAt(right);\n            count[rightChar - 'A']++;\n            maxCount = Math.max(maxCount, count[rightChar - 'A']);\n\n            while (right - left + 1 - maxCount > k) {\n                char leftChar = s.charAt(left);\n                count[leftChar - 'A']--;\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return maxLength;\n    }\n}\n"
    }
  },
  "425": {
    "solution": {
      "backtracking": "class Trie {\n    Trie[] children = new Trie[26];\n    List<Integer> v = new ArrayList<>();\n\n    void insert(String word, int i) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                node.children[c] = new Trie();\n            }\n            node = node.children[c];\n            node.v.add(i);\n        }\n    }\n\n    List<Integer> search(String pref) {\n        Trie node = this;\n        for (char c : pref.toCharArray()) {\n            c -= 'a';\n            if (node.children[c] == null) {\n                return Collections.emptyList();\n            }\n            node = node.children[c];\n        }\n        return node.v;\n    }\n}\n\nclass Solution {\n    private Trie trie = new Trie();\n    private String[] words;\n    private List<List<String>> ans = new ArrayList<>();\n\n    public List<List<String>> wordSquares(String[] words) {\n        this.words = words;\n        for (int i = 0; i < words.length; ++i) {\n            trie.insert(words[i], i);\n        }\n\n        List<String> t = new ArrayList<>();\n        for (String w : words) {\n            t.add(w);\n            dfs(t);\n            t.remove(t.size() - 1);\n        }\n        return ans;\n    }\n\n    private void dfs(List<String> t) {\n        if (t.size() == words[0].length()) {\n            ans.add(new ArrayList<>(t));\n            return;\n        }\n        int idx = t.size();\n        StringBuilder pref = new StringBuilder();\n        for (String x : t) {\n            pref.append(x.charAt(idx));\n        }\n        List<Integer> indexes = trie.search(pref.toString());\n        for (int i : indexes) {\n            t.add(words[i]);\n            dfs(t);\n            t.remove(t.size() - 1);\n        }\n    }\n}"
    }
  },
  "426": {
    "solution": {
      "doubly-linked-list": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public Node left;\n    public Node right;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val,Node _left,Node _right) {\n        val = _val;\n        left = _left;\n        right = _right;\n    }\n};\n*/\n\nclass Solution {\n    private Node prev;\n    private Node head;\n\n    public Node treeToDoublyList(Node root) {\n        if (root == null) {\n            return null;\n        }\n        prev = null;\n        head = null;\n        dfs(root);\n        prev.right = head;\n        head.left = prev;\n        return head;\n    }\n\n    private void dfs(Node root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        if (prev != null) {\n            prev.right = root;\n            root.left = prev;\n        } else {\n            head = root;\n        }\n        prev = root;\n        dfs(root.right);\n    }\n}"
    }
  },
  "427": {
    "solution": {
      "matrix": "/*\n// Definition for a QuadTree node.\nclass Node {\n    public boolean val;\n    public boolean isLeaf;\n    public Node topLeft;\n    public Node topRight;\n    public Node bottomLeft;\n    public Node bottomRight;\n\n    public Node() {\n        this.val = false;\n        this.isLeaf = false;\n        this.topLeft = null;\n        this.topRight = null;\n        this.bottomLeft = null;\n        this.bottomRight = null;\n    }\n\n    public Node(boolean val, boolean isLeaf) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = null;\n        this.topRight = null;\n        this.bottomLeft = null;\n        this.bottomRight = null;\n    }\n\n    public Node(boolean val, boolean isLeaf, Node topLeft, Node topRight, Node bottomLeft, Node bottomRight) {\n        this.val = val;\n        this.isLeaf = isLeaf;\n        this.topLeft = topLeft;\n        this.topRight = topRight;\n        this.bottomLeft = bottomLeft;\n        this.bottomRight = bottomRight;\n    }\n}\n*/\n\nclass Solution {\n    public Node construct(int[][] grid) {\n        return build(grid, 0, 0, grid.length);\n    }\n\n    private Node build(int[][] grid, int row, int col, int size) {\n        if (isUniform(grid, row, col, size)) {\n            return new Node(grid[row][col] == 1, true);\n        }\n\n        int newSize = size / 2;\n        Node topLeft = build(grid, row, col, newSize);\n        Node topRight = build(grid, row, col + newSize, newSize);\n        Node bottomLeft = build(grid, row + newSize, col, newSize);\n        Node bottomRight = build(grid, row + newSize, col + newSize, newSize);\n\n        return new Node(true, false, topLeft, topRight, bottomLeft, bottomRight);\n    }\n\n    private boolean isUniform(int[][] grid, int row, int col, int size) {\n        int val = grid[row][col];\n        for (int i = row; i < row + size; i++) {\n            for (int j = col; j < col + size; j++) {\n                if (grid[i][j] != val) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "428": {
    "solution": {
      "tree": "import java.util.*;\n\n/*\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n\n    public Node(int val, List<Node> children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n*/\n\nclass Codec {\n\n    public String serialize(Node root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(Node node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"# \");\n            return;\n        }\n        sb.append(node.val).append(\" \").append(node.children.size()).append(\" \");\n        for (Node child : node.children) {\n            serializeHelper(child, sb);\n        }\n    }\n\n    public Node deserialize(String data) {\n        String[] tokens = data.split(\" \");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(tokens));\n        return deserializeHelper(queue);\n    }\n\n    private Node deserializeHelper(Queue<String> queue) {\n        String val = queue.poll();\n        if (val.equals(\"#\")) return null;\n\n        int size = Integer.parseInt(queue.poll());\n        Node node = new Node(Integer.parseInt(val), new ArrayList<>());\n        for (int i = 0; i < size; i++) {\n            node.children.add(deserializeHelper(queue));\n        }\n        return node;\n    }\n}"
    }
  },
  "429": {
    "solution": {
      "tree": "import java.util.*;\n\n/*\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n\n    public Node(int val, List<Node> children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n*/\n\nclass Solution {\n    public List<List<Integer>> levelOrder(Node root) {\n        List<List<Integer>> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<Node> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int levelSize = queue.size();\n            List<Integer> currentLevel = new ArrayList<>();\n\n            for (int i = 0; i < levelSize; i++) {\n                Node node = queue.poll();\n                currentLevel.add(node.val);\n\n                for (Node child : node.children) {\n                    queue.offer(child);\n                }\n            }\n\n            result.add(currentLevel);\n        }\n\n        return result;\n    }\n}"
    }
  },
  "430": {
    "solution": {
      "doubly-linked-list": "/*\nDefinition for a Node.\nclass Node {\n    public int val;\n    public Node prev;\n    public Node next;\n    public Node child;\n};\n*/\n\nclass Solution {\n    public Node flatten(Node head) {\n        if (head == null) return head;\n        \n        Node pointer = head;\n        \n        while (pointer != null) {\n            if (pointer.child == null) {\n                pointer = pointer.next;\n                continue;\n            }\n            \n            Node nextNode = pointer.next;            \n            Node child = pointer.child;\n            Node flattenedChild = flatten(child);\n            \n            pointer.next = flattenedChild;\n            flattenedChild.prev = pointer;\n            \n            Node tail = flattenedChild;\n            while (tail.next != null) {\n                tail = tail.next;\n            }\n            \n            tail.next = nextNode;\n            if (nextNode != null) {\n                nextNode.prev = tail;\n            }\n            \n            pointer.child = null;            \n            pointer = nextNode;\n        }\n        \n        return head;\n    }\n}\n\n"
    }
  },
  "431": {
    "solution": {
      "tree": "class Codec {\n    // Encodes an n-ary tree to a binary tree.\n    public TreeNode encode(Node root) {\n        if (root == null) {\n            return null;\n        }\n        TreeNode node = new TreeNode(root.val);\n        if (root.children == null || root.children.isEmpty()) {\n            return node;\n        }\n        TreeNode left = encode(root.children.get(0));\n        node.left = left;\n        for (int i = 1; i < root.children.size(); i++) {\n            left.right = encode(root.children.get(i));\n            left = left.right;\n        }\n        return node;\n    }\n\n    // Decodes your binary tree to an n-ary tree.\n    public Node decode(TreeNode data) {\n        if (data == null) {\n            return null;\n        }\n        Node node = new Node(data.val, new ArrayList<>());\n        if (data.left == null) {\n            return node;\n        }\n        TreeNode left = data.left;\n        while (left != null) {\n            node.children.add(decode(left));\n            left = left.right;\n        }\n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec codec = new Codec();\n// codec.decode(codec.encode(root));"
    }
  },
  "432": {
    "solution": {
      "doubly-linked-list": "class AllOne {\n\n    class Node {\n        int freq;\n        Set<String> keys;\n        Node prev;\n        Node next;\n\n        Node(int freq) {\n            this.freq = freq;\n            keys = new HashSet<>();\n        }\n    }\n\n    private Node head;\n    private Node tail;\n    private Map<String, Node> keyToNode;\n\n    public AllOne() {\n        head = new Node(0);\n        tail = new Node(0);\n        head.next = tail;\n        tail.prev = head;\n        keyToNode = new HashMap<>();\n    }\n\n    public void inc(String key) {\n        if (keyToNode.containsKey(key)) {\n            Node node = keyToNode.get(key);\n            moveKeyToNextFreq(node, key);\n        } else {\n            if (head.next.freq != 1) {\n                addNodeAfter(new Node(1), head);\n            }\n            head.next.keys.add(key);\n            keyToNode.put(key, head.next);\n        }\n    }\n\n    public void dec(String key) {\n        if (!keyToNode.containsKey(key)) return;\n        Node node = keyToNode.get(key);\n        if (node.freq == 1) {\n            node.keys.remove(key);\n            keyToNode.remove(key);\n        } else {\n            moveKeyToPrevFreq(node, key);\n        }\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    public String getMaxKey() {\n        return tail.prev == head ? \",\" : tail.prev.keys.iterator().next();\n    }\n\n    public String getMinKey() {\n        return head.next == tail ? \": \" : head.next.keys.iterator().next();\n    }\n\n    private void moveKeyToNextFreq(Node node, String key) {\n        int nextFreq = node.freq + 1;\n        Node nextNode = node.next;\n        if (nextNode.freq != nextFreq) {\n            nextNode = new Node(nextFreq);\n            addNodeAfter(nextNode, node);\n        }\n        node.keys.remove(key);\n        nextNode.keys.add(key);\n        keyToNode.put(key, nextNode);\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    private void moveKeyToPrevFreq(Node node, String key) {\n        int prevFreq = node.freq - 1;\n        Node prevNode = node.prev;\n        if (prevNode.freq != prevFreq) {\n            prevNode = new Node(prevFreq);\n            addNodeAfter(prevNode, node.prev);\n        }\n        node.keys.remove(key);\n        prevNode.keys.add(key);\n        keyToNode.put(key, prevNode);\n        if (node.keys.isEmpty()) removeNode(node);\n    }\n\n    private void addNodeAfter(Node newNode, Node prevNode) {\n        newNode.next = prevNode.next;\n        newNode.prev = prevNode;\n        prevNode.next.prev = newNode;\n        prevNode.next = newNode;\n    }\n\n    private void removeNode(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n    }\n}\n"
    }
  },
  "433": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public int minMutation(String start, String end, String[] bank) {\n        Set<String> validMutations = new HashSet<>(Arrays.asList(bank));\n        if (!validMutations.contains(end)) {\n            return -1; // If the end mutation is not in the bank, return -1\n        }\n\n        char[] genes = {'A', 'C', 'G', 'T'};\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(start);\n        int level = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                String current = queue.poll();\n                if (current.equals(end)) {\n                    return level;\n                }\n\n                char[] currArray = current.toCharArray();\n                for (int j = 0; j < currArray.length; j++) {\n                    char originalChar = currArray[j];\n                    for (char gene : genes) {\n                        if (gene == originalChar) continue;\n\n                        currArray[j] = gene;\n                        String newMutation = new String(currArray);\n                        if (validMutations.contains(newMutation)) {\n                            queue.offer(newMutation);\n                            validMutations.remove(newMutation); // Mark as visited\n                        }\n                    }\n                    currArray[j] = originalChar; // Restore original character\n                }\n            }\n            level++;\n        }\n        return -1; // No mutation path found\n    }\n}"
    }
  },
  "434": {
    "solution": {
      "string": "class Solution {\n    public int countSegments(String s) {\n        int count = 0;\n        boolean inSegment = false;\n\n        for (char c : s.toCharArray()) {\n            if (c != ' ') {\n                if (!inSegment) {\n                    count++;\n                    inSegment = true;\n                }\n            } else {\n                inSegment = false;\n            }\n        }\n\n        return count;\n    }\n}"
    }
  },
  "435": {
    "solution": {
      "greedy": "import java.util.Arrays;\n\nclass Solution {\n    public int eraseOverlapIntervals(int[][] intervals) {\n        if (intervals.length == 0)\n            return 0;\n        \n        Arrays.sort(intervals, (a, b) -> Integer.compare(a[1], b[1]));\n        int end = intervals[0][1];\n        int count = 0;\n        \n        for (int i = 1; i < intervals.length; i++) {\n            if (intervals[i][0] < end) {\n                count++;\n            } else {\n                end = intervals[i][1];\n            }\n        }\n        \n        return count;\n    }\n}"
    }
  },
  "436": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n  public int[] findRightInterval(int[][] intervals) {\n    final int n = intervals.length;\n\n    int[] ans = new int[n];\n    NavigableMap<Integer, Integer> startToIndex = new TreeMap<>();\n\n    for (int i = 0; i < n; ++i)\n      startToIndex.put(intervals[i][0], i);\n\n    for (int i = 0; i < n; ++i) {\n      Map.Entry<Integer, Integer> entry = startToIndex.ceilingEntry(intervals[i][1]);\n      if (entry == null)\n        ans[i] = -1;\n      else\n        ans[i] = entry.getValue();\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "437": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int pathSum(TreeNode root, int targetSum) {\n        if (root == null) return 0;\n\n        return countFromNode(root, targetSum)\n            + pathSum(root.left, targetSum)\n            + pathSum(root.right, targetSum);\n    }\n\n    private int countFromNode(TreeNode node, long sum) {\n        if (node == null) return 0;\n\n        int count = 0;\n        if (node.val == sum) count++;\n\n        count += countFromNode(node.left, sum - node.val);\n        count += countFromNode(node.right, sum - node.val);\n\n        return count;\n    }\n}\n\n// TreeNode class assumed as before."
    }
  },
  "438": {
    "solution": {
      "sliding-window": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public List<Integer> findAnagrams(String s, String p) {\n        List<Integer> result = new ArrayList<>();\n        if (s == null || p == null || s.length() < p.length()) {\n            return result;\n        }\n\n        int[] pCount = new int[26];\n        int[] sCount = new int[26];\n\n        for (char c : p.toCharArray()) {\n            pCount[c - 'a']++;\n        }\n\n        int windowLength = p.length();\n        for (int i = 0; i < windowLength; i++) {\n            sCount[s.charAt(i) - 'a']++;\n        }\n\n        for (int i = windowLength; i < s.length(); i++) {\n            if (areArraysEqual(pCount, sCount)) {\n                result.add(i - windowLength);\n            }\n\n            sCount[s.charAt(i - windowLength) - 'a']--;\n            sCount[s.charAt(i) - 'a']++;\n        }\n\n        if (areArraysEqual(pCount, sCount)) {\n            result.add(s.length() - windowLength);\n        }\n\n        return result;\n    }\n\n    private boolean areArraysEqual(int[] arr1, int[] arr2) {\n        for (int i = 0; i < 26; i++) {\n            if (arr1[i] != arr2[i]) {\n                return false;\n            }\n        }\n        return true;\n    }\n}\n"
    }
  },
  "439": {
    "solution": {
      "stack": "class Solution {\n    public String parseTernary(String expression) {\n        Deque<Character> stk = new ArrayDeque<>();\n        boolean cond = false;\n        for (int i = expression.length() - 1; i >= 0; --i) {\n            char c = expression.charAt(i);\n            if (c == ':') {\n                continue;\n            }\n            if (c == '?') {\n                cond = true;\n            } else {\n                if (cond) {\n                    if (c == 'T') {\n                        char x = stk.pop();\n                        stk.pop();\n                        stk.push(x);\n                    } else {\n                        stk.pop();\n                    }\n                    cond = false;\n                } else {\n                    stk.push(c);\n                }\n            }\n        }\n        return String.valueOf(stk.peek());\n    }\n}"
    }
  },
  "440": {
    "solution": {
      "trie": "class Solution {\n    public int findKthNumber(int n, int k) {\n        int curr = 1;\n        k--;\n        while (k > 0) {\n            long step = countSteps(n, curr, curr + 1);\n            if (step <= k) {\n                k -= step;\n                curr++;\n            } else {\n                curr *= 10;\n                k--;\n            }\n        }\n        return curr;\n    }\n\n    private long countSteps(int n, long curr, long next) {\n        long steps = 0;\n        while (curr <= n) {\n            steps += Math.min(n + 1, next) - curr;\n            curr *= 10;\n            next *= 10;\n        }\n        return steps;\n    }\n}"
    }
  },
  "441": {
    "solution": {
      "math": "class Solution {\n  public int arrangeCoins(long n) {\n    return (int) ((-1 + Math.sqrt(8 * n + 1)) / 2);\n  }\n}"
    }
  },
  "442": {
    "solution": {
      "hash-table": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> findDuplicates(int[] nums) {\n        List<Integer> ans = new ArrayList<>();\n\n        for (final int num : nums) {\n            nums[Math.abs(num) - 1] *= -1;\n            if (nums[Math.abs(num) - 1] > 0)\n                ans.add(Math.abs(num));\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "443": {
    "solution": {
      "two-pointers": "class Solution {\n    public int compress(char[] chars) {\n        int write = 0, read = 0;\n        \n        while (read < chars.length) {\n            char currentChar = chars[read];\n            int count = 0;\n            \n            while (read < chars.length && chars[read] == currentChar) {\n                read++;\n                count++;\n            }\n            \n            chars[write++] = currentChar;\n            \n            if (count > 1) {\n                for (char c : Integer.toString(count).toCharArray()) {\n                    chars[write++] = c;\n                }\n            }\n        }\n        \n        return write;\n    }\n}"
    }
  },
  "444": {
    "solution": {
      "topological-sort": "class Solution {\n    public boolean sequenceReconstruction(int[] nums, List<List<Integer>> sequences) {\n        int n = nums.length;\n        List<Set<Integer>> graph = new ArrayList<>();\n        int[] indegree = new int[n + 1];\n        for (int i = 0; i <= n; i++) graph.add(new HashSet<>());\n\n        for (List<Integer> seq : sequences) {\n            for (int i = 1; i < seq.size(); i++) {\n                int from = seq.get(i - 1), to = seq.get(i);\n                if (graph.get(from).add(to)) {\n                    indegree[to]++;\n                }\n            }\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 1; i <= n; i++) {\n            if (indegree[i] == 0) queue.offer(i);\n        }\n\n        int idx = 0;\n        while (!queue.isEmpty()) {\n            if (queue.size() > 1) return false;\n            int cur = queue.poll();\n            if (nums[idx++] != cur) return false;\n            for (int nei : graph.get(cur)) {\n                if (--indegree[nei] == 0) queue.offer(nei);\n            }\n        }\n        return idx == n;\n    }\n}"
    }
  },
  "445": {
    "solution": {
      "stack": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n * int val;\n * ListNode next;\n * ListNode() {}\n * ListNode(int val) { this.val = val; }\n * ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\n\npublic class Solution {\n    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n        Stack<Integer> s1 = new Stack<>();\n        Stack<Integer> s2 = new Stack<>();\n\n        while (l1 != null) {\n            s1.push(l1.val);\n            l1 = l1.next;\n        }\n        while (l2 != null) {\n            s2.push(l2.val);\n            l2 = l2.next;\n        }\n\n        int carry = 0;\n        ListNode head = null;\n\n        while (!s1.isEmpty() || !s2.isEmpty() || carry != 0) {\n            int sum = carry;\n            if (!s1.isEmpty())\n                sum += s1.pop();\n            if (!s2.isEmpty())\n                sum += s2.pop();\n\n            carry = sum / 10;\n            ListNode newNode = new ListNode(sum % 10);\n            newNode.next = head;\n            head = newNode;\n        }\n\n        return head;\n    }\n\n}\n"
    }
  },
  "446": {
    "solution": {
      "dynamic-programming": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int numberOfArithmeticSlices(int[] nums) {\n        int n = nums.length;\n        int totalCount = 0;\n        \n        // Array of HashMaps to store count of subsequences ending at each index\n        Map<Long, Integer>[] dp = new HashMap[n];\n        \n        for (int i = 0; i < n; i++) {\n            dp[i] = new HashMap<>();\n            \n            for (int j = 0; j < i; j++) {\n                long diff = (long) nums[i] - nums[j]; // Compute difference\n                \n                // Get existing count of sequences with this difference at index j\n                int countAtJ = dp[j].getOrDefault(diff, 0);\n                \n                // Update the count at index i\n                dp[i].put(diff, dp[i].getOrDefault(diff, 0) + countAtJ + 1);\n                \n                // Only count subsequences of length  3 (not pairs)\n                totalCount += countAtJ;\n            }\n        }\n        \n        return totalCount;\n    }\n}"
    }
  },
  "447": {
    "solution": {
      "hash-table": "class Solution {\n    public int numberOfBoomerangs(int[][] points) {\n        int count = 0;\n        for (int[] p : points) {\n            Map<Integer, Integer> distanceMap = new HashMap<>();\n            for (int[] q : points) {\n                int dx = p[0] - q[0];\n                int dy = p[1] - q[1];\n                int distance = dx * dx + dy * dy;\n                distanceMap.put(distance, distanceMap.getOrDefault(distance, 0) + 1);\n            }\n            for (int freq : distanceMap.values()) {\n                count += freq * (freq - 1); // Permutations: P(n, 2) = n * (n - 1)\n            }\n        }\n        return count;\n    }\n}"
    }
  },
  "448": {
    "solution": {
      "hash-table": "class Solution {\n    public List<Integer> findDisappearedNumbers(int[] nums) {\n        for (int i = 0; i < nums.length; i++) {\n            int idx = Math.abs(nums[i]) - 1;\n            if (nums[idx] > 0) {\n                nums[idx] = -nums[idx];\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > 0) {\n                result.add(i + 1);\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "449": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode(int x) { val = x; }\n * }\n */\nimport java.util.*;\n\npublic class Codec {\n\n    public String serialize(TreeNode root) {\n        StringBuilder sb = new StringBuilder();\n        serializeHelper(root, sb);\n        return sb.toString();\n    }\n\n    private void serializeHelper(TreeNode node, StringBuilder sb) {\n        if (node == null) {\n            sb.append(\"null\").append(\",\");\n            return;\n        }\n\n        sb.append(node.val).append(\",\");\n        serializeHelper(node.left, sb);\n        serializeHelper(node.right, sb);\n    }\n\n    public TreeNode deserialize(String data) {\n        if (data == null || data.isEmpty()) {\n            return null;\n        }\n\n        String[] nodes = data.split(\",\");\n        Queue<String> queue = new LinkedList<>(Arrays.asList(nodes));\n        return deserializeHelper(queue);\n    }\n\n    private TreeNode deserializeHelper(Queue<String> queue) {\n        String val = queue.poll();\n        if (val.equals(\"null\")) {\n            return null;\n        }\n\n        TreeNode node = new TreeNode(Integer.parseInt(val));\n        node.left = deserializeHelper(queue);\n        node.right = deserializeHelper(queue);\n\n        return node;\n    }\n}\n\n// Your Codec object will be instantiated and called as such:\n// Codec ser = new Codec();\n// Codec deser = new Codec();\n// String tree = ser.serialize(root);\n// TreeNode ans = deser.deserialize(tree);\n// return ans;"
    }
  },
  "450": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    public TreeNode deleteNode(TreeNode root, int key) {\n        if (root == null) {\n            return null;\n        }\n\n        if (key < root.val) {\n            root.left = deleteNode(root.left, key);\n        } else if (key > root.val) {\n            root.right = deleteNode(root.right, key);\n        } else {\n            if (root.left == null) {\n                return root.right;\n            } else if (root.right == null) {\n                return root.left;\n            }\n            root.val = findMin(root.right);\n            root.right = deleteNode(root.right, root.val);\n        }\n\n        return root;\n    }\n\n    private int findMin(TreeNode node) {\n        while (node.left != null) {\n            node = node.left;\n        }\n        return node.val;\n    }\n}\n"
    }
  },
  "451": {
    "solution": {
      "bucket-sort": "import java.util.*;\n\npublic class Solution {\n    public String frequencySort(String s) {\n        Map<Character, Integer> frequencyMap = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            frequencyMap.put(c, frequencyMap.getOrDefault(c, 0) + 1);\n        }\n\n        List<Character>[] buckets = new List[s.length() + 1];\n        for (char key : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(key);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(key);\n        }\n\n        StringBuilder result = new StringBuilder();\n        for (int i = buckets.length - 1; i >= 0; i--) {\n            if (buckets[i] != null) {\n                for (char c : buckets[i]) {\n                    for (int j = 0; j < i; j++) {\n                        result.append(c);\n                    }\n                }\n            }\n        }\n\n        return result.toString();\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.frequencySort(\"tree\")); // Output: \"eert\" or \"rtee\"\n        System.out.println(solution.frequencySort(\"cccaaa\")); // Output: \"cccaaa\" or \"aaaccc\"\n        System.out.println(solution.frequencySort(\"Aabb\")); // Output: \"bbAa\" or \"bbaA\"\n    }\n}\n"
    }
  },
  "452": {
    "solution": {
      "greedy": "class Solution {\n    public int findMinArrowShots(int[][] points) {\n        if (points.length == 0) return 0;\n\n        Arrays.sort(points, (a, b) -> Integer.compare(a[1], b[1]));\n\n        int arrows = 1;\n        int end = points[0][1];\n\n        for (int[] point : points) {\n            if (point[0] > end) {\n                arrows++;\n                end = point[1];\n            }\n        }\n        return arrows;\n    }\n}"
    }
  },
  "453": {
    "solution": {
      "math": "class Solution {\n    public int minMoves(int[] nums) {\n        int min = Arrays.stream(nums).min().getAsInt();\n        int moves = 0;\n        for (int num : nums) {\n            moves += num - min;\n        }\n        return moves;\n    }\n}"
    }
  },
  "454": {
    "solution": {
      "hash-table": "class Solution {\n  public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {\n    int ans = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (final int a : nums1)\n      for (final int b : nums2)\n        count.merge(a + b, 1, Integer::sum);\n\n    for (final int c : nums3)\n      for (final int d : nums4)\n        if (count.containsKey(-c - d))\n          ans += count.get(-c - d);\n\n    return ans;\n  }\n}"
    }
  },
  "455": {
    "solution": {
      "greedy": "class Solution {\n    public int findContentChildren(int[] g, int[] s) {\n        Arrays.sort(g);\n        Arrays.sort(s);\n\n        int i = 0, j = 0;\n        while (i < g.length && j < s.length) {\n            if (s[j] >= g[i]) {\n                i++;\n            }\n            j++;\n        }\n        return i;\n    }\n}"
    }
  },
  "456": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public boolean find132pattern(int[] nums) {\n        int n = nums.length;\n        if (n < 3) {\n            return false;\n        }\n\n        Stack<Integer> stack = new Stack<>();\n        int[] min = new int[n];\n        min[0] = nums[0];\n\n        for (int i = 1; i < n; ++i) {\n            min[i] = Math.min(min[i - 1], nums[i]);\n        }\n\n        for (int j = n - 1; j >= 0; --j) {\n            if (nums[j] > min[j]) {\n                while (!stack.isEmpty() && stack.peek() <= min[j]) {\n                    stack.pop();\n                }\n                if (!stack.isEmpty() && stack.peek() < nums[j]) {\n                    return true;\n                }\n                stack.push(nums[j]);\n            }\n        }\n\n        return false;\n    }\n}\n"
    }
  },
  "457": {
    "solution": {
      "two-pointers": "class Solution {\n    private int n;\n    private int[] nums;\n\n    public boolean circularArrayLoop(int[] nums) {\n        n = nums.length;\n        this.nums = nums;\n        for (int i = 0; i < n; ++i) {\n            if (nums[i] == 0) {\n                continue;\n            }\n            int slow = i, fast = next(i);\n            while (nums[slow] * nums[fast] > 0 && nums[slow] * nums[next(fast)] > 0) {\n                if (slow == fast) {\n                    if (slow != next(slow)) {\n                        return true;\n                    }\n                    break;\n                }\n                slow = next(slow);\n                fast = next(next(fast));\n            }\n            int j = i;\n            while (nums[j] * nums[next(j)] > 0) {\n                nums[j] = 0;\n                j = next(j);\n            }\n        }\n        return false;\n    }\n\n    private int next(int i) {\n        return (i + nums[i] % n + n) % n;\n    }\n}"
    }
  },
  "458": {
    "solution": {
      "dynamic-programming": "class Solution {\n  public int poorPigs(int buckets, int minutesToDie, int minutesToTest) {\n    final int base = minutesToTest / minutesToDie + 1;\n    int ans = 0;\n    for (int x = 1; x < buckets; x *= base)\n      ++ans;\n    return ans;\n  }\n}"
    }
  },
  "459": {
    "solution": {
      "string-matching": "class Solution {\n    public boolean repeatedSubstringPattern(String s) {\n        String doubled = s + s;\n        return doubled.substring(1, doubled.length() - 1).contains(s);\n    }\n}"
    }
  },
  "460": {
    "solution": {
      "doubly-linked-list": "class LFUCache {\n    class Node {\n        int key, value, freq;\n        Node prev, next;\n        Node(int k, int v) {\n            key = k;\n            value = v;\n            freq = 1;\n        }\n    }\n\n    class DoublyLinkedList {\n        Node head, tail;\n        DoublyLinkedList() {\n            head = new Node(0, 0);\n            tail = new Node(0, 0);\n            head.next = tail;\n            tail.prev = head;\n        }\n\n        void addNode(Node node) {\n            Node nextNode = head.next;\n            head.next = node;\n            node.prev = head;\n            node.next = nextNode;\n            nextNode.prev = node;\n        }\n\n        void removeNode(Node node) {\n            Node prevNode = node.prev;\n            Node nextNode = node.next;\n            prevNode.next = nextNode;\n            nextNode.prev = prevNode;\n        }\n\n        boolean isEmpty() {\n            return head.next == tail;\n        }\n    }\n\n    private int capacity, size, minFreq;\n    private Map<Integer, Node> keyToNode;\n    private Map<Integer, DoublyLinkedList> freqToDLL;\n\n    public LFUCache(int capacity) {\n        this.capacity = capacity;\n        this.size = 0;\n        this.minFreq = 0;\n        this.keyToNode = new HashMap<>();\n        this.freqToDLL = new HashMap<>();\n    }\n\n    public int get(int key) {\n        if (!keyToNode.containsKey(key)) return -1;\n        Node node = keyToNode.get(key);\n        updateFrequency(node);\n        return node.value;\n    }\n\n    public void put(int key, int value) {\n        if (capacity == 0) return;\n        if (keyToNode.containsKey(key)) {\n            Node node = keyToNode.get(key);\n            node.value = value;\n            updateFrequency(node);\n        } else {\n            if (size == capacity) {\n                DoublyLinkedList minFreqList = freqToDLL.get(minFreq);\n                keyToNode.remove(minFreqList.tail.prev.key);\n                minFreqList.removeNode(minFreqList.tail.prev);\n                size--;\n            }\n            Node newNode = new Node(key, value);\n            keyToNode.put(key, newNode);\n            minFreq = 1;\n            freqToDLL.computeIfAbsent(1, k -> new DoublyLinkedList()).addNode(newNode);\n            size++;\n        }\n    }\n\n    private void updateFrequency(Node node) {\n        int oldFreq = node.freq;\n        DoublyLinkedList oldList = freqToDLL.get(oldFreq);\n        oldList.removeNode(node);\n        if (oldFreq == minFreq && oldList.isEmpty()) minFreq++;\n        node.freq++;\n        freqToDLL.computeIfAbsent(node.freq, k -> new DoublyLinkedList()).addNode(node);\n    }\n}\n"
    }
  },
  "461": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int hammingDistance(int x, int y) {\n        int xor = x ^ y; // XOR to find differing bits\n        int distance = 0;\n        \n        while (xor > 0) {\n            distance += xor & 1; // Count set bits\n            xor >>= 1; // Right shift to process next bit\n        }\n        \n        return distance;\n    }\n}"
    }
  },
  "462": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int minMoves2(int[] nums) {\n        int length = nums.length;\n        int median = quickSelect(nums, 0, length - 1, (length + 1) / 2);\n        int totalMoves = 0;\n        \n        for (int num : nums) {\n            totalMoves += Math.abs(num - median);\n        }\n        \n        return totalMoves;\n    }\n\n    private int quickSelect(int[] nums, int left, int right, int k) {\n        int randomIndex = new Random().nextInt(right - left + 1) + left;\n        swap(nums, randomIndex, right);\n        int pivot = nums[right];\n\n        int swapIndex = left;\n        for (int i = left; i < right; ++i) {\n            if (nums[i] <= pivot) {\n                swap(nums, swapIndex++, i);\n            }\n        }\n        swap(nums, swapIndex, right);\n\n        int count = swapIndex - left + 1;\n        if (count == k) {\n            return nums[swapIndex];\n        }\n        if (count > k) {\n            return quickSelect(nums, left, swapIndex - 1, k);\n        }\n        return quickSelect(nums, swapIndex + 1, right, k - count);\n    }\n\n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}"
    }
  },
  "463": {
    "solution": {
      "matrix": "class Solution {\n    private final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int islandPerimeter(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n        int m = grid.length;\n        int n = grid[0].length;\n        int perimeter = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    for (int[] direction : DIRECTIONS) {\n                        int x = i + direction[0];\n                        int y = j + direction[1];\n\n                        if (x < 0 || x >= m || y < 0 || y >= n || grid[x][y] == 0) {\n                            perimeter++;\n                        }\n                    }\n                }\n            }\n        }\n\n        return perimeter;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {0, 1, 0, 0},\n            {1, 1, 1, 0},\n            {1, 0, 0, 0},\n            {0, 1, 0, 0}\n        };\n\n        int result = solution.islandPerimeter(grid);\n        System.out.println(\"Island Perimeter: \" + result); // Output: 12\n    }\n}\n"
    }
  },
  "464": {
    "solution": {
      "bitmask": "class Solution {\n    private Map<Integer, Boolean> memo = new HashMap<>();\n\n    public boolean canIWin(int maxChoosableInteger, int desiredTotal) {\n        if (desiredTotal <= 0) return true;\n        int maxSum = (maxChoosableInteger * (maxChoosableInteger + 1)) / 2;\n        if (maxSum < desiredTotal) return false; // Impossible to reach desiredTotal\n\n        return canWin(maxChoosableInteger, desiredTotal, 0);\n    }\n\n    private boolean canWin(int maxChoosableInteger, int target, int used) {\n        if (memo.containsKey(used)) return memo.get(used);\n\n        for (int i = 1; i <= maxChoosableInteger; i++) {\n            int mask = 1 << i;\n            if ((used & mask) != 0) continue;\n\n            if (i >= target || !canWin(maxChoosableInteger, target - i, used | mask)) {\n                memo.put(used, true);\n                return true;\n            }\n        }\n\n        memo.put(used, false);\n        return false;\n    }\n}"
    }
  },
  "465": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int minTransfers(int[][] transactions) {\n        int[] balance = new int[12];\n        \n        // Calculate net balance for each person\n        for (var transaction : transactions) {\n            balance[transaction[0]] -= transaction[2];\n            balance[transaction[1]] += transaction[2];\n        }\n        \n        List<Integer> nonZeroBalances = new ArrayList<>();\n        for (int amount : balance) {\n            if (amount != 0) {\n                nonZeroBalances.add(amount);\n            }\n        }\n        \n        int numPeople = nonZeroBalances.size();\n        int[] dp = new int[1 << numPeople];\n        Arrays.fill(dp, Integer.MAX_VALUE / 2);\n        dp[0] = 0;\n        \n        for (int mask = 1; mask < (1 << numPeople); ++mask) {\n            int sum = 0;\n            for (int j = 0; j < numPeople; ++j) {\n                if ((mask & (1 << j)) != 0) {\n                    sum += nonZeroBalances.get(j);\n                }\n            }\n            \n            if (sum == 0) {\n                dp[mask] = Integer.bitCount(mask) - 1;\n                for (int subset = (mask - 1) & mask; subset > 0; subset = (subset - 1) & mask) {\n                    dp[mask] = Math.min(dp[mask], dp[subset] + dp[mask ^ subset]);\n                }\n            }\n        }\n        \n        return dp[(1 << numPeople) - 1];\n    }\n}"
    }
  },
  "466": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int getMaxRepetitions(String s1, int n1, String s2, int n2) {\n        record Record(int count, int nextIndex) {}\n        // records[i].count := the number of times that s2 starting from index i has\n        // been fully matched with s1\n        // records[i].nextIndex := the next index in s2 to be matched after\n        // completing a full match starting from index i\n        List<Record> records = new ArrayList<>();\n\n        for (int i = 0; i < s2.length(); ++i) {\n            int count = 0;\n            int nextIndex = i;\n            for (final char c : s1.toCharArray())\n                if (s2.charAt(nextIndex) == c)\n                    if (++nextIndex == s2.length()) { // There's a match.\n                        ++count;\n                        nextIndex = 0;\n                    }\n            records.add(new Record(count, nextIndex));\n        }\n\n        int matches = 0; // the number of matches between `s1` x n1 and `s2`\n        int i = 0; // the index in `s2` to start matching\n\n        while (n1-- > 0) {\n            matches += records.get(i).count;\n            i = records.get(i).nextIndex;\n        }\n\n        return matches / n2;\n    }\n}"
    }
  },
  "467": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int findSubstringInWraproundString(String input) {\n        int[] maxSubstringLengths = new int[26]; // Stores max length of substrings ending at each letter\n        int currentLength = 0; // Length of the current valid substring sequence\n\n        for (int index = 0; index < input.length(); ++index) {\n            char currentChar = input.charAt(index);\n\n            // Check if current character continues the cyclic sequence\n            if (index > 0 && (currentChar - input.charAt(index - 1) + 26) % 26 == 1) {\n                ++currentLength;\n            } else {\n                currentLength = 1;\n            }\n\n            int charIndex = currentChar - 'a';\n            maxSubstringLengths[charIndex] = Math.max(maxSubstringLengths[charIndex], currentLength);\n        }\n\n        int totalSubstrings = 0;\n        for (int length : maxSubstringLengths) {\n            totalSubstrings += length;\n        }\n        return totalSubstrings;\n    }\n}"
    }
  },
  "468": {
    "solution": {
      "string": "class Solution {\n    public String validIPAddress(String IP) {\n        if (IP.chars().filter(ch -> ch == '.').count() == 3) {\n            return isValidIPv4(IP) ? \"IPv4\" : \"Neither\";\n        }\n        if (IP.chars().filter(ch -> ch == ':').count() == 7) {\n            return isValidIPv6(IP) ? \"IPv6\" : \"Neither\";\n        }\n        return \"Neither\";\n    }\n\n    private boolean isValidIPv4(String ip) {\n        String[] parts = ip.split(\"\\\\.\", -1);\n        if (parts.length != 4) return false;\n\n        for (String part : parts) {\n            if (part.length() == 0 || part.length() > 3) return false;\n            if (part.charAt(0) == '0' && part.length() != 1) return false;\n            for (char c : part.toCharArray()) {\n                if (!Character.isDigit(c)) return false;\n            }\n            int num = Integer.parseInt(part);\n            if (num < 0 || num > 255) return false;\n        }\n        return true;\n    }\n\n    private boolean isValidIPv6(String ip) {\n        String[] parts = ip.split(\":\", -1);\n        if (parts.length != 8) return false;\n\n        for (String part : parts) {\n            if (part.length() == 0 || part.length() > 4) return false;\n            for (char c : part.toCharArray()) {\n                if (!isHexDigit(c)) return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean isHexDigit(char c) {\n        return (c >= '0' && c <= '9') ||\n               (c >= 'a' && c <= 'f') ||\n               (c >= 'A' && c <= 'F');\n    }\n}"
    }
  },
  "469": {
    "solution": {
      "geometry": "class Solution {\n    public boolean isConvex(List<List<Integer>> points) {\n        int n = points.size();\n        long pre = 0, cur = 0;\n        for (int i = 0; i < n; ++i) {\n            var p1 = points.get(i);\n            var p2 = points.get((i + 1) % n);\n            var p3 = points.get((i + 2) % n);\n            int x1 = p2.get(0) - p1.get(0);\n            int y1 = p2.get(1) - p1.get(1);\n            int x2 = p3.get(0) - p1.get(0);\n            int y2 = p3.get(1) - p1.get(1);\n            cur = x1 * y2 - x2 * y1;\n            if (cur != 0) {\n                if (cur * pre < 0) {\n                    return false;\n                }\n                pre = cur;\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "470": {
    "solution": {
      "rejection-sampling": "/**\n * The rand7() API is already defined in the parent class SolBase.\n * public int rand7();\n * @return a random integer in the range 1 to 7\n */\nclass Solution extends SolBase {\n    public int rand10() {\n        while (true) {\n            int num = (rand7() - 1) * 7 + rand7(); // Generate a number from 1 to 49\n            if (num <= 40) { // Accept only if the number is in the range 1 to 40\n                return 1 + (num - 1) % 10; // Map to the range 1 to 10\n            }\n        }\n    }\n}"
    }
  },
  "471": {
    "solution": {
      "dynamic-programming": "class Solution {\n    private String inputString;\n    private String[][] encodedResults;\n\n    public String encode(String s) {\n        this.inputString = s;\n        int stringLength = s.length();\n        encodedResults = new String[stringLength][stringLength];\n\n        for (int start = stringLength - 1; start >= 0; --start) {\n            for (int end = start; end < stringLength; ++end) {\n                encodedResults[start][end] = encodeSubstring(start, end);\n\n                if (end - start + 1 > 4) {\n                    for (int mid = start; mid < end; ++mid) {\n                        String splitEncoded = encodedResults[start][mid] + encodedResults[mid + 1][end];\n                        if (encodedResults[start][end].length() > splitEncoded.length()) {\n                            encodedResults[start][end] = splitEncoded;\n                        }\n                    }\n                }\n            }\n        }\n        return encodedResults[0][stringLength - 1];\n    }\n\n    private String encodeSubstring(int start, int end) {\n        String substring = inputString.substring(start, end + 1);\n        if (substring.length() < 5) {\n            return substring;\n        }\n\n        int repeatIndex = (substring + substring).indexOf(substring, 1);\n        if (repeatIndex < substring.length()) {\n            int repeatCount = substring.length() / repeatIndex;\n            return String.format(\"%d[%s]\", repeatCount, encodedResults[start][start + repeatIndex - 1]);\n        }\n        return substring;\n    }\n}\n"
    }
  },
  "472": {
    "solution": {
      "depth-first-search": "import java.util.*;\n\nclass Solution {\n    public List<String> findAllConcatenatedWordsInADict(String[] words) {\n        List<String> result = new ArrayList<>();\n        Set<String> wordSet = new HashSet<>(Arrays.asList(words));\n        Map<String, Boolean> memo = new HashMap<>();\n\n        for (String word : words) {\n            if (canForm(word, wordSet, memo)) {\n                result.add(word);\n            }\n        }\n        return result;\n    }\n\n    private boolean canForm(String word, Set<String> wordSet, Map<String, Boolean> memo) {\n        if (memo.containsKey(word)) return memo.get(word);\n\n        for (int i = 1; i < word.length(); i++) {\n            String prefix = word.substring(0, i);\n            String suffix = word.substring(i);\n\n            if (wordSet.contains(prefix) && \n                (wordSet.contains(suffix) || canForm(suffix, wordSet, memo))) {\n                memo.put(word, true);\n                return true;\n            }\n        }\n\n        memo.put(word, false);\n        return false;\n    }\n}\n"
    }
  },
  "473": {
    "solution": {
      "backtracking": "import java.util.Arrays;\n\nclass Solution {\n    public boolean makesquare(int[] matchsticks) {\n        int total = 0;\n        for (int stick : matchsticks) {\n            total += stick;\n        }\n        if (total % 4 != 0) return false;\n        int target = total / 4;\n\n        Arrays.sort(matchsticks);\n        reverse(matchsticks); // Optional: sorting descending to optimize\n\n        int[] sides = new int[4];\n        return dfs(matchsticks, 0, sides, target);\n    }\n\n    private boolean dfs(int[] matchsticks, int index, int[] sides, int target) {\n        if (index == matchsticks.length) {\n            return sides[0] == target && sides[1] == target &&\n                   sides[2] == target && sides[3] == target;\n        }\n\n        for (int i = 0; i < 4; i++) {\n            if (sides[i] + matchsticks[index] > target) continue;\n            sides[i] += matchsticks[index];\n            if (dfs(matchsticks, index + 1, sides, target)) return true;\n            sides[i] -= matchsticks[index];\n            if (sides[i] == 0) break;\n        }\n\n        return false;\n    }\n\n    private void reverse(int[] arr) {\n        int left = 0, right = arr.length - 1;\n        while (left < right) {\n            int temp = arr[left];\n            arr[left] = arr[right];\n            arr[right] = temp;\n            left++;\n            right--;\n        }\n    }\n}"
    }
  },
  "474": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int findMaxForm(String[] strs, int m, int n) {\n        // dp[i][j] = max number of strings that can be formed with i zeros and j ones\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (String str : strs) {\n            int zeros = 0, ones = 0;\n            for (char c : str.toCharArray()) {\n                if (c == '0') zeros++;\n                else ones++;\n            }\n\n            for (int i = m; i >= zeros; i--) {\n                for (int j = n; j >= ones; j--) {\n                    dp[i][j] = Math.max(dp[i][j], dp[i - zeros][j - ones] + 1);\n                }\n            }\n        }\n\n        return dp[m][n];\n    }\n}"
    }
  },
  "475": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\n\nclass Solution {\n    public int findRadius(int[] houses, int[] heaters) {\n        Arrays.sort(houses);\n        Arrays.sort(heaters);\n        \n        int maxRadius = 0;\n        \n        for (int house : houses) {\n            int idx = Arrays.binarySearch(heaters, house);\n            \n            if (idx < 0) {\n                idx = -(idx + 1); // Find insertion point\n            }\n            \n            int leftDist = (idx > 0) ? house - heaters[idx - 1] : Integer.MAX_VALUE;\n            int rightDist = (idx < heaters.length) ? heaters[idx] - house : Integer.MAX_VALUE;\n            \n            int minDist = Math.min(leftDist, rightDist);\n            maxRadius = Math.max(maxRadius, minDist);\n        }\n        \n        return maxRadius;\n    }\n}\n"
    }
  },
  "476": {
    "solution": {
      "bit-manipulation": "class Solution {\n  public int findComplement(int num) {\n    for (long i = 1; i <= num; i <<= 1)\n      num ^= i;\n    return num;\n  }\n}"
    }
  },
  "477": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int totalHammingDistance(int[] nums) {\n        int totalDistance = 0;\n        int n = nums.length;\n        \n        for (int bitPosition = 0; bitPosition < 32; bitPosition++) {\n            int countOnes = 0;\n            \n            // Count how many numbers have a 1 at this bit position\n            for (int num : nums) {\n                countOnes += (num >> bitPosition) & 1;\n            }\n            \n            int countZeros = n - countOnes; // Remaining are zeros\n            totalDistance += countOnes * countZeros; // Contribution of this bit position\n        }\n        \n        return totalDistance;\n    }\n}\n"
    }
  },
  "478": {
    "solution": {
      "rejection-sampling": "import java.util.Random;\n\nclass Solution {\n    private double radius;\n    private double x_center;\n    private double y_center;\n    private Random random;\n\n    public Solution(double radius, double x_center, double y_center) {\n        this.radius = radius;\n        this.x_center = x_center;\n        this.y_center = y_center;\n        this.random = new Random();\n    }\n\n    public double[] randPoint() {\n        double x = x_center - radius + 2 * radius * random.nextDouble();\n        double y = y_center - radius + 2 * radius * random.nextDouble();\n\n        while (!isInCircle(x, y)) {\n            x = x_center - radius + 2 * radius * random.nextDouble();\n            y = y_center - radius + 2 * radius * random.nextDouble();\n        }\n\n        return new double[]{x, y};\n    }\n\n    private boolean isInCircle(double x, double y) {\n        return Math.pow(x - x_center, 2) + Math.pow(y - y_center, 2) <= Math.pow(radius, 2);\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(radius, x_center, y_center);\n * double[] param_1 = obj.randPoint();\n */"
    }
  },
  "479": {
    "solution": {
      "math": "class Solution {\n    public int largestPalindrome(int n) {\n        if (n == 1) return 9;\n\n        int upper = (int)Math.pow(10, n) - 1;\n        int lower = (int)Math.pow(10, n - 1);\n\n        for (int i = upper; i >= lower; i--) {\n            long p = createPalindrome(i);\n            for (long j = upper; j >= lower; j--) {\n                if (p / j > upper) break;\n                if (p % j == 0) return (int)(p % 1337);\n            }\n        }\n\n        return -1;\n    }\n\n    private long createPalindrome(int half) {\n        String s = Integer.toString(half);\n        String rev = new StringBuilder(s).reverse().toString();\n        return Long.parseLong(s + rev);\n    }\n}"
    }
  },
  "480": {
    "solution": {
      "sliding-window": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class Solution {\n    public double[] medianSlidingWindow(int[] nums, int k) {\n        List<Double> resList = new ArrayList<>();\n        int n = nums.length;\n        int i = 0;\n        int j = k - 1;\n        List<Integer> temp = new ArrayList<>();\n        for (int x = 0; x < k - 1; x++) {\n            temp.add(nums[x]);\n        }\n        Collections.sort(temp);\n        while (j < n) {\n            int num = nums[j];\n            int insertIdx = Collections.binarySearch(temp, num);\n            if (insertIdx < 0) {\n                insertIdx = -insertIdx - 1;\n            }\n            temp.add(insertIdx, num);\n\n            if (k % 2 == 1) {\n                double median = (double) temp.get(k / 2);\n                resList.add(median);\n            } else {\n                int idx = k / 2;\n                double median1 = (double) temp.get(idx);\n                double median2 = (double) temp.get(idx - 1);\n                resList.add((median1 + median2) / 2);\n            }\n\n            int removeIdx = Collections.binarySearch(temp, nums[i]);\n            if (removeIdx < 0) {\n                removeIdx = -removeIdx - 1;\n            }\n            temp.remove(removeIdx);\n\n            i++;\n            j++;\n        }\n\n        double[] resArray = new double[resList.size()];\n        for (int x = 0; x < resList.size(); x++) {\n            resArray[x] = resList.get(x);\n        }\n\n        return resArray;\n    }\n}"
    }
  },
  "481": {
    "solution": {
      "two-pointers": "class Solution {\n    public int magicalString(int n) {\n        if (n == 0) return 0;\n        if (n <= 3) return 1; // \"122\" has one '1'\n\n        List<Integer> magicString = new ArrayList<>();\n        magicString.add(1);\n        magicString.add(2);\n        magicString.add(2);\n        \n        int index = 2;  // Points to the number determining the next repetition\n        int nextNum = 1; // Next number to be added (alternating between 1 and 2)\n        int onesCount = 1; // Initial count (since \"1\" appears once in \"122\")\n        \n        while (magicString.size() < n) {\n            int repeat = magicString.get(index); // Number of times to add `nextNum`\n            for (int i = 0; i < repeat && magicString.size() < n; i++) {\n                magicString.add(nextNum);\n                if (nextNum == 1) {\n                    onesCount++; // Count '1's as we add them\n                }\n            }\n            nextNum = (nextNum == 1) ? 2 : 1; // Alternate between 1 and 2\n            index++; // Move to the next determining number\n        }\n\n        return onesCount;\n    }\n}\n"
    }
  },
  "482": {
    "solution": {
      "string": "class Solution {\n    public String licenseKeyFormatting(String s, int k) {\n        StringBuilder sb = new StringBuilder();\n        int count = 0;\n\n        for (int i = s.length() - 1; i >= 0; i--) {\n            char ch = s.charAt(i);\n            if (ch == '-') continue;\n            \n            if (count == k) {\n                sb.append('-');\n                count = 0;\n            }\n            sb.append(Character.toUpperCase(ch));\n            count++;\n        }\n\n        return sb.reverse().toString();\n    }\n}"
    }
  },
  "483": {
    "solution": {
      "math": "// 13\nclass Solution {\n  public String smallestGoodBase(String n) {\n    final long num = Long.parseLong(n);\n    final int log2 = (int) (Math.log(num) / Math.log(2));\n\n    for (int m = log2; m >= 2; --m) {\n      int k = (int) Math.floor(Math.pow(num, 1.0 / m));\n      long sum = 1;\n      long prod = 1;\n      for (int i = 0; i < m; ++i) {\n        prod *= k;\n        sum += prod;\n      }\n      if (sum == num)\n        return String.valueOf(k);\n    }\n\n    return String.valueOf(num - 1);\n  }\n}\n"
    }
  },
  "484": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int[] findPermutation(String s) {\n        int n = s.length();\n        int[] result = new int[n + 1];\n        for (int i = 0; i <= n; i++) {\n            result[i] = i + 1;\n        }\n\n        int i = 0;\n        while (i < n) {\n            if (s.charAt(i) == 'D') {\n                int start = i;\n                while (i < n && s.charAt(i) == 'D') {\n                    i++;\n                }\n                reverse(result, start, i);\n            } else {\n                i++;\n            }\n        }\n\n        return result;\n    }\n\n    private void reverse(int[] arr, int start, int end) {\n        while (start < end) {\n            int temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}"
    }
  },
  "485": {
    "solution": {
      "array": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int maxCount = 0;\n        int currentCount = 0;\n        \n        for (int num : nums) {\n            if (num == 1) {\n                currentCount++;\n                maxCount = Math.max(maxCount, currentCount);\n            } else {\n                currentCount = 0;\n            }\n        }\n        \n        return maxCount;\n    }\n}\n"
    }
  },
  "486": {
    "solution": {
      "game-theory": "class Solution {\n    public boolean PredictTheWinner(int[] nums) {\n        int n = nums.length;\n        int[][] dp = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = nums[i];\n        }\n\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                dp[i][j] = Math.max(nums[i] - dp[i + 1][j], nums[j] - dp[i][j - 1]);\n            }\n        }\n\n        return dp[0][n - 1] >= 0;\n    }\n}"
    }
  },
  "487": {
    "solution": {
      "sliding-window": "class Solution {\n    public int findMaxConsecutiveOnes(int[] nums) {\n        int left = 0, right = 0;\n        int k = 1;\n        while (right < nums.length) {\n            if (nums[right++] == 0) {\n                --k;\n            }\n            if (k < 0 && nums[left++] == 0) {\n                ++k;\n            }\n        }\n        return right - left;\n    }\n}"
    }
  },
  "488": {
    "solution": {
      "stack": "class Solution {\n    public int findMinStep(String board, String hand) {\n        List<Character> boardList = new ArrayList<>();\n        for (char c : board.toCharArray()) {\n            boardList.add(c);\n        }\n        List<Character> handList = new ArrayList<>();\n        for (char c : hand.toCharArray()) {\n            handList.add(c);\n        }\n        \n        int res = findMinStep(boardList, handList);\n        return res;\n    }\n    \n    public int findMinStep(List<Character> boardList, List<Character> handList) {\n        if (boardList.isEmpty()) {\n            return 0;\n        }\n        if (!boardList.isEmpty() && handList.isEmpty()) {\n            return -1;\n        }\n        if (!isValid(boardList, handList)) {\n            return -1;\n        }\n        \n        int res = Integer.MAX_VALUE;\n        for (int boardListIndex=0; boardListIndex<=boardList.size(); boardListIndex++) {            \n            Set<Character> duplicate = new HashSet<>();\n            for (int handListIndex=0; handListIndex<handList.size(); handListIndex++) {\n                if (boardListIndex > 0 && boardList.get(boardListIndex-1) == handList.get(handListIndex)) {\n                    continue;\n                }\n                if (duplicate.contains(handList.get(handListIndex))) {\n                    continue;\n                } else {\n                    duplicate.add(handList.get(handListIndex));\n                }\n\n                boolean goodCase1 = (boardListIndex < boardList.size() && boardList.get(boardListIndex) == handList.get(handListIndex));\n                boolean goodCase2 = (boardListIndex > 0 && boardListIndex < boardList.size() && boardList.get(boardListIndex-1) == boardList.get(boardListIndex) && boardList.get(boardListIndex-1) != handList.get(handListIndex));\n                if (goodCase1 == false && goodCase2 == false) continue;\n                \n                List<Character> boardListClone = new ArrayList<>(boardList);\n                List<Character> handListClone = new ArrayList<>(handList);\n                boardListClone.add(boardListIndex, handListClone.remove(handListIndex));\n                cleanup(boardListClone);\n                int preRes = findMinStep(boardListClone, handListClone);\n                if (preRes != -1 && preRes < res) {\n                    res = preRes;\n                }\n            }\n        }\n        \n        if (res == Integer.MAX_VALUE) {\n            return -1;\n        }\n        return res + 1;\n    }\n    \n    public void cleanup(List<Character> boardList) {\n        Boolean isCleanup = false;\n        while (!isCleanup) {\n            isCleanup = true;\n            for (int i=0; i<boardList.size()-2; i++) {\n                int repeatLen = 1;\n                for (int j=i+1; j<boardList.size(); j++) {\n                    if (boardList.get(j) == boardList.get(j-1)) {\n                        repeatLen++;\n                    } else {\n                        break;\n                    }\n                }\n                if (repeatLen >= 3) {\n                    isCleanup = false;\n                    for (; repeatLen > 0; repeatLen--) {\n                        boardList.remove(i);\n                    }\n                }\n            }\n        }\n    }\n    \n    public boolean isValid(List<Character> boardList, List<Character> handList) {\n        int boardR = 0, boardY = 0, boardB = 0, boardG = 0, boardW = 0;\n        int handR = 0, handY = 0, handB = 0, handG = 0, handW = 0;\n        for (char c : boardList) {\n            if (c == 'R') boardR++;\n            if (c == 'Y') boardY++;\n            if (c == 'B') boardB++;\n            if (c == 'G') boardG++;\n            if (c == 'W') boardW++;\n        }\n        for (char c : handList) {\n            if (c == 'R') handR++;\n            if (c == 'Y') handY++;\n            if (c == 'B') handB++;\n            if (c == 'G') handG++;\n            if (c == 'W') handW++;\n        }\n        if (boardR < 3 && boardR > 0 && boardR + handR < 3) return false;\n        if (boardY < 3 && boardY > 0 && boardY + handY < 3) return false;\n        if (boardB < 3 && boardB > 0 && boardB + handB < 3) return false;\n        if (boardG < 3 && boardG > 0 && boardG + handG < 3) return false;\n        if (boardW < 3 && boardW > 0 && boardW + handW < 3) return false;\n        \n        return true;\n    }\n}"
    }
  },
  "489": {
    "solution": {
      "interactive": "class Solution {\n    private int[] dirs = {-1, 0, 1, 0, -1};\n    private Set<List<Integer>> vis = new HashSet<>();\n    private Robot robot;\n\n    public void cleanRoom(Robot robot) {\n        this.robot = robot;\n        dfs(0, 0, 0);\n    }\n\n    private void dfs(int i, int j, int d) {\n        robot.clean();\n        vis.add(List.of(i, j));\n        for (int k = 0; k < 4; ++k) {\n            int nd = (d + k) % 4;\n            int x = i + dirs[nd], y = j + dirs[nd + 1];\n            if (!vis.contains(List.of(x, y)) && robot.move()) {\n                dfs(x, y, nd);\n                robot.turnRight();\n                robot.turnRight();\n                robot.move();\n                robot.turnRight();\n                robot.turnRight();\n            }\n            robot.turnRight();\n        }\n    }\n}"
    }
  },
  "490": {
    "solution": {
      "matrix": "class Solution {\n\n  private static final int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n  public boolean hasPath(int[][] maze, int[] start, int[] destination) {\n    boolean[][] seen = new boolean[maze.length][maze[0].length];\n    return dfs(maze, seen, start[0], start[1], destination);\n  }\n\n  private boolean dfs(int[][] maze, boolean[][] seen, int i, int j, int[] destination) {\n    if (i == destination[0] && j == destination[1])\n      return true;\n    if (seen[i][j])\n      return false;\n\n    seen[i][j] = true;\n\n    for (int[] dir : dirs) {\n      int x = i;\n      int y = j;\n      while (isValid(maze, x + dir[0], y + dir[1])) {\n        x += dir[0];\n        y += dir[1];\n      }\n      if (dfs(maze, seen, x, y, destination))\n        return true;\n    }\n\n    return false;\n  }\n\n  private boolean isValid(int[][] maze, int x, int y) {\n    return 0 <= x && x < maze.length && 0 <= y && y < maze[0].length && maze[x][y] == 0;\n  }\n}"
    }
  },
  "491": {
    "solution": {
      "backtracking": "class Solution {\n    public List<List<Integer>> findSubsequences(int[] nums) {\n        List<List<Integer>> result = new ArrayList<>();\n        backtrack(result, new ArrayList<>(), nums, 0);\n        return result;\n    }\n\n    private void backtrack(List<List<Integer>> result, List<Integer> sequence, int[] nums, int index) {\n        if (sequence.size() >= 2) {\n            result.add(new ArrayList<>(sequence)); // Store valid sequence\n        }\n        Set<Integer> used = new HashSet<>(); // Avoid duplicates at this level\n        \n        for (int i = index; i < nums.length; i++) {\n            if (!sequence.isEmpty() && nums[i] < sequence.get(sequence.size() - 1)) {\n                continue; // Maintain non-decreasing order\n            }\n            if (used.contains(nums[i])) {\n                continue; // Skip duplicates\n            }\n            used.add(nums[i]);\n            sequence.add(nums[i]);\n            backtrack(result, sequence, nums, i + 1);\n            sequence.remove(sequence.size() - 1); // Undo choice\n        }\n    }\n}"
    }
  },
  "492": {
    "solution": {
      "math": "class Solution {\n    public int[] constructRectangle(int area) {\n        int width = (int) Math.sqrt(area); // Start from the closest square root\n        while (area % width != 0) { // Find the largest factor  sqrt(area)\n            width--;\n        }\n        int length = area / width; // Compute corresponding length\n        return new int[]{length, width};\n    }\n}"
    }
  },
  "493": {
    "solution": {
      "merge-sort": "class Solution {\n    public int reversePairs(int[] nums) {\n        return mergeSortAndCount(nums, 0, nums.length - 1);\n    }\n    \n    private int mergeSortAndCount(int[] nums, int left, int right) {\n        if (left >= right) return 0;\n        \n        int mid = left + (right - left) / 2;\n        int count = mergeSortAndCount(nums, left, mid) + mergeSortAndCount(nums, mid + 1, right);\n        count += mergeAndCount(nums, left, mid, right);\n        \n        return count;\n    }\n    \n    private int mergeAndCount(int[] nums, int left, int mid, int right) {\n        int count = 0;\n        int[] merged = new int[right - left + 1];\n        int i = left, j = mid + 1, k = 0;\n        \n        while (i <= mid && j <= right) {\n            if ((long) nums[i] > 2 * (long) nums[j]) {\n                count += (mid - i + 1);\n                j++;\n            } else {\n                i++;\n            }\n        }\n        \n        i = left; j = mid + 1;\n        while (i <= mid && j <= right) {\n            if (nums[i] <= nums[j]) {\n                merged[k++] = nums[i++];\n            } else {\n                merged[k++] = nums[j++];\n            }\n        }\n        \n        while (i <= mid) {\n            merged[k++] = nums[i++];\n        }\n        \n        while (j <= right) {\n            merged[k++] = nums[j++];\n        }\n        \n        System.arraycopy(merged, 0, nums, left, merged.length);\n        \n        return count;\n    }\n}\n"
    }
  },
  "494": {
    "solution": {
      "dynamic-programming": "",
      "backtracking": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int findTargetSumWays(int[] nums, int target) {\n        return dfs(nums, 0, 0, target, new HashMap<>());\n    }\n\n    private int dfs(int[] nums, int index, int currentSum, int target, Map<String, Integer> memo) {\n        if (index == nums.length) {\n            return currentSum == target ? 1 : 0;\n        }        \n        String key = index + \",\" + currentSum;\n        if (memo.containsKey(key)) {\n            return memo.get(key);\n        }        \n        int add = dfs(nums, index + 1, currentSum + nums[index], target, memo);\n        int subtract = dfs(nums, index + 1, currentSum - nums[index], target, memo);        \n        memo.put(key, add + subtract);\n        return add + subtract;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1, 1, 1};\n        int target = 3;\n        System.out.println(solution.findTargetSumWays(nums, target));  // Output: 5\n    }\n}\n"
    }
  },
  "495": {
    "solution": {
      "array": "class Solution {\n    public int findPoisonedDuration(int[] timeSeries, int duration) {\n        if (timeSeries.length == 0) return 0;\n\n        int totalDuration = 0;\n        for (int i = 1; i < timeSeries.length; i++) {\n            totalDuration += Math.min(duration, timeSeries[i] - timeSeries[i - 1]);\n        }\n\n        return totalDuration + duration; // Add last attack's full duration\n    }\n}"
    }
  },
  "496": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n        Map<Integer, Integer> map = new HashMap<>();\n        int m = nums1.length;\n        int n = nums2.length;\n        int[] nums = nextGreaterElement(nums2);\n\n        for (int i = 0; i < n; i++) {\n            map.put(nums2[i], nums[i]);\n        }\n\n        int[] result = new int[m];\n\n        for (int i = 0; i < m; i++) {\n            result[i] = map.get(nums1[i]);\n        }\n\n        return result;\n    }\n\n    public int[] nextGreaterElement(int[] nums) {\n        int[] result = new int[nums.length];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = nums.length - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i]) {\n                stack.pop();\n            }\n            result[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i]);\n        }\n\n        return result;\n    }\n\n}\n\n// class Solution {\n//     public int[] nextGreaterElement(int[] nums1, int[] nums2) {\n//         Map<Integer, Integer> map = new HashMap<>();\n//         Stack<Integer> stack = new Stack<>();\n//         for (int num : nums2) {\n//             while (!stack.isEmpty() && stack.peek() < num) {\n//                 map.put(stack.pop(), num);\n//             }\n//             stack.push(num);\n//         }\n//         for (int i = 0; i < nums1.length; i++) {\n//             nums1[i] = map.getOrDefault(nums1[i], -1);\n//         }\n//         return nums1;\n//     }\n// }"
    }
  },
  "497": {
    "solution": {
      "reservoir-sampling": "import java.util.Random;\nimport java.util.TreeMap;\n\npublic class Solution {\n    private int[][] rects;\n    private Random rand;\n    private TreeMap<Integer, Integer> areaMap;\n    private int totalPoints;\n\n    public Solution(int[][] rects) {\n        this.rects = rects;\n        this.rand = new Random();\n        this.areaMap = new TreeMap<>();\n        this.totalPoints = 0;\n\n        // Calculate the cumulative number of points for each rectangle\n        for (int i = 0; i < rects.length; i++) {\n            int[] rect = rects[i];\n            int area = (rect[2] - rect[0] + 1) * (rect[3] - rect[1] + 1);\n            totalPoints += area;\n            areaMap.put(totalPoints, i);\n        }\n    }\n\n    public int[] pick() {\n        int randomPoint = rand.nextInt(totalPoints) + 1;\n        int rectIndex = areaMap.ceilingEntry(randomPoint).getValue();\n        int[] rect = rects[rectIndex];\n\n        int x = rect[0] + rand.nextInt(rect[2] - rect[0] + 1);\n        int y = rect[1] + rand.nextInt(rect[3] - rect[1] + 1);\n\n        return new int[] { x, y };\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(rects);\n * int[] param_1 = obj.pick();\n */"
    }
  },
  "498": {
    "solution": {
      "matrix": "public class Solution {\n    private static final int[][] DIAGONAL_DIRECTIONS = {{-1, 1}, {1, -1}};\n    \n    public int[] findDiagonalOrder(int[][] matrix) {\n        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {\n            return new int[0]; \n        }\n        \n        int m = matrix.length;   \n        int n = matrix[0].length;\n        int[] result = new int[m * n]; \n        \n        int r = 0, c = 0;\n        int direction = 0;\n        \n        for (int i = 0; i < m * n; i++) {\n            result[i] = matrix[r][c]; \n            int newR = r + DIAGONAL_DIRECTIONS[direction][0];\n            int newC = c + DIAGONAL_DIRECTIONS[direction][1];\n            \n            if (newR < 0 || newR >= m || newC < 0 || newC >= n) {\n                if (direction == 0) { \n                    if (c == n - 1) {\n                        r++;\n                    } else {\n                        c++; \n                    }\n                } else { \n                    if (r == m - 1) {\n                        c++;\n                    } else {\n                        r++;\n                    }\n                }\n                direction = 1 - direction;\n            } else {\n                r = newR;\n                c = newC;\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[][] matrix = {\n            { 1, 2, 3 },\n            { 4, 5, 6 },\n            { 7, 8, 9 }\n        };\n        \n        int[] result = solution.findDiagonalOrder(matrix);\n        \n        for (int val : result) {\n            System.out.print(val + \" \");\n        }\n    }\n}\n"
    }
  },
  "499": {
    "solution": {
      "matrix": "class Solution {\n    public String findShortestWay(int[][] maze, int[] ball, int[] hole) {\n        int m = maze.length;\n        int n = maze[0].length;\n        int r = ball[0], c = ball[1];\n        int rh = hole[0], ch = hole[1];\n        Deque<int[]> q = new LinkedList<>();\n        q.offer(new int[] {r, c});\n        int[][] dist = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE);\n        }\n        dist[r][c] = 0;\n        String[][] path = new String[m][n];\n        path[r][c] = \"\";\n        int[][] dirs = { {-1, 0, 'u'}, {1, 0, 'd'}, {0, -1, 'l'}, {0, 1, 'r'} };\n        while (!q.isEmpty()) {\n            int[] p = q.poll();\n            int i = p[0], j = p[1];\n            for (int[] dir : dirs) {\n                int a = dir[0], b = dir[1];\n                String d = String.valueOf((char) (dir[2]));\n                int x = i, y = j;\n                int step = dist[i][j];\n                while (x + a >= 0 && x + a < m && y + b >= 0 && y + b < n && maze[x + a][y + b] == 0\n                    && (x != rh || y != ch)) {\n                    x += a;\n                    y += b;\n                    ++step;\n                }\n                if (dist[x][y] > step\n                    || (dist[x][y] == step && (path[i][j] + d).compareTo(path[x][y]) < 0)) {\n                    dist[x][y] = step;\n                    path[x][y] = path[i][j] + d;\n                    if (x != rh || y != ch) {\n                        q.offer(new int[] {x, y});\n                    }\n                }\n            }\n        }\n        return path[rh][ch] == null ? \"impossible\" : path[rh][ch];\n    }\n}\n"
    }
  },
  "500": {
    "solution": {
      "hash-table": "class Solution {\n    public String[] findWords(String[] words) {\n        String row1 = \"qwertyuiop\";\n        String row2 = \"asdfghjkl\";\n        String row3 = \"zxcvbnm\";\n\n        List<String> result = new ArrayList<>();\n        \n        for (String word : words) {\n            String lower = word.toLowerCase();\n            if (isInRow(lower, row1) || isInRow(lower, row2) || isInRow(lower, row3)) {\n                result.add(word);\n            }\n        }\n\n        return result.toArray(new String[0]);\n    }\n\n    private boolean isInRow(String word, String row) {\n        for (char c : word.toCharArray()) {\n            if (row.indexOf(c) == -1) return false;\n        }\n        return true;\n    }\n}"
    }
  },
  "501": {
    "solution": {
      "binary-search-tree": "import java.util.*;\n\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int maxCount;\n    private int currentCount;\n    private int currentVal;\n    private List<Integer> modes;\n\n    public int[] findMode(TreeNode root) {\n        if (root == null) {\n            return new int[0];\n        }\n\n        maxCount = 0;\n        currentCount = 0;\n        currentVal = Integer.MIN_VALUE;\n        modes = new ArrayList<>();\n\n        traverse(root);\n\n        int[] result = new int[modes.size()];\n        for (int i = 0; i < modes.size(); i++) {\n            result[i] = modes.get(i);\n        }\n\n        return result;\n    }\n\n    private void traverse(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n\n        traverse(node.left);\n\n        handleValue(node.val);\n\n        traverse(node.right);\n    }\n\n    private void handleValue(int val) {\n        if (val != currentVal) {\n            currentVal = val;\n            currentCount = 0;\n        }\n\n        currentCount++;\n\n        if (currentCount > maxCount) {\n            maxCount = currentCount;\n            modes.clear();\n            modes.add(currentVal);\n        } else if (currentCount == maxCount) {\n            modes.add(currentVal);\n        }\n    }\n}\n"
    }
  },
  "502": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int findMaximizedCapital(int k, int w, int[] profits, int[] capital) {\n        int n = profits.length;\n        int[][] projects = new int[n][2];\n\n        for (int i = 0; i < n; i++) {\n            projects[i][0] = capital[i];\n            projects[i][1] = profits[i];\n        }\n\n        Arrays.sort(projects, (a, b) -> a[0] - b[0]);\n\n        PriorityQueue<Integer> maxProfit = new PriorityQueue<>(Collections.reverseOrder());\n        int i = 0;\n\n        for (int j = 0; j < k; j++) {\n            while (i < n && projects[i][0] <= w) {\n                maxProfit.add(projects[i][1]);\n                i++;\n            }\n            if (maxProfit.isEmpty()) break;\n            w += maxProfit.poll();\n        }\n\n        return w;\n    }\n}"
    }
  },
  "503": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int[] nextGreaterElements(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 2 * n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && stack.peek() <= nums[i % n]) {\n                stack.pop();\n            }\n            result[i % n] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(nums[i % n]);\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "504": {
    "solution": {
      "math": "class Solution {\n    public String convertToBase7(int num) {\n        if (num == 0) return \"0\";\n        boolean isNegative = num < 0;\n        num = Math.abs(num);\n\n        StringBuilder sb = new StringBuilder();\n        while (num > 0) {\n            sb.append(num % 7);\n            num /= 7;\n        }\n\n        if (isNegative) sb.append('-');\n        return sb.reverse().toString();\n    }\n}"
    }
  },
  "505": {
    "solution": {
      "matrix": "class Solution {\n  public int shortestDistance(int[][] maze, int[] start, int[] destination) {\n    int[][] dirs = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    int m = maze.length;\n    int n = maze[0].length;\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(start[0], start[1])));\n    int[][] dist = new int[maze.length][maze[0].length];\n    Arrays.stream(dist).forEach(A -> Arrays.fill(A, Integer.MAX_VALUE));\n    dist[start[0]][start[1]] = 0;\n\n    while (!q.isEmpty()) {\n      int i = q.peek().getKey();\n      int j = q.poll().getValue();\n      for (int[] dir : dirs) {\n        int x = i;\n        int y = j;\n        int step = dist[i][j];\n        while (isValid(maze, x + dir[0], y + dir[1])) {\n          x += dir[0];\n          y += dir[1];\n          ++step;\n        }\n        if (step < dist[x][y]) {\n          dist[x][y] = step;\n          q.offer(new Pair<>(x, y));\n        }\n      }\n    }\n\n    return dist[destination[0]][destination[1]] == Integer.MAX_VALUE\n        ? -1\n        : dist[destination[0]][destination[1]];\n  }\n\n  private boolean isValid(int[][] maze, int x, int y) {\n    return x >= 0 && x < maze.length && y >= 0 && y < maze[0].length && maze[x][y] == 0;\n  }\n}"
    }
  },
  "506": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "507": {
    "solution": {
      "math": "class Solution {\n    public boolean checkPerfectNumber(int num) {\n        if (num <= 1) return false;\n\n        int sum = 1;\n        for (int i = 2; i * i <= num; i++) {\n            if (num % i == 0) {\n                sum += i;\n                if (i != num / i) {\n                    sum += num / i;\n                }\n            }\n        }\n\n        return sum == num;\n    }\n}"
    }
  },
  "508": {
    "solution": {
      "binary-tree": "import java.util.*;\n\nclass Solution {\n    public int[] findFrequentTreeSum(TreeNode root) {\n        Map<Integer, Integer> sumCount = new HashMap<>();\n        int[] maxFreq = new int[1];\n        postOrder(root, sumCount, maxFreq);\n\n        List<Integer> result = new ArrayList<>();\n        for (Map.Entry<Integer, Integer> entry : sumCount.entrySet()) {\n            if (entry.getValue() == maxFreq[0]) {\n                result.add(entry.getKey());\n            }\n        }\n\n        return result.stream().mapToInt(i -> i).toArray();\n    }\n\n    private int postOrder(TreeNode node, Map<Integer, Integer> sumCount, int[] maxFreq) {\n        if (node == null) return 0;\n        int left = postOrder(node.left, sumCount, maxFreq);\n        int right = postOrder(node.right, sumCount, maxFreq);\n        int sum = node.val + left + right;\n        sumCount.put(sum, sumCount.getOrDefault(sum, 0) + 1);\n        maxFreq[0] = Math.max(maxFreq[0], sumCount.get(sum));\n        return sum;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}"
    }
  },
  "509": {
    "solution": {
      "memoization": "import java.util.*;\n\nclass Solution {\n    public int fib(int n) {\n        int[] memo = new int[n + 1];\n        Arrays.fill(memo, -1);\n        return fibHelper(n, memo);\n    }\n\n    private int fibHelper(int n, int[] memo) {\n        if (n <= 1) return n;\n        if (memo[n] != -1) return memo[n];\n        memo[n] = fibHelper(n - 1, memo) + fibHelper(n - 2, memo);\n        return memo[n];\n    }\n}"
    }
  },
  "510": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "511": {
    "solution": {
      "database": ""
    }
  },
  "512": {
    "solution": {
      "database": ""
    }
  },
  "513": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public int findBottomLeftValue(TreeNode root) {\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int bottomLeft = root.val;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (i == 0) {\n                    bottomLeft = node.val; // First node of the level\n                }\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n        }\n\n        return bottomLeft;\n    }\n}"
    }
  },
  "514": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "515": {
    "solution": {
      "binary-tree": "class Solution {\n    public List<Integer> largestValues(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) return result;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            int max = Integer.MIN_VALUE;\n\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                max = Math.max(max, node.val);\n\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n\n            result.add(max);\n        }\n        return result;\n    }\n}"
    }
  },
  "516": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int longestPalindromeSubseq(String s) {\n        int n = s.length();\n        int[][] dp = new int[n][n];\n\n        // Single characters are palindromes of length 1\n        for (int i = 0; i < n; i++) {\n            dp[i][i] = 1;\n        }\n\n        for (int len = 2; len <= n; len++) {\n            for (int i = 0; i <= n - len; i++) {\n                int j = i + len - 1;\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = 2 + dp[i + 1][j - 1];\n                } else {\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n            }\n        }\n\n        return dp[0][n - 1];\n    }\n}"
    }
  },
  "517": {
    "solution": {
      "greedy": "class Solution {\n public:\n  int findMinMoves(vector<int>& machines) {\n    const int dresses = accumulate(machines.begin(), machines.end(), 0);\n    if (dresses % machines.size() != 0)\n      return -1;\n\n    int ans = 0;\n    int inout = 0;\n    const int average = dresses / machines.size();\n\n    for (const int dress : machines) {\n      inout += dress - average;\n      ans = max({ans, abs(inout), dress - average});\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "518": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "519": {
    "solution": {
      "reservoir-sampling": "import java.util.HashMap;\nimport java.util.Map;\nimport java.util.Random;\n\npublic class Solution {\n    private int m, n, totalCells;\n    private Map<Integer, Integer> map;\n    private Random rand;\n\n    public Solution(int m, int n) {\n        this.m = m;\n        this.n = n;\n        this.totalCells = m * n;\n        this.map = new HashMap<>();\n        this.rand = new Random();\n    }\n\n    public int[] flip() {\n        int randomCell = rand.nextInt(totalCells);\n        totalCells--;\n\n        // Use map to get the actual position or the random position\n        int position = map.getOrDefault(randomCell, randomCell);\n\n        // Map the selected position to the last available cell position\n        map.put(randomCell, map.getOrDefault(totalCells, totalCells));\n\n        return new int[]{position / n, position % n};\n    }\n\n    public void reset() {\n        map.clear();\n        totalCells = m * n;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(m, n);\n * int[] param_1 = obj.flip();\n * obj.reset();\n */"
    }
  },
  "520": {
    "solution": {
      "string": "class Solution {\n    public boolean detectCapitalUse(String word) {\n        return word.equals(word.toUpperCase()) ||\n               word.equals(word.toLowerCase()) ||\n               (Character.isUpperCase(word.charAt(0)) && word.substring(1).equals(word.substring(1).toLowerCase()));\n    }\n}"
    }
  },
  "521": {
    "solution": {
      "string": "class Solution {\n    public int findLUSlength(String a, String b) {\n        if (a.equals(b)) return -1;\n        return Math.max(a.length(), b.length());\n    }\n}"
    }
  },
  "522": {
    "solution": {
      "hash-table": "class Solution {\n    public int findLUSlength(String[] strs) {\n        int res = -1;\n        for (int i = 0; i < strs.length; ++i) {\n            boolean isSubsequence = false;\n            for (int j = 0; j < strs.length; ++j) {\n                if (i == j) continue;\n                if (isSubsequence(strs[i], strs[j])) {\n                    isSubsequence = true;\n                    break;\n                }\n            }\n            if (!isSubsequence) {\n                res = Math.max(res, strs[i].length());\n            }\n        }\n        return res;\n    }\n\n    private boolean isSubsequence(String a, String b) {\n        int i = 0, j = 0;\n        while (i < a.length() && j < b.length()) {\n            if (a.charAt(i) == b.charAt(j)) i++;\n            j++;\n        }\n        return i == a.length();\n    }\n}"
    }
  },
  "523": {
    "solution": {
      "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public boolean checkSubarraySum(int[] nums, int k) {\n        HashMap<Integer, Integer> remainderMap = new HashMap<>();\n        remainderMap.put(0, -1); // Base case: remainder 0 at index -1\n        \n        int prefixSum = 0;\n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += nums[i];\n            \n            // Compute remainder\n            int remainder = k == 0 ? prefixSum : (prefixSum % k + k) % k; // Handle negative remainders\n            \n            // Check if the remainder is already seen\n            if (remainderMap.containsKey(remainder)) {\n                // Ensure subarray length is at least 2\n                if (i - remainderMap.get(remainder) > 1) {\n                    return true;\n                }\n            } else {\n                remainderMap.put(remainder, i);\n            }\n        }\n        \n        return false;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {23, 2, 4, 6, 7};\n        int k = 6;\n        System.out.println(solution.checkSubarraySum(nums, k)); // Output: true\n    }\n}\n"
    }
  },
  "524": {
    "solution": {
      "two-pointers": ""
    }
  },
  "525": {
    "solution": {
      "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int findMaxLength(int[] nums) {\n        HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n        \n        // Initialize with the base case: sum 0 at index -1\n        prefixSumMap.put(0, -1);\n        \n        int prefixSum = 0;\n        int maxLength = 0;\n        \n        for (int i = 0; i < nums.length; i++) {\n            prefixSum += (nums[i] == 1) ? 1 : -1;\n            \n            if (prefixSumMap.containsKey(prefixSum)) {\n                maxLength = Math.max(maxLength, i - prefixSumMap.get(prefixSum));\n            } else {\n                prefixSumMap.put(prefixSum, i);\n            }\n        }\n        \n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {0, 1, 0, 1, 1, 0};\n        System.out.println(solution.findMaxLength(nums)); // Output: 6\n    }\n}\n"
    }
  },
  "526": {
    "solution": {
      "backtracking": "class Solution {\n    private int count = 0;\n\n    public int countArrangement(int n) {\n        boolean[] used = new boolean[n + 1];\n        backtrack(n, 1, used);\n        return count;\n    }\n\n    private void backtrack(int n, int pos, boolean[] used) {\n        if (pos > n) {\n            count++;\n            return;\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (!used[i] && (i % pos == 0 || pos % i == 0)) {\n                used[i] = true;\n                backtrack(n, pos + 1, used);\n                used[i] = false;\n            }\n        }\n    }\n}"
    }
  },
  "527": {
    "solution": {
      "greedy": "class Solution {\n public:\n  vector<string> wordsAbbreviation(vector<string>& words) {\n    const int n = words.size();\n    vector<string> ans;\n    // prefix[i] := ans[i] takes words[i][0..prefix[i]]\n    vector<int> prefix(n);\n\n    for (const string& word : words)\n      ans.push_back(getAbbrev(word, 0));\n\n    for (int i = 0; i < n; ++i) {\n      while (true) {\n        vector<int> dupeIndices;\n        for (int j = i + 1; j < n; ++j)\n          if (ans[i] == ans[j])\n            dupeIndices.push_back(j);\n        if (dupeIndices.empty())\n          break;\n        dupeIndices.push_back(i);\n        for (const int index : dupeIndices)\n          ans[index] = getAbbrev(words[index], ++prefix[index]);\n      }\n    }\n\n    return ans;\n  }\n\n private:\n  string getAbbrev(const string& s, int prefixIndex) {\n    const int n = s.length();\n    const int num = n - (prefixIndex + 1) - 1;\n    const int numLength = num < 10 ? 1 : num < 100 ? 2 : 3;\n    const int abbrevLength = (prefixIndex + 1) + numLength + 1;\n    if (abbrevLength >= n)\n      return s;\n    return s.substr(0, prefixIndex + 1) + to_string(num) + s.back();\n  }\n};"
    }
  },
  "528": {
    "solution": {
      "randomized": "import java.util.Random;\nimport java.util.TreeMap;\n\nclass Solution {\n    private int[] prefixSums;\n    private int totalSum;\n    private Random rand;\n\n    public Solution(int[] w) {\n        prefixSums = new int[w.length];\n        prefixSums[0] = w[0];\n        for (int i = 1; i < w.length; i++) {\n            prefixSums[i] = prefixSums[i - 1] + w[i];\n        }\n        totalSum = prefixSums[prefixSums.length - 1];\n        rand = new Random();\n    }\n\n    public int pickIndex() {\n        int target = rand.nextInt(totalSum) + 1;\n        int low = 0, high = prefixSums.length - 1;\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n            if (prefixSums[mid] < target) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n        return low;\n    }\n}\n\n/**\n * Your Solution object will be instantiated and called as such:\n * Solution obj = new Solution(w);\n * int param_1 = obj.pickIndex();\n */"
    }
  },
  "529": {
    "solution": {
      "matrix": "class Solution {\n\n  private static final int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1},\n                                       {0, 1},   {1, -1}, {1, 0},  {1, 1}};\n\n  public char[][] updateBoard(char[][] board, int[] click) {\n    int i = click[0];\n    int j = click[1];\n    if (board[i][j] == 'M') {\n      board[i][j] = 'X';\n      return board;\n    }\n\n    dfs(board, i, j);\n    return board;\n  }\n\n  private void dfs(char[][] board, int i, int j) {\n    if (i < 0 || i == board.length || j < 0 || j == board[0].length)\n      return;\n    if (board[i][j] != 'E')\n      return;\n\n    int minesCount = getMinesCount(board, i, j);\n    board[i][j] = minesCount == 0 ? 'B' : (char) ('0' + minesCount);\n\n    if (minesCount == 0)\n      for (int[] dir : dirs)\n        dfs(board, i + dir[0], j + dir[1]);\n  }\n\n  private int getMinesCount(char[][] board, int i, int j) {\n    int minesCount = 0;\n    for (int[] dir : dirs) {\n      int x = i + dir[0];\n      int y = j + dir[1];\n      if (x < 0 || x == board.length || y < 0 || y == board[0].length)\n        continue;\n      if (board[x][y] == 'M')\n        ++minesCount;\n    }\n    return minesCount;\n  }\n}"
    }
  },
  "530": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int minDiff;\n    private Integer prev;\n\n    public int getMinimumDifference(TreeNode root) {\n        minDiff = Integer.MAX_VALUE;\n        prev = null;\n        inorder(root);\n        return minDiff;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        if (prev != null) {\n            minDiff = Math.min(minDiff, node.val - prev);\n        }\n        prev = node.val;\n        inorder(node.right);\n    }\n}\n"
    }
  },
  "531": {
    "solution": {
      "matrix": ""
    }
  },
  "532": {
    "solution": {
      "two-pointers": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Solution {\n    public int findPairs(int[] nums, int k) {\n        if (nums == null || nums.length < 2 || k < 0) {\n            return 0;\n        }\n\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        Set<Integer> countedPairs = new HashSet<>();\n        int count = 0;\n\n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        for (int num : nums) {\n            if (frequencyMap.containsKey(num + k) && !countedPairs.contains(num)) {\n                if (k == 0) {\n                    if (frequencyMap.get(num) > 1) {\n                        count++;\n                        countedPairs.add(num);\n                    }\n                } else {\n                    count++;\n                    countedPairs.add(num);\n                }\n            }\n        }\n\n        return count;\n    }\n}\n"
    }
  },
  "533": {
    "solution": {
      "matrix": "class Solution {\n    public int findBlackPixel(char[][] picture, int target) {\n        int m = picture.length, n = picture[0].length;\n        int[] rowCount = new int[m];\n        int[] colCount = new int[n];\n        Map<String, Integer> rowMap = new HashMap<>();\n\n        for (int i = 0; i < m; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (int j = 0; j < n; j++) {\n                if (picture[i][j] == 'B') {\n                    rowCount[i]++;\n                    colCount[j]++;\n                }\n                sb.append(picture[i][j]);\n            }\n            rowMap.put(sb.toString(), rowMap.getOrDefault(sb.toString(), 0) + 1);\n        }\n\n        int result = 0;\n        for (Map.Entry<String, Integer> entry : rowMap.entrySet()) {\n            String rowStr = entry.getKey();\n            int count = entry.getValue();\n            if (count != target) continue;\n\n            for (int j = 0; j < n; j++) {\n                if (rowStr.charAt(j) == 'B' && colCount[j] == target) {\n                    boolean valid = true;\n                    for (int i = 0; i < m; i++) {\n                        if (picture[i][j] == 'B' && !rowStr.equals(new String(picture[i]))) {\n                            valid = false;\n                            break;\n                        }\n                    }\n                    if (valid) result += target;\n                }\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "534": {
    "solution": {
      "database": ""
    }
  },
  "535": {
    "solution": {
      "hash-function": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Codec {\n    private static final String BASE_URL = \"http://tinyurl.com/\";\n    private Map<String, String> shortToLongMap = new HashMap<>();\n    private Map<String, String> longToShortMap = new HashMap<>();\n    \n    private String getHash(String url) {\n        return Integer.toHexString(url.hashCode());\n    }\n\n    public String encode(String longUrl) {\n        if (longToShortMap.containsKey(longUrl)) {\n            return BASE_URL + longToShortMap.get(longUrl);\n        }\n\n        String shortKey = getHash(longUrl);\n        while (shortToLongMap.containsKey(shortKey)) {\n            longUrl += \" \";\n            shortKey = getHash(longUrl);\n        }\n        \n        shortToLongMap.put(shortKey, longUrl);\n        longToShortMap.put(longUrl, shortKey);\n        \n        return BASE_URL + shortKey;\n    }\n\n    public String decode(String shortUrl) {\n        String shortKey = shortUrl.replace(BASE_URL, \"\");\n        return shortToLongMap.get(shortKey);\n    }\n\n}\n"
    }
  },
  "536": {
    "solution": {
      "stack": ""
    }
  },
  "537": {
    "solution": {
      "math": ""
    }
  },
  "538": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "539": {
    "solution": {
      "sorting": ""
    }
  },
  "540": {
    "solution": {
      "array": ""
    }
  },
  "541": {
    "solution": {
      "two-pointers": ""
    }
  },
  "542": {
    "solution": {
      "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] updateMatrix(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n        int[][] distances = new int[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 1) {\n                    distances[i][j] = Integer.MAX_VALUE;\n                }\n            }\n        }\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (matrix[i][j] == 0) {\n                    dfs(matrix, distances, i, j);\n                }\n            }\n        }\n\n        return distances;\n    }\n\n    private void dfs(int[][] matrix, int[][] distances, int row, int col) {\n        for (int[] dir : DIRECTIONS) {\n            int newRow = row + dir[0];\n            int newCol = col + dir[1];\n\n            if (newRow >= 0 && newRow < matrix.length && newCol >= 0 && newCol < matrix[0].length) {\n                if (distances[newRow][newCol] > distances[row][col] + 1) {\n                    distances[newRow][newCol] = distances[row][col] + 1;\n                    dfs(matrix, distances, newRow, newCol);\n                }\n            }\n        }\n    }\n}\n"
    }
  },
  "543": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int diameter = 0;\n    public int diameterOfBinaryTree(TreeNode root) {\n        dfs(root);\n        return diameter;\n    }\n\n    private int dfs(TreeNode node) {\n        if (node == null)\n            return 0;\n\n        int leftDepth = dfs(node.left);\n        int rightDepth = dfs(node.right);\n\n        diameter = Math.max(diameter, leftDepth + rightDepth); \n\n        return Math.max(leftDepth, rightDepth) + 1;\n    }\n}"
    }
  },
  "544": {
    "solution": {
      "recursion": ""
    }
  },
  "545": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<Integer> res;\n\n    public List<Integer> boundaryOfBinaryTree(TreeNode root) {\n        if (root == null) {\n            return Collections.emptyList();\n        }\n        res = new ArrayList<>();\n\n        if (!isLeaf(root)) {\n            res.add(root.val);\n        }\n\n        TreeNode t = root.left;\n        while (t != null) {\n            if (!isLeaf(t)) {\n                res.add(t.val);\n            }\n            t = t.left == null ? t.right : t.left;\n        }\n\n        addLeaves(root);\n\n        Deque<Integer> s = new ArrayDeque<>();\n        t = root.right;\n        while (t != null) {\n            if (!isLeaf(t)) {\n                s.offer(t.val);\n            }\n            t = t.right == null ? t.left : t.right;\n        }\n        while (!s.isEmpty()) {\n            res.add(s.pollLast());\n        }\n\n        // output\n        return res;\n    }\n\n    private void addLeaves(TreeNode root) {\n        if (isLeaf(root)) {\n            res.add(root.val);\n            return;\n        }\n        if (root.left != null) {\n            addLeaves(root.left);\n        }\n        if (root.right != null) {\n            addLeaves(root.right);\n        }\n    }\n\n    private boolean isLeaf(TreeNode node) {\n        return node != null && node.left == null && node.right == null;\n    }\n}"
    }
  },
  "546": {
    "solution": {
      "memoization": "class Solution {\n    public int removeBoxes(int[] boxes) {\n        int n = boxes.length;\n        int[][][] dp = new int[n][n][n];\n        return helper(boxes, 0, n - 1, 0, dp);\n    }\n\n    private int helper(int[] boxes, int l, int r, int k, int[][][] dp) {\n        if (l > r) return 0;\n        if (dp[l][r][k] != 0) return dp[l][r][k];\n\n        while (l < r && boxes[r] == boxes[r - 1]) {\n            r--;\n            k++;\n        }\n\n        dp[l][r][k] = helper(boxes, l, r - 1, 0, dp) + (k + 1) * (k + 1);\n\n        for (int i = l; i < r; i++) {\n            if (boxes[i] == boxes[r]) {\n                dp[l][r][k] = Math.max(dp[l][r][k],\n                    helper(boxes, l, i, k + 1, dp) + helper(boxes, i + 1, r - 1, 0, dp));\n            }\n        }\n\n        return dp[l][r][k];\n    }\n}"
    }
  },
  "547": {
    "solution": {
      "union-find": "class UF {\n  public UF(int n) {\n    size = n;\n    id = new int[n];\n    for (int i = 0; i < n; ++i)\n      id[i] = i;\n  }\n\n  public void union(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return;\n    id[i] = j;\n    --size;\n  }\n\n  public int getSize() {\n    return size;\n  }\n\n  private int size;\n  private int[] id;\n\n  private int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  }\n}\n\nclass Solution {\n  public int findCircleNum(int[][] M) {\n    final int n = M.length;\n    UF uf = new UF(n);\n\n    for (int i = 0; i < n; ++i)\n      for (int j = i; j < n; ++j)\n        if (M[i][j] == 1)\n          uf.union(i, j);\n\n    return uf.getSize();\n  }\n}\n"
    }
  },
  "548": {
    "solution": {
      "prefix-sum": "class Solution {\n  public boolean splitArray(int[] nums) {\n    int n = nums.length;\n    if (n < 7)\n      return false;\n\n    int[] prefix = new int[n];\n\n    for (int i = 0; i < n; ++i)\n      prefix[i] = i == 0 ? nums[0] : prefix[i - 1] + nums[i];\n\n    for (int j = 3; j < n - 3; ++j) {\n      HashSet<Integer> seen = new HashSet<>();\n      for (int i = 1; i < j - 1; ++i)\n        if (prefix[i - 1] == prefix[j - 1] - prefix[i])\n          seen.add(prefix[i - 1]);\n      for (int k = j + 2; k < n - 1; ++k)\n        if (prefix[n - 1] - prefix[k] == prefix[k - 1] - prefix[j] &&\n            seen.contains(prefix[k - 1] - prefix[j]))\n          return true;\n    }\n\n    return false;\n  }\n}"
    }
  },
  "549": {
    "solution": {
      "tree": ""
    }
  },
  "550": {
    "solution": {
      "database": ""
    }
  },
  "551": {
    "solution": {
      "string": ""
    }
  },
  "552": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "553": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "554": {
    "solution": {
      "hash-table": ""
    }
  },
  "555": {
    "solution": {
      "greedy": ""
    }
  },
  "556": {
    "solution": {
      "two-pointers": "public class Solution {\n    public int nextGreaterElement(int n) {\n        char[] digits = Integer.toString(n).toCharArray();\n        int length = digits.length;\n\n        int left = length - 2;\n        while (left >= 0 && digits[left] >= digits[left + 1]) {\n            left--;\n        }\n\n        if (left == -1) {\n            return -1; \n        }\n\n        int right = length - 1;\n        while (digits[right] <= digits[left]) {\n            right--;\n        }\n\n        char temp = digits[left];\n        digits[left] = digits[right];\n        digits[right] = temp;\n\n        reverse(digits, left + 1, length - 1);\n        \n        try {\n            long result = Long.parseLong(new String(digits));\n            return (result <= Integer.MAX_VALUE) ? (int) result : -1;\n        } catch (NumberFormatException e) {\n            return -1;\n        }\n    }\n\n    private void reverse(char[] arr, int start, int end) {\n        while (start < end) {\n            char temp = arr[start];\n            arr[start] = arr[end];\n            arr[end] = temp;\n            start++;\n            end--;\n        }\n    }\n}\n"
    }
  },
  "557": {
    "solution": {
      "two-pointers": ""
    }
  },
  "558": {
    "solution": {
      "tree": ""
    }
  },
  "559": {
    "solution": {
      "tree": "class Solution {\n    public int maxDepth(Node root) {\n        if (root == null) return 0;\n        int depth = 0;\n        for (Node child : root.children) {\n            depth = Math.max(depth, maxDepth(child));\n        }\n        return depth + 1;\n    }\n}"
    }
  },
  "560": {
    "solution": {
      "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int subarraySum(int[] nums, int k) {\n        HashMap<Integer, Integer> prefixSumMap = new HashMap<>();\n        \n        // Initialize with the base case: prefix sum of 0 appears once\n        prefixSumMap.put(0, 1);\n        \n        int prefixSum = 0;  \n        int count = 0;      \n\n        for (int num : nums) {\n            prefixSum += num;\n            \n            if (prefixSumMap.containsKey(prefixSum - k)) {\n                count += prefixSumMap.get(prefixSum - k);\n            }\n            \n            prefixSumMap.put(prefixSum, prefixSumMap.getOrDefault(prefixSum, 0) + 1);\n        }\n        \n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1};\n        int k = 2;\n        System.out.println(solution.subarraySum(nums, k)); // Output: 2\n    }\n}\n"
    }
  },
  "561": {
    "solution": {
      "counting-sort": "class Solution {\n    public int arrayPairSum(int[] nums) {\n        int maxNum = 10000;\n        int[] count = new int[2 * maxNum + 1];\n\n        for (int num : nums) {\n            count[num + maxNum]++;\n        }\n\n        int sum = 0;\n        boolean add = true;\n        for (int i = 0; i < count.length; i++) {\n            while (count[i] > 0) {\n                if (add) {\n                    sum += i - maxNum;\n                }\n                add = !add;\n                count[i]--;\n            }\n        }\n\n        return sum;\n    }\n}\n"
    }
  },
  "562": {
    "solution": {
      "matrix": "class Solution {\n  public int longestLine(int[][] mat) {\n    final int m = mat.length;\n    final int n = mat[0].length;\n    int ans = 0;\n    // dp[i][j][0] := horizontal  Represents the length of the longest line of consecutive 1s ending at cell (i, j) horizontally.\n    // dp[i][j][1] := vertical\n    // dp[i][j][2] := diagonal\n    // dp[i][j][3] := anti-diagonal\n    int[][][] dp = new int[m][n][4];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        if (mat[i][j] == 1) {\n          dp[i][j][0] = j > 0 ? dp[i][j - 1][0] + 1 : 1;\n          dp[i][j][1] = i > 0 ? dp[i - 1][j][1] + 1 : 1;\n          dp[i][j][2] = (i > 0 && j > 0) ? dp[i - 1][j - 1][2] + 1 : 1;\n          dp[i][j][3] = (i > 0 && j < n - 1) ? dp[i - 1][j + 1][3] + 1 : 1;\n          for (int k = 0; k < 4; ++k)\n            ans = Math.max(ans, dp[i][j][k]);\n        }\n\n    return ans;\n  }\n}"
    }
  },
  "563": {
    "solution": {
      "depth-first-search": "class Solution {\n    private int totalTilt = 0;\n\n    public int findTilt(TreeNode root) {\n        postOrder(root);\n        return totalTilt;\n    }\n\n    private int postOrder(TreeNode node) {\n        if (node == null) return 0;\n\n        int left = postOrder(node.left);\n        int right = postOrder(node.right);\n        totalTilt += Math.abs(left - right);\n\n        return left + right + node.val;\n    }\n}"
    }
  },
  "564": {
    "solution": {
      "math": "class Solution {\n    public String nearestPalindromic(String n) {\n        long num = Long.parseLong(n);\n        Set<Long> candidates = new HashSet<>();\n        int len = n.length();\n\n        candidates.add((long)Math.pow(10, len) + 1);\n        candidates.add((long)Math.pow(10, len - 1) - 1);\n\n        long prefix = Long.parseLong(n.substring(0, (len + 1) / 2));\n        for (long i = prefix - 1; i <= prefix + 1; ++i) {\n            StringBuilder sb = new StringBuilder();\n            String pre = String.valueOf(i);\n            sb.append(pre);\n            String rev = new StringBuilder(pre.substring(0, len / 2)).reverse().toString();\n            sb.append(rev);\n            candidates.add(Long.parseLong(sb.toString()));\n        }\n\n        candidates.remove(num);\n        long minDiff = Long.MAX_VALUE, res = 0;\n        for (long candidate : candidates) {\n            long diff = Math.abs(candidate - num);\n            if (diff < minDiff || (diff == minDiff && candidate < res)) {\n                minDiff = diff;\n                res = candidate;\n            }\n        }\n        return String.valueOf(res);\n    }\n}"
    }
  },
  "565": {
    "solution": {
      "depth-first-search": ""
    }
  },
  "566": {
    "solution": {
      "matrix": "class Solution {\n  public int[][] matrixReshape(int[][] nums, int r, int c) {\n    if (nums.length == 0 || r * c != nums.length * nums[0].length)\n      return nums;\n\n    int[][] ans = new int[r][c];\n    int k = 0;\n\n    for (int[] row : nums)\n      for (int num : row) {\n        ans[k / c][k % c] = num;\n        ++k;\n      }\n\n    return ans;\n  }\n}"
    }
  },
  "567": {
    "solution": {
      "two-pointers": "",
      "sliding-window": "import java.util.Arrays;\n\npublic class Solution {\n    public boolean checkInclusion(String s1, String s2) {\n        if (s1.length() > s2.length()) {\n            return false;\n        }\n        \n        int[] countS1 = new int[26];\n        int[] countWindow = new int[26];        \n        for (char c : s1.toCharArray()) {\n            countS1[c - 'a']++;\n        }        \n        for (int i = 0; i < s1.length(); i++) {\n            countWindow[s2.charAt(i) - 'a']++;\n        }        \n        for (int i = 0; i <= s2.length() - s1.length(); i++) {\n            if (Arrays.equals(countS1, countWindow)) {\n                return true;\n            }            \n            if (i + s1.length() < s2.length()) {\n                countWindow[s2.charAt(i) - 'a']--;\n                countWindow[s2.charAt(i + s1.length()) - 'a']++;\n            }\n        }\n        \n        return false;\n    }\n}\n"
    }
  },
  "568": {
    "solution": {
      "matrix": ""
    }
  },
  "569": {
    "solution": {
      "database": "WITH\n    t AS (\n        SELECT\n            *,\n            ROW_NUMBER() OVER (\n                PARTITION BY company\n                ORDER BY salary ASC\n            ) AS rk,\n            COUNT(id) OVER (PARTITION BY company) AS n\n        FROM Employee\n    )\nSELECT\n    id,\n    company,\n    salary\nFROM t\nWHERE rk >= n / 2 AND rk <= n / 2 + 1;"
    }
  },
  "570": {
    "solution": {
      "database": ""
    }
  },
  "571": {
    "solution": {
      "database": "WITH\n    t AS (\n        SELECT\n            *,\n            SUM(frequency) OVER (ORDER BY num ASC) AS rk1,\n            SUM(frequency) OVER (ORDER BY num DESC) AS rk2,\n            SUM(frequency) OVER () AS s\n        FROM Numbers\n    )\nSELECT\n    ROUND(AVG(num), 1) AS median\nFROM t\nWHERE rk1 >= s / 2 AND rk2 >= s / 2;"
    }
  },
  "572": {
    "solution": {
      "depth-first-search": "class Solution {\n    public boolean isSubtree(TreeNode root, TreeNode subRoot) {\n        if (root == null) return false;\n        if (isSameTree(root, subRoot)) return true;\n        return isSubtree(root.left, subRoot) || isSubtree(root.right, subRoot);\n    }\n\n    private boolean isSameTree(TreeNode s, TreeNode t) {\n        if (s == null && t == null) return true;\n        if (s == null || t == null || s.val != t.val) return false;\n        return isSameTree(s.left, t.left) && isSameTree(s.right, t.right);\n    }\n}"
    }
  },
  "573": {
    "solution": {
      "math": ""
    }
  },
  "574": {
    "solution": {
      "database": ""
    }
  },
  "575": {
    "solution": {
      "hash-table": ""
    }
  },
  "576": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "577": {
    "solution": {
      "database": ""
    }
  },
  "578": {
    "solution": {
      "database": "WITH\n    T AS (\n        SELECT\n            question_id AS survey_log,\n            (SUM(action = 'answer') OVER (PARTITION BY question_id)) / (\n                SUM(action = 'show') OVER (PARTITION BY question_id)\n            ) AS ratio\n        FROM SurveyLog\n    )\nSELECT survey_log\nFROM T\nORDER BY ratio DESC, 1\nLIMIT 1;"
    }
  },
  "579": {
    "solution": {
      "database": "# Write your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            id,\n            month,\n            SUM(salary) OVER (\n                PARTITION BY id\n                ORDER BY month\n                RANGE 2 PRECEDING\n            ) AS salary,\n            RANK() OVER (\n                PARTITION BY id\n                ORDER BY month DESC\n            ) AS rk\n        FROM Employee\n    )\nSELECT id, month, salary\nFROM T\nWHERE rk > 1\nORDER BY 1, 2 DESC;"
    }
  },
  "580": {
    "solution": {
      "database": ""
    }
  },
  "581": {
    "solution": {
      "two-pointers": "public class Solution {\n    public int findUnsortedSubarray(int[] nums) {\n        int n = nums.length;\n        int left = 0, right = n - 1;\n        \n        while (left < n - 1 && nums[left] <= nums[left + 1]) {\n            left++;\n        }\n        \n        if (left == n - 1) {\n            return 0;\n        }\n        \n        while (right > 0 && nums[right] >= nums[right - 1]) {\n            right--;\n        }\n        \n        int subarrayMin = Integer.MAX_VALUE, subarrayMax = Integer.MIN_VALUE;\n        for (int i = left; i <= right; i++) {\n            subarrayMin = Math.min(subarrayMin, nums[i]);\n            subarrayMax = Math.max(subarrayMax, nums[i]);\n        }\n        \n        while (left > 0 && nums[left - 1] > subarrayMin) {\n            left--;\n        }\n        \n        while (right < n - 1 && nums[right + 1] < subarrayMax) {\n            right++;\n        }\n        \n        return right - left + 1;\n    }\n}\n"
    }
  },
  "582": {
    "solution": {
      "tree": ""
    }
  },
  "583": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "584": {
    "solution": {
      "database": ""
    }
  },
  "585": {
    "solution": {
      "database": ""
    }
  },
  "586": {
    "solution": {
      "database": ""
    }
  },
  "587": {
    "solution": {
      "geometry": "class Solution {\n    public int[][] outerTrees(int[][] trees) {\n        Arrays.sort(trees, (a, b) -> a[0] == b[0] ? a[1] - b[1] : a[0] - b[0]);\n        List<int[]> hull = new ArrayList<>();\n\n        for (int[] tree : trees) {\n            while (hull.size() >= 2 && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), tree) < 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(tree);\n        }\n\n        int t = hull.size() + 1;\n        for (int i = trees.length - 1; i >= 0; i--) {\n            int[] tree = trees[i];\n            while (hull.size() >= t && cross(hull.get(hull.size() - 2), hull.get(hull.size() - 1), tree) < 0) {\n                hull.remove(hull.size() - 1);\n            }\n            hull.add(tree);\n        }\n\n        Set<String> seen = new HashSet<>();\n        List<int[]> result = new ArrayList<>();\n        for (int[] p : hull) {\n            String key = p[0] + \",\" + p[1];\n            if (!seen.contains(key)) {\n                seen.add(key);\n                result.add(p);\n            }\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n\n    private int cross(int[] o, int[] a, int[] b) {\n        return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);\n    }\n}"
    }
  },
  "588": {
    "solution": {
      "trie": ""
    }
  },
  "589": {
    "solution": {
      "stack": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    public List<Integer> preorder(Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            result.add(node.val);\n            for (int i = node.children.size() - 1; i >= 0; i--) {\n                stack.push(node.children.get(i));\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "590": {
    "solution": {
      "stack": "/*\n// Definition for a Node.\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int _val) {\n        val = _val;\n    }\n\n    public Node(int _val, List<Node> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\n    public List<Integer> postorder(Node root) {\n        List<Integer> result = new ArrayList<>();\n        if (root == null) {\n            return result;\n        }\n\n        Stack<Node> stack = new Stack<>();\n        stack.push(root);\n\n        while (!stack.isEmpty()) {\n            Node node = stack.pop();\n            result.add(0, node.val);\n            for (Node child : node.children) {\n                stack.push(child);\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "591": {
    "solution": {
      "stack": ""
    }
  },
  "592": {
    "solution": {
      "math": ""
    }
  },
  "593": {
    "solution": {
      "geometry": ""
    }
  },
  "594": {
    "solution": {
      "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\npublic class Solution {\n    public int findLHS(int[] nums) {\n        Map<Integer, Integer> frequencyMap = new HashMap<>();\n        int maxLen = 0;\n        \n        for (int num : nums) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n        \n        for (int num : frequencyMap.keySet()) {\n            if (frequencyMap.containsKey(num + 1)) {\n                int currentLen = frequencyMap.get(num) + frequencyMap.get(num + 1);\n                maxLen = Math.max(maxLen, currentLen);\n            }\n        }\n        \n        return maxLen;\n    }\n}\n"
    }
  },
  "595": {
    "solution": {
      "database": ""
    }
  },
  "596": {
    "solution": {
      "database": ""
    }
  },
  "597": {
    "solution": {
      "database": ""
    }
  },
  "598": {
    "solution": {
      "math": "class Solution {\n public:\n  int maxCount(int m, int n, vector<vector<int>>& ops) {\n    int minY = m;\n    int minX = n;\n\n    for (const vector<int>& op : ops) {\n      minY = min(minY, op[0]);\n      minX = min(minX, op[1]);\n    }\n\n    return minX * minY;\n  }\n};"
    }
  },
  "599": {
    "solution": {
      "hash-table": ""
    }
  },
  "600": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "601": {
    "solution": {
      "database": "with cte\nas\n(select id,visit_date, people, id - row_number() over (order by id ) diff\n from stadium\nwhere people >=  100)\n\n\nselect id, visit_date, people from cte\nwhere diff in (\nselect diff from cte\n    group by diff\n    having count(*)>=3)\n    order by 2"
    }
  },
  "602": {
    "solution": {
      "database": ""
    }
  },
  "603": {
    "solution": {
      "database": "# Write your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            *,\n            SUM(free = 1) OVER (\n                ORDER BY seat_id\n                ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING\n            ) AS cnt\n        FROM Cinema\n    )\nSELECT seat_id\nFROM T\nWHERE free = 1 AND cnt > 1\nORDER BY 1;"
    }
  },
  "604": {
    "solution": {
      "iterator": "class StringIterator {\n    private List<Node> d = new ArrayList<>();\n    private int p;\n\n    public StringIterator(String compressedString) {\n        int n = compressedString.length();\n        int i = 0;\n        while (i < n) {\n            char c = compressedString.charAt(i);\n            int x = 0;\n            while (++i < n && Character.isDigit(compressedString.charAt(i))) {\n                x = x * 10 + (compressedString.charAt(i) - '0');\n            }\n            d.add(new Node(c, x));\n        }\n    }\n\n    public char next() {\n        if (!hasNext()) {\n            return ' ';\n        }\n        char ans = d.get(p).c;\n        if (--d.get(p).x == 0) {\n            ++p;\n        }\n        return ans;\n    }\n\n    public boolean hasNext() {\n        return p < d.size() && d.get(p).x > 0;\n    }\n}\n\nclass Node {\n    char c;\n    int x;\n\n    Node(char c, int x) {\n        this.c = c;\n        this.x = x;\n    }\n}\n\n/**\n * Your StringIterator object will be instantiated and called as such:\n * StringIterator obj = new StringIterator(compressedString);\n * char param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
    }
  },
  "605": {
    "solution": {
      "greedy": "class Solution {\n    public boolean canPlaceFlowers(int[] flowerbed, int n) {\n        if (n == 0) return true;\n\n        for (int i = 0; i < flowerbed.length; i++) {\n            if (flowerbed[i] == 0 &&\n                (i == 0 || flowerbed[i - 1] == 0) &&\n                (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) {\n                flowerbed[i] = 1;\n                n--;\n                if (n == 0) return true;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "606": {
    "solution": {
      "tree": ""
    }
  },
  "607": {
    "solution": {
      "database": ""
    }
  },
  "608": {
    "solution": {
      "database": ""
    }
  },
  "609": {
    "solution": {
      "hash-table": ""
    }
  },
  "610": {
    "solution": {
      "database": ""
    }
  },
  "611": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int triangleNumber(int[] nums) {\n        Arrays.sort(nums);\n        int count = 0;\n        for (int i = nums.length - 1; i >= 2; i--) {\n            int left = 0, right = i - 1;\n            while (left < right) {\n                if (nums[left] + nums[right] > nums[i]) {\n                    count += right - left;\n                    right--;\n                } else {\n                    left++;\n                }\n            }\n        }\n        return count;\n    }\n}\n"
    }
  },
  "612": {
    "solution": {
      "database": ""
    }
  },
  "613": {
    "solution": {
      "database": ""
    }
  },
  "614": {
    "solution": {
      "database": ""
    }
  },
  "615": {
    "solution": {
      "database": "WITH\n    S AS (\n        SELECT *\n        FROM\n            Salary\n            JOIN Employee USING (employee_id)\n    ),\n    T AS (\n        SELECT\n            DATE_FORMAT(pay_date, '%Y-%m') AS pay_month,\n            department_id,\n            AVG(amount) OVER (PARTITION BY pay_date, department_id) AS department_avg,\n            AVG(amount) OVER (PARTITION BY pay_date) AS company_avg\n        FROM S\n    )\nSELECT\n    pay_month,\n    department_id,\n    CASE\n        WHEN AVG(department_avg) > AVG(company_avg) THEN 'higher'\n        WHEN AVG(department_avg) < AVG(company_avg) THEN 'lower'\n        ELSE 'same'\n    END AS comparison\nFROM T\nGROUP BY 1, 2;"
    }
  },
  "616": {
    "solution": {
      "string-matching": ""
    }
  },
  "617": {
    "solution": {
      "binary-tree": "class Solution {\n    public TreeNode mergeTrees(TreeNode root1, TreeNode root2) {\n        if (root1 == null) return root2;\n        if (root2 == null) return root1;\n\n        root1.val += root2.val;\n        root1.left = mergeTrees(root1.left, root2.left);\n        root1.right = mergeTrees(root1.right, root2.right);\n\n        return root1;\n    }\n}"
    }
  },
  "618": {
    "solution": {
      "database": "WITH\n    T AS (\n        SELECT\n            *,\n            ROW_NUMBER() OVER (\n                PARTITION BY continent\n                ORDER BY name\n            ) AS rk\n        FROM Student\n    )\nSELECT\n    MAX(IF(continent = 'America', name, NULL)) AS 'America',\n    MAX(IF(continent = 'Asia', name, NULL)) AS 'Asia',\n    MAX(IF(continent = 'Europe', name, NULL)) AS 'Europe'\nFROM T\nGROUP BY rk;"
    }
  },
  "619": {
    "solution": {
      "database": ""
    }
  },
  "620": {
    "solution": {
      "database": ""
    }
  },
  "621": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "622": {
    "solution": {
      "design": "class MyCircularQueue {\n    private int[] data;\n    private int head;\n    private int size;\n\n    public MyCircularQueue(int k) {\n        data = new int[k];\n        head = 0;\n        size = 0;\n    }\n\n    public boolean enQueue(int value) {\n        if (isFull()) return false;\n        data[(head + size) % data.length] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deQueue() {\n        if (isEmpty()) return false;\n        head = (head + 1) % data.length;\n        size--;\n        return true;\n    }\n\n    public int Front() {\n        return isEmpty() ? -1 : data[head];\n    }\n\n    public int Rear() {\n        return isEmpty() ? -1 : data[(head + size - 1) % data.length];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == data.length;\n    }\n}"
    }
  },
  "623": {
    "solution": {
      "binary-tree": "class Solution {\n    public TreeNode addOneRow(TreeNode root, int val, int depth) {\n        if (depth == 1) {\n            TreeNode newRoot = new TreeNode(val);\n            newRoot.left = root;\n            return newRoot;\n        }\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n        int currentLevel = 1;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                if (currentLevel == depth - 1) {\n                    TreeNode left = new TreeNode(val);\n                    TreeNode right = new TreeNode(val);\n                    left.left = node.left;\n                    right.right = node.right;\n                    node.left = left;\n                    node.right = right;\n                } else {\n                    if (node.left != null) queue.offer(node.left);\n                    if (node.right != null) queue.offer(node.right);\n                }\n            }\n            currentLevel++;\n        }\n\n        return root;\n    }\n}"
    }
  },
  "624": {
    "solution": {
      "greedy": "class Solution {\n    public int maxDistance(List<List<Integer>> arrays) {\n        int minVal = arrays.get(0).get(0);\n        int maxVal = arrays.get(0).get(arrays.get(0).size() - 1);\n        int maxDist = 0;\n\n        for (int i = 1; i < arrays.size(); i++) {\n            List<Integer> arr = arrays.get(i);\n            int first = arr.get(0), last = arr.get(arr.size() - 1);\n            maxDist = Math.max(maxDist, Math.max(Math.abs(last - minVal), Math.abs(maxVal - first)));\n            minVal = Math.min(minVal, first);\n            maxVal = Math.max(maxVal, last);\n        }\n\n        return maxDist;\n    }\n}"
    }
  },
  "625": {
    "solution": {
      "greedy": "class Solution {\n    public int smallestFactorization(int num) {\n        if (num < 2) return num;\n\n        long res = 0, mul = 1;\n        for (int i = 9; i >= 2; i--) {\n            while (num % i == 0) {\n                num /= i;\n                res += i * mul;\n                mul *= 10;\n            }\n        }\n\n        return (num == 1 && res <= Integer.MAX_VALUE) ? (int) res : 0;\n    }\n}"
    }
  },
  "626": {
    "solution": {
      "database": ""
    }
  },
  "627": {
    "solution": {
      "database": ""
    }
  },
  "628": {
    "solution": {
      "sorting": "class Solution {\n    public int maximumProduct(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        return Math.max(\n            nums[0] * nums[1] * nums[n - 1],\n            nums[n - 1] * nums[n - 2] * nums[n - 3]\n        );\n    }\n}"
    }
  },
  "629": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "630": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "631": {
    "solution": {
      "design": "// Struct to represent a cell in the Excel sheet\nstruct Cell {\n  int val = 0;\n  unordered_map<int, int> posCount;  // {position: count}\n};\n\nclass Excel {\n public:\n  // Constructor to initialize the Excel sheet\n  Excel(int height, char width)\n      : width(width - 'A' + 1), sheet(height, vector<Cell>(width - 'A' + 1)) {}\n\n  // Sets the value of a cell\n  void set(int row, char column, int val) {\n    getCell(row, column) = {val, {}};\n  }\n\n  // Gets the value of a cell\n  int get(int row, char column) {\n    const Cell& cell = getCell(row, column);\n    if (cell.posCount.empty())\n      return cell.val;\n\n    int val = 0;\n    for (const auto& [pos, count] : cell.posCount)\n      val += get(pos / width + 1, pos % width + 'A') * count;\n    return val;\n  }\n\n  // Sets a cell's value as the sum of other cells and returns the result\n  int sum(int row, char column, vector<string> numbers) {\n    getCell(row, column).posCount = parse(numbers);\n    return get(row, column);\n  }\n\n private:\n  int width;  // Number of columns in the Excel sheet\n  vector<vector<Cell>> sheet;\n\n  // Retrieves a reference to a cell\n  Cell& getCell(int row, char column) {\n    return sheet[row - 1][column - 'A'];\n  }\n\n  // Parses the input strings to map cell positions to their counts\n  unordered_map<int, int> parse(const vector<string>& numbers) {\n    unordered_map<int, int> count;\n    for (const string& s : numbers) {\n      const auto [startRow, startCol, endRow, endCol] = parseRange(s);\n      for (int i = startRow - 1; i < endRow; ++i)\n        for (int j = startCol - 'A'; j < endCol - 'A' + 1; ++j)\n          ++count[i * width + j];\n    }\n    return count;\n  }\n\n  // Parses a range string (e.g., \"A1:B2\" or \"A1\") into start and end coordinates\n  tuple<int, char, int, char> parseRange(const string& s) {\n    if (s.find(':') == string::npos) {\n      return {stoi(s.substr(1)), s[0], stoi(s.substr(1)), s[0]};\n    }\n\n    const int colonIndex = s.find(':');\n    const string& left = s.substr(0, colonIndex);\n    const string& right = s.substr(colonIndex + 1);\n    return {stoi(left.substr(1)), left[0], stoi(right.substr(1)), right[0]};\n  }\n};"
    }
  },
  "632": {
    "solution": {
      "sliding-window": "import java.util.Comparator;\nimport java.util.PriorityQueue;\n\nclass Solution {\n    public int[] smallestRange(List<List<Integer>> nums) {\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(o -> nums.get(o[0]).get(o[1])));\n        int maxElement = Integer.MIN_VALUE;\n        int start = 0, end = Integer.MAX_VALUE;\n        \n        for (int i = 0; i < nums.size(); i++) {\n            minHeap.offer(new int[]{i, 0});\n            maxElement = Math.max(maxElement, nums.get(i).get(0));\n        }\n        \n        while (true) {\n            int[] current = minHeap.poll();\n            int listIdx = current[0];\n            int elementIdx = current[1];            \n            int currentRange = maxElement - nums.get(listIdx).get(elementIdx);            \n            if (currentRange < end - start) {\n                start = nums.get(listIdx).get(elementIdx);\n                end = maxElement;\n            }            \n            elementIdx++;\n            if (elementIdx == nums.get(listIdx).size()) {\n                break;\n            }            \n            minHeap.offer(new int[]{listIdx, elementIdx});\n            maxElement = Math.max(maxElement, nums.get(listIdx).get(elementIdx));\n        }\n        \n        return new int[]{start, end};\n    }\n}\n"
    }
  },
  "633": {
    "solution": {
      "two-pointers": "public class Solution {\n    public boolean judgeSquareSum(int c) {\n        long left = 0;\n        long right = (long) Math.sqrt(c);\n\n        while (left <= right) {\n            long sum = left * left + right * right;\n            if (sum == c) {\n                return true;\n            } else if (sum < c) {\n                left++;\n            } else {\n                right--;\n            }\n        }\n\n        return false;\n    }\n}\n"
    }
  },
  "634": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "635": {
    "solution": {
      "ordered-set": "class LogSystem {\n    private final Map<String, Integer> granularityMap;\n    private final List<int[]> logs;\n\n    public LogSystem() {\n        granularityMap = Map.of(\n            \"Year\", 4,\n            \"Month\", 7,\n            \"Day\", 10,\n            \"Hour\", 13,\n            \"Minute\", 16,\n            \"Second\", 19\n        );\n        logs = new ArrayList<>();\n    }\n\n    public void put(int id, String timestamp) {\n        logs.add(new int[]{id, timestamp.hashCode()}); // Store timestamp with id for fast filtering\n    }\n\n    public List<Integer> retrieve(String start, String end, String granularity) {\n        int len = granularityMap.get(granularity);\n        String startSub = start.substring(0, len);\n        String endSub = end.substring(0, len);\n\n        List<Integer> result = new ArrayList<>();\n        for (int[] log : logs) {\n            String time = String.valueOf(log[1]);\n            if (startSub.compareTo(time.substring(0, len)) <= 0 &&\n                time.substring(0, len).compareTo(endSub) <= 0) {\n                result.add(log[0]);\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "636": {
    "solution": {
      "stack": ""
    }
  },
  "637": {
    "solution": {
      "binary-tree": "class Solution {\n    public List<Double> averageOfLevels(TreeNode root) {\n        List<Double> result = new ArrayList<>();\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            double sum = 0;\n            for (int i = 0; i < size; i++) {\n                TreeNode node = queue.poll();\n                sum += node.val;\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n            result.add(sum / size);\n        }\n        return result;\n    }\n}"
    }
  },
  "638": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "639": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "640": {
    "solution": {
      "math": ""
    }
  },
  "641": {
    "solution": {
      "design": "class MyCircularDeque {\n    private int[] q;\n    private int front, rear, size, capacity;\n\n    public MyCircularDeque(int k) {\n        q = new int[k];\n        capacity = k;\n        front = 0;\n        rear = k - 1;\n        size = 0;\n    }\n\n    public boolean insertFront(int value) {\n        if (isFull()) return false;\n        front = (front - 1 + capacity) % capacity;\n        q[front] = value;\n        size++;\n        return true;\n    }\n\n    public boolean insertLast(int value) {\n        if (isFull()) return false;\n        rear = (rear + 1) % capacity;\n        q[rear] = value;\n        size++;\n        return true;\n    }\n\n    public boolean deleteFront() {\n        if (isEmpty()) return false;\n        front = (front + 1) % capacity;\n        size--;\n        return true;\n    }\n\n    public boolean deleteLast() {\n        if (isEmpty()) return false;\n        rear = (rear - 1 + capacity) % capacity;\n        size--;\n        return true;\n    }\n\n    public int getFront() {\n        return isEmpty() ? -1 : q[front];\n    }\n\n    public int getRear() {\n        return isEmpty() ? -1 : q[rear];\n    }\n\n    public boolean isEmpty() {\n        return size == 0;\n    }\n\n    public boolean isFull() {\n        return size == capacity;\n    }\n}"
    }
  },
  "642": {
    "solution": {
      "design": "// TrieNode class implements Comparable to manage sorting based on frequency and lexicographical order\nclass TrieNode implements Comparable<TrieNode> {\n  public TrieNode[] children = new TrieNode[128];  // Array to store child nodes (one for each character)\n  public String s = null; // The string associated with this node\n  public int time = 0; // Frequency of the sentence\n  public List<TrieNode> top3 = new ArrayList<>(); // List of top 3 sentences for autocomplete\n\n  @Override\n  public int compareTo(TrieNode o) {\n    if (this.time == o.time)\n      return this.s.compareTo(o.s);  // If times are equal, compare lexicographically\n    return o.time - this.time; // Otherwise, compare based on frequency\n  }\n\n  public void update(TrieNode node) {\n    if (!this.top3.contains(node))\n      this.top3.add(node);  // Add node to top3 if not already present\n    Collections.sort(top3);  // Sort top3 list to maintain the top 3\n    if (top3.size() > 3)  // Keep only the top 3\n      top3.remove(top3.size() - 1);\n  }\n}\n\nclass AutocompleteSystem {\n  public AutocompleteSystem(String[] sentences, int[] times) {\n    for (int i = 0; i < sentences.length; ++i)\n      insert(sentences[i], times[i]);  // Initialize the system with existing sentences and their times\n  }\n\n  public List<String> input(char c) {\n    if (c == '#') {  // If the input is '#', finalize the current sentence\n      insert(sb.toString(), 1);  // Insert the sentence with time 1\n      curr = root;  // Reset current node\n      sb = new StringBuilder();  // Reset the sentence builder\n      return new ArrayList<>();  // No autocomplete needed after '#'\n    }\n\n    sb.append(c);  // Append the character to the current sentence\n\n    int index = (int) c; // Convert the character to an integer index\n    if (curr != null)\n      curr = curr.children[index];  // Traverse the trie based on the current character\n    if (curr == null)\n      return new ArrayList<>();  // If no sentence matches, return empty list\n\n    List<String> ans = new ArrayList<>();  // List to store autocomplete results\n\n    for (TrieNode node : curr.top3)  // Add the top 3 suggestions\n      ans.add(node.s);\n\n    return ans;  // Return the suggestions\n  }\n\n  private TrieNode root = new TrieNode();  // Root of the trie\n  private TrieNode curr = root;  // Pointer to the current node in the trie\n  private StringBuilder sb = new StringBuilder();  // StringBuilder to build the current sentence\n\n  private void insert(final String s, int time) {\n    TrieNode node = root;  // Start from the root node\n    for (final char c : s.toCharArray()) {  // Traverse the trie based on the sentence characters\n      int index = (int) c;  // Convert character to integer index for children array\n      if (node.children[index] == null)\n        node.children[index] = new TrieNode();  // Create a new node if it doesn't exist\n      node = node.children[index];  // Move to the next node\n    }\n    node.s = s;  // Set the sentence at the leaf node\n    node.time += time;  // Increment the time for the sentence\n\n    TrieNode leaf = node;  // Save the leaf node\n    node = root;  // Restart from the root node\n    for (final char c : s.toCharArray()) {  // Traverse again from the root to update top3 for each node\n      int index = (int) c;  // Convert character to integer index for children array\n      node = node.children[index];  // Move to the next node\n      node.update(leaf);  // Update the top3 list for each node\n    }\n  }\n}"
    }
  },
  "643": {
    "solution": {
      "sliding-window": "public class Solution {\n    public double findMaxAverage(int[] nums, int k) {\n        int sum = 0;\n        for (int i = 0; i < k; ++i) {\n            sum += nums[i];\n        }\n        \n        double res = sum;\n        \n        for (int i = k; i < nums.length; ++i) {\n            sum += nums[i] - nums[i - k];\n            res = Math.max(res, sum);\n        }\n        \n        return res / k;\n    }\n}\n"
    }
  },
  "644": {
    "solution": {
      "prefix-sum": "class Solution {\n  public double findMaxAverage(int[] nums, int k) {\n    double kErr = 1e-5;\n    double l = (double) Arrays.stream(nums).min().getAsInt();\n    double r = (double) Arrays.stream(nums).max().getAsInt();\n\n    while (r - l > kErr) {\n      double m = (l + r) / 2;\n      if (check(nums, k, m))\n        l = m;\n      else\n        r = m;\n    }\n\n    return l;\n  }\n\n  private boolean check(int[] nums, int k, double m) {\n    double sum = 0;\n    double prevSum = 0;\n    double minPrevSum = 0;\n\n    for (int i = 0; i < nums.length; ++i) {\n      sum += nums[i] - m;\n      if (i >= k) {\n        prevSum += nums[i - k] - m;\n        minPrevSum = Math.min(minPrevSum, prevSum);\n      }\n      if (i + 1 >= k && sum >= minPrevSum)\n        return true;\n    }\n\n    return false;\n  }\n}"
    }
  },
  "645": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "646": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "647": {
    "solution": {
      "two-pointers": "public class Solution {\n    public int countSubstrings(String s) {\n        int n = s.length();\n        int count = 0;\n\n        for (int i = 0; i < n; i++) {\n            count += countPalindromesAroundCenter(s, i, i); // Odd length palindromes\n            count += countPalindromesAroundCenter(s, i, i + 1); // Even length palindromes\n        }\n\n        return count;\n    }\n\n    private int countPalindromesAroundCenter(String s, int left, int right) {\n        int count = 0;\n        while (left >= 0 && right < s.length() && s.charAt(left) == s.charAt(right)) {\n            count++;\n            left--;\n            right++;\n        }\n        return count;\n    }\n}\n"
    }
  },
  "648": {
    "solution": {
      "trie": ""
    }
  },
  "649": {
    "solution": {
      "queue": ""
    }
  },
  "650": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int minSteps(int n) {\n        int[] dp = new int[n + 1];\n        Arrays.fill(dp, Integer.MAX_VALUE);\n        dp[1] = 0;\n\n        for (int i = 2; i <= n; i++) {\n            for (int j = 1; j <= Math.sqrt(i); j++) {\n                if (i % j == 0) {\n                    dp[i] = Math.min(dp[i], dp[j] + (i / j));\n                    if (j != i / j) {\n                        dp[i] = Math.min(dp[i], dp[i / j] + j);\n                    }\n                }\n            }\n        }\n\n        return dp[n];\n    }\n}"
    }
  },
  "651": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int maxA(int n) {\n        int[] dp = new int[n + 1];\n        for (int i = 1; i <= n; i++) {\n            dp[i] = dp[i - 1] + 1;\n            for (int j = 2; j < i - 1; j++) {\n                dp[i] = Math.max(dp[i], dp[j - 1] * (i - j));\n            }\n        }\n        return dp[n];\n    }\n}"
    }
  },
  "652": {
    "solution": {
      "depth-first-search": "class Solution {\n    Map<String, Integer> count = new HashMap<>();\n    List<TreeNode> result = new ArrayList<>();\n\n    public List<TreeNode> findDuplicateSubtrees(TreeNode root) {\n        serialize(root);\n        return result;\n    }\n\n    private String serialize(TreeNode node) {\n        if (node == null) return \"#\";\n        String serial = node.val + \",\" + serialize(node.left) + \",\" + serialize(node.right);\n        count.put(serial, count.getOrDefault(serial, 0) + 1);\n        if (count.get(serial) == 2) result.add(node);\n        return serial;\n    }\n}"
    }
  },
  "653": {
    "solution": {
      "two-pointers": ""
    }
  },
  "654": {
    "solution": {
      "binary-tree": "class Solution {\n    public TreeNode constructMaximumBinaryTree(int[] nums) {\n        return build(nums, 0, nums.length - 1);\n    }\n\n    private TreeNode build(int[] nums, int left, int right) {\n        if (left > right) return null;\n\n        int maxIndex = left;\n        for (int i = left; i <= right; i++) {\n            if (nums[i] > nums[maxIndex]) maxIndex = i;\n        }\n\n        TreeNode root = new TreeNode(nums[maxIndex]);\n        root.left = build(nums, left, maxIndex - 1);\n        root.right = build(nums, maxIndex + 1, right);\n        return root;\n    }\n}"
    }
  },
  "655": {
    "solution": {
      "binary-tree": "class Solution {\n    public List<List<String>> printTree(TreeNode root) {\n        int height = getHeight(root);\n        int width = (1 << height) - 1;\n        List<List<String>> res = new ArrayList<>();\n        for (int i = 0; i < height; i++) {\n            List<String> row = new ArrayList<>(Collections.nCopies(width, \"\"));\n            res.add(row);\n        }\n        fill(root, res, 0, 0, width - 1);\n        return res;\n    }\n\n    private int getHeight(TreeNode root) {\n        if (root == null) return 0;\n        return 1 + Math.max(getHeight(root.left), getHeight(root.right));\n    }\n\n    private void fill(TreeNode root, List<List<String>> res, int level, int left, int right) {\n        if (root == null) return;\n        int mid = left + (right - left) / 2;\n        res.get(level).set(mid, String.valueOf(root.val));\n        fill(root.left, res, level + 1, left, mid - 1);\n        fill(root.right, res, level + 1, mid + 1, right);\n    }\n}"
    }
  },
  "656": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "657": {
    "solution": {
      "string": ""
    }
  },
  "658": {
    "solution": {
      "two-pointers": "class Solution {\n    public List<Integer> findClosestElements(int[] arr, int k, int x) {\n        int left = 0;\n        int right = arr.length - k;\n\n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (x - arr[mid] <= arr[mid + k] - x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = left; i < left + k; i++) {\n            result.add(arr[i]);\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "659": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "660": {
    "solution": {
      "math": "class Solution {\n public:\n  int newInteger(int n) {\n    string ans;\n    while (n > 0) {\n      ans = to_string(n % 9) + ans;\n      n /= 9;\n    }\n    return stoi(ans);\n  }\n};"
    }
  },
  "661": {
    "solution": {
      "matrix": ""
    }
  },
  "662": {
    "solution": {
      "binary-tree": "class Solution {\n    public int widthOfBinaryTree(TreeNode root) {\n        if (root == null) return 0;\n\n        int maxWidth = 0;\n        Queue<Pair<TreeNode, Long>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(root, 0L));\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            long min = queue.peek().getValue();\n            long first = 0, last = 0;\n\n            for (int i = 0; i < size; i++) {\n                Pair<TreeNode, Long> p = queue.poll();\n                TreeNode node = p.getKey();\n                long curId = p.getValue() - min;\n                if (i == 0) first = curId;\n                if (i == size - 1) last = curId;\n\n                if (node.left != null)\n                    queue.offer(new Pair<>(node.left, 2 * curId + 1));\n                if (node.right != null)\n                    queue.offer(new Pair<>(node.right, 2 * curId + 2));\n            }\n\n            maxWidth = Math.max(maxWidth, (int) (last - first + 1));\n        }\n        return maxWidth;\n    }\n}"
    }
  },
  "663": {
    "solution": {
      "tree": ""
    }
  },
  "664": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "665": {
    "solution": {
      "array": "class Solution {\n    public boolean checkPossibility(int[] nums) {\n        int count = 0;\n        for (int i = 0; i < nums.length - 1; i++) {\n            if (nums[i] > nums[i + 1]) {\n                if (++count > 1) return false;\n                if (i == 0 || nums[i - 1] <= nums[i + 1]) {\n                    nums[i] = nums[i + 1];\n                } else {\n                    nums[i + 1] = nums[i];\n                }\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "666": {
    "solution": {
      "tree": ""
    }
  },
  "667": {
    "solution": {
      "math": ""
    }
  },
  "668": {
    "solution": {
      "math": ""
    }
  },
  "669": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "670": {
    "solution": {
      "greedy": "class Solution {\n    public int maximumSwap(int num) {\n        char[] digits = String.valueOf(num).toCharArray();\n        int[] last = new int[10];\n        for (int i = 0; i < digits.length; i++) {\n            last[digits[i] - '0'] = i;\n        }\n\n        for (int i = 0; i < digits.length; i++) {\n            for (int d = 9; d > digits[i] - '0'; d--) {\n                if (last[d] > i) {\n                    char temp = digits[i];\n                    digits[i] = digits[last[d]];\n                    digits[last[d]] = temp;\n                    return Integer.parseInt(new String(digits));\n                }\n            }\n        }\n        return num;\n    }\n}"
    }
  },
  "671": {
    "solution": {
      "binary-tree": "class Solution {\n    public int findSecondMinimumValue(TreeNode root) {\n        if (root == null) return -1;\n        int minVal = root.val;\n        int[] secondMin = new int[]{-1};\n        traverse(root, minVal, secondMin);\n        return secondMin[0];\n    }\n\n    private void traverse(TreeNode node, int minVal, int[] secondMin) {\n        if (node == null) return;\n\n        if (node.val > minVal) {\n            if (secondMin[0] == -1 || node.val < secondMin[0]) {\n                secondMin[0] = node.val;\n            }\n        }\n\n        traverse(node.left, minVal, secondMin);\n        traverse(node.right, minVal, secondMin);\n    }\n}"
    }
  },
  "672": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "673": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int findNumberOfLIS(int[] nums) {\n        int n = nums.length;\n        int[] length = new int[n];\n        int[] count = new int[n];\n        Arrays.fill(length, 1);\n        Arrays.fill(count, 1);\n\n        int maxLength = 0, result = 0;\n\n        for (int i = 0; i < n; ++i) {\n            for (int j = 0; j < i; ++j) {\n                if (nums[j] < nums[i]) {\n                    if (length[i] < length[j] + 1) {\n                        length[i] = length[j] + 1;\n                        count[i] = count[j];\n                    } else if (length[i] == length[j] + 1) {\n                        count[i] += count[j];\n                    }\n                }\n            }\n            if (length[i] > maxLength) {\n                maxLength = length[i];\n                result = count[i];\n            } else if (length[i] == maxLength) {\n                result += count[i];\n            }\n        }\n        return result;\n    }\n}"
    }
  },
  "674": {
    "solution": {
      "array": ""
    }
  },
  "675": {
    "solution": {
      "matrix": ""
    }
  },
  "676": {
    "solution": {
      "trie": ""
    }
  },
  "677": {
    "solution": {
      "trie": ""
    }
  },
  "678": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public boolean checkValidString(String s) {\n        int low = 0, high = 0;\n        for (char c : s.toCharArray()) {\n            if (c == '(') {\n                low++;\n                high++;\n            } else if (c == ')') {\n                if (low > 0) low--;\n                high--;\n            } else {\n                if (low > 0) low--;\n                high++;\n            }\n            if (high < 0) return false;\n        }\n        return low == 0;\n    }\n}"
    }
  },
  "679": {
    "solution": {
      "backtracking": ""
    }
  },
  "680": {
    "solution": {
      "string": "class Solution {\n    public boolean validPalindrome(String s) {\n        int left = 0, right = s.length() - 1;\n        while (left < right) {\n            if (s.charAt(left) != s.charAt(right)) {\n                return isPalindrome(s, left + 1, right) || isPalindrome(s, left, right - 1);\n            }\n            left++;\n            right--;\n        }\n        return true;\n    }\n\n    private boolean isPalindrome(String s, int l, int r) {\n        while (l < r) {\n            if (s.charAt(l++) != s.charAt(r--)) return false;\n        }\n        return true;\n    }\n}"
    }
  },
  "681": {
    "solution": {
      "backtracking": ""
    }
  },
  "682": {
    "solution": {
      "stack": ""
    }
  },
  "683": {
    "solution": {
      "sliding-window": "class Solution {\n    public int kEmptySlots(int[] bulbs, int k) {\n      int n = bulbs.length;\n        int ans = Integer.MAX_VALUE;\n        int[] day = new int[n]; // day[i] will store the day when bulb at position (i+1) is turned on\n\n        for (int i = 0; i < n; ++i)\n            day[bulbs[i] - 1] = i + 1;\n\n        int left = 0;\n        int right = left + k + 1;\n        \n        for (int i = 1; right < n; ++i) {\n            if (i == right) {\n                ans = Math.min(ans, Math.max(day[left], day[right]));\n                left = i;\n                right = i + k + 1;\n            } else if (day[i] < Math.max(day[left], day[right])) {\n                left = i;\n                right = i + k + 1;\n            }\n        }\n\n        return ans == Integer.MAX_VALUE ? -1 : ans;\n    }\n}\n"
    }
  },
  "684": {
    "solution": {
      "union-find": "class Solution {\n    int[] parent;\n\n    public int[] findRedundantConnection(int[][] edges) {\n        int n = edges.length;\n        parent = new int[n + 1];\n        for (int i = 1; i <= n; i++) parent[i] = i;\n\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            if (find(u) == find(v)) return edge;\n            union(u, v);\n        }\n        return new int[0];\n    }\n\n    private int find(int x) {\n        if (parent[x] != x) parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    private void union(int x, int y) {\n        parent[find(x)] = find(y);\n    }\n}"
    }
  },
  "685": {
    "solution": {
      "union-find": "class UF {\n  public UF(int n) {\n    id = new int[n];\n    for (int i = 0; i < n; ++i)\n      id[i] = i;\n  }\n\n  public boolean union(int u, int v) {\n    final int i = find(u);\n    final int j = find(v);\n    if (i == j)\n      return false;\n    id[i] = j;\n    return true;\n  }\n\n  private int[] id;\n\n  private int find(int u) {\n    return id[u] == u ? u : (id[u] = find(id[u]));\n  }\n}\n\nclass Solution {\n  public int[] findRedundantDirectedConnection(int[][] edges) {\n    int[] ids = new int[edges.length + 1];\n    int nodeWithTwoParents = 0;\n\n    for (int[] edge : edges) {\n      final int v = edge[1];\n      if (++ids[v] == 2) {\n        nodeWithTwoParents = v;\n        break;\n      }\n    }\n\n    if (nodeWithTwoParents == 0)\n      return findRedundantDirectedConnection(edges, -1);\n\n    for (int i = edges.length - 1; i >= 0; --i)\n      if (edges[i][1] == nodeWithTwoParents)\n        if (findRedundantDirectedConnection(edges, i).length == 0)\n          return edges[i];\n\n    throw new IllegalArgumentException();\n  }\n\n  private int[] findRedundantDirectedConnection(int[][] edges, int skippedEdgeIndex) {\n    UF uf = new UF(edges.length + 1);\n\n    for (int i = 0; i < edges.length; ++i) {\n      if (i == skippedEdgeIndex)\n        continue;\n      if (!uf.union(edges[i][0], edges[i][1]))\n        return edges[i];\n    }\n\n    return new int[] {};\n  }\n}\n"
    }
  },
  "686": {
    "solution": {
      "string-matching": "class Solution {\n    public int repeatedStringMatch(String a, String b) {\n        StringBuilder sb = new StringBuilder(a);\n        int count = 1;\n        while (sb.length() < b.length()) {\n            sb.append(a);\n            count++;\n        }\n        if (sb.indexOf(b) != -1) return count;\n        sb.append(a);\n        return sb.indexOf(b) != -1 ? count + 1 : -1;\n    }\n}"
    }
  },
  "687": {
    "solution": {
      "binary-tree": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    private int maxLength = 0;\n\n    public int longestUnivaluePath(TreeNode root) {\n        dfs(root);\n        return maxLength;\n    }\n\n    private int dfs(TreeNode node) {\n        if (node == null) return 0;\n\n        int leftLength = dfs(node.left);\n        int rightLength = dfs(node.right);\n\n        int left = 0, right = 0;\n        if (node.left != null && node.left.val == node.val) {\n            left = leftLength + 1;\n        }\n        if (node.right != null && node.right.val == node.val) {\n            right = rightLength + 1;\n        }\n\n        maxLength = Math.max(maxLength, left + right);\n        return Math.max(left, right);\n    }\n}"
    }
  },
  "688": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "689": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "690": {
    "solution": {
      "tree": ""
    }
  },
  "691": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "692": {
    "solution": {
      "bucket-sort": "import java.util.*;\n\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n\n        List<String>[] buckets = new List[words.length + 1];\n        for (String word : frequencyMap.keySet()) {\n            int frequency = frequencyMap.get(word);\n            if (buckets[frequency] == null) {\n                buckets[frequency] = new ArrayList<>();\n            }\n            buckets[frequency].add(word);\n        }\n\n        List<String> result = new ArrayList<>();\n        for (int i = buckets.length - 1; i >= 0 && result.size() < k; i--) {\n            if (buckets[i] != null) {\n                Collections.sort(buckets[i]);\n                result.addAll(buckets[i]);\n            }\n        }\n\n        return result.subList(0, k);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.topKFrequent(new String[]{\"i\", \"love\", \"leetcode\", \"i\", \"love\", \"coding\"}, 2)); // Output: [\"i\", \"love\"]\n    }\n}\n",
      "heap-(priority-queue)": "import java.util.*;\n\nclass Solution {\n    public List<String> topKFrequent(String[] words, int k) {\n        Map<String, Integer> frequencyMap = new HashMap<>();\n        for (String word : words) {\n            frequencyMap.put(word, frequencyMap.getOrDefault(word, 0) + 1);\n        }\n\n        PriorityQueue<String> minHeap = new PriorityQueue<>(\n                (a, b) -> frequencyMap.get(a).equals(frequencyMap.get(b))\n                        ? b.compareTo(a)\n                        : frequencyMap.get(a) - frequencyMap.get(b));\n\n        for (String word : frequencyMap.keySet()) {\n            minHeap.offer(word);\n            if (minHeap.size() > k) {\n                minHeap.poll();\n            }\n        }\n\n        List<String> result = new ArrayList<>();\n        while (!minHeap.isEmpty()) {\n            result.add(minHeap.poll());\n        }\n        Collections.reverse(result);\n        return result;\n    }\n}\n"
    }
  },
  "693": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "694": {
    "solution": {
      "depth-first-search": "class Solution {\n    private Set<String> shapes = new HashSet<>();\n    private StringBuilder path;\n    private int[][] directions = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\n\n    public int numDistinctIslands(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    path = new StringBuilder();\n                    dfs(grid, i, j, 0);\n                    shapes.add(path.toString());\n                }\n            }\n        }\n\n        return shapes.size();\n    }\n\n    private void dfs(int[][] grid, int i, int j, int dir) {\n        if (i < 0 || j < 0 || i >= grid.length || j >= grid[0].length || grid[i][j] == 0) return;\n\n        grid[i][j] = 0;\n        path.append(dir);\n\n        for (int d = 0; d < 4; d++) {\n            int[] move = directions[d];\n            dfs(grid, i + move[0], j + move[1], d + 1);\n        }\n\n        path.append(0); // backtrack marker\n    }\n}"
    }
  },
  "695": {
    "solution": {
      "union-find": "",
      "matrix": "class Solution {\n    private final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int maxAreaOfIsland(int[][] grid) {\n        if (grid == null || grid.length == 0 || grid[0].length == 0) {\n            return 0;\n        }\n\n        int m = grid.length;\n        int n = grid[0].length;\n        int maxArea = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    int area = dfs(grid, i, j);\n                    maxArea = Math.max(maxArea, area);\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 0) {\n            return 0;\n        }\n\n        grid[i][j] = 0;\n        int area = 1;\n\n        for (int[] direction : DIRECTIONS) {\n            int newI = i + direction[0];\n            int newJ = j + direction[1];\n            area += dfs(grid, newI, newJ);\n        }\n\n        return area;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {0, 1, 0, 0},\n            {1, 1, 1, 0},\n            {0, 1, 0, 0},\n            {0, 0, 1, 1}\n        };\n\n        int result = solution.maxAreaOfIsland(grid);\n        System.out.println(\"Max Area of Island: \" + result); // Output: 6\n    }\n}\n"
    }
  },
  "696": {
    "solution": {
      "two-pointers": ""
    }
  },
  "697": {
    "solution": {
      "hash-table": "class Solution {\n    public int findShortestSubArray(int[] nums) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        Map<Integer, Integer> first = new HashMap<>();\n        Map<Integer, Integer> last = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            freq.put(nums[i], freq.getOrDefault(nums[i], 0) + 1);\n            first.putIfAbsent(nums[i], i);\n            last.put(nums[i], i);\n        }\n\n        int maxDegree = Collections.max(freq.values());\n        int minLen = nums.length;\n\n        for (int num : freq.keySet()) {\n            if (freq.get(num) == maxDegree) {\n                minLen = Math.min(minLen, last.get(num) - first.get(num) + 1);\n            }\n        }\n\n        return minLen;\n    }\n}"
    }
  },
  "698": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "699": {
    "solution": {
      "ordered-set": ""
    }
  },
  "700": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode searchBST(TreeNode root, int val) {\n        if (root == null || root.val == val) {\n            return root;\n        }\n        \n        if (val < root.val) {\n            return searchBST(root.left, val);\n        } else {\n            return searchBST(root.right, val);\n        }\n    }\n}\n"
    }
  },
  "701": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode insertIntoBST(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n        \n        if (val < root.val) {\n            root.left = insertIntoBST(root.left, val);\n        } else {\n            root.right = insertIntoBST(root.right, val);\n        }\n        \n        return root;\n    }\n}\n"
    }
  },
  "702": {
    "solution": {
      "interactive": ""
    }
  },
  "703": {
    "solution": {
      "binary-search-tree": "import java.util.PriorityQueue;\n\nclass KthLargest {\n    private PriorityQueue<Integer> minHeap;\n    private int k;\n\n    public KthLargest(int k, int[] nums) {\n        this.k = k;\n        this.minHeap = new PriorityQueue<>(k);\n        \n        for (int num : nums) {\n            add(num);\n        }\n    }\n    \n    public int add(int val) {\n        if (minHeap.size() < k) {\n            minHeap.offer(val);\n        } else if (val > minHeap.peek()) {\n            minHeap.poll();\n            minHeap.offer(val);\n        }\n        return minHeap.peek();\n    }\n}\n"
    }
  },
  "704": {
    "solution": {
      "binary-search": "class Solution {\n    public int search(int[] nums, int target) {\n        int low = 0, high = nums.length - 1;\n\n        while (low <= high) {\n            int mid = low + (high - low) / 2;\n            if (nums[mid] == target) return mid;\n            else if (nums[mid] < target) low = mid + 1;\n            else high = mid - 1;\n        }\n\n        return -1;\n    }\n}"
    }
  },
  "705": {
    "solution": {
      "design": "class MyHashSet {\n    private Set<Integer> set;\n\n    public MyHashSet() {\n        set = new HashSet<>();\n    }\n\n    public void add(int key) {\n        set.add(key);\n    }\n\n    public void remove(int key) {\n        set.remove(key);\n    }\n\n    public boolean contains(int key) {\n        return set.contains(key);\n    }\n}"
    }
  },
  "706": {
    "solution": {
      "hash-function": "class MyHashMap {\n    private int SIZE = 1000;\n    private List<Pair<Integer, Integer>>[] map;\n\n    public MyHashMap() {\n        map = new ArrayList[SIZE];\n        for (int i = 0; i < SIZE; i++) {\n            map[i] = new ArrayList<>();\n        }\n    }\n\n    private int hash(int key) {\n        return key % SIZE;\n    }\n\n    public void put(int key, int value) {\n        int idx = hash(key);\n        for (Pair<Integer, Integer> p : map[idx]) {\n            if (p.getKey() == key) {\n                map[idx].remove(p);\n                break;\n            }\n        }\n        map[idx].add(new Pair<>(key, value));\n    }\n\n    public int get(int key) {\n        int idx = hash(key);\n        for (Pair<Integer, Integer> p : map[idx]) {\n            if (p.getKey() == key) {\n                return p.getValue();\n            }\n        }\n        return -1;\n    }\n\n    public void remove(int key) {\n        int idx = hash(key);\n        map[idx].removeIf(p -> p.getKey() == key);\n    }\n}"
    }
  },
  "707": {
    "solution": {
      "design": "class MyLinkedList {\n public:\n  struct ListNode {\n    int val;\n    ListNode* next;\n    ListNode(int x) : val(x), next(nullptr) {}\n  };\n\n  MyLinkedList() : length(0), dummy(0) {}\n\n  int get(int index) {\n    if (index < 0 || index >= length)\n      return -1;\n    ListNode* curr = dummy.next;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    return curr->val;\n  }\n\n  void addAtHead(int val) {\n    ListNode* node = new ListNode(val);\n    node->next = dummy.next;\n    dummy.next = node;\n    ++length;\n  }\n\n  void addAtTail(int val) {\n    ListNode* curr = &dummy;\n    while (curr->next != nullptr)\n      curr = curr->next;\n    curr->next = new ListNode(val);\n    ++length;\n  }\n\n  void addAtIndex(int index, int val) {\n    if (index > length)\n      return;\n    ListNode* curr = &dummy;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    ListNode* node = new ListNode(val);\n    node->next = curr->next;\n    curr->next = node;\n    ++length;\n  }\n\n  void deleteAtIndex(int index) {\n    if (index < 0 || index >= length)\n      return;\n    ListNode* curr = &dummy;\n    for (int i = 0; i < index; ++i)\n      curr = curr->next;\n    ListNode* nodeToDelete = curr->next;\n    curr->next = nodeToDelete->next;\n    delete nodeToDelete;\n    --length;\n  }\n\n private:\n  int length;\n  ListNode dummy;\n};"
    }
  },
  "708": {
    "solution": {
      "linked-list": ""
    }
  },
  "709": {
    "solution": {
      "string": "class Solution {\n    public String toLowerCase(String s) {\n        StringBuilder result = new StringBuilder();\n        for (char c : s.toCharArray()) {\n            if (c >= 'A' && c <= 'Z') {\n                result.append((char)(c + 32));\n            } else {\n                result.append(c);\n            }\n        }\n        return result.toString();\n    }\n}"
    }
  },
  "710": {
    "solution": {
      "randomized": ""
    }
  },
  "711": {
    "solution": {
      "depth-first-search": "class Solution {\n public:\n  int numDistinctIslands2(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    // all the islands with different shapes\n    set<vector<pair<int, int>>> islands;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        vector<pair<int, int>> island;\n        dfs(grid, i, j, seen, island);\n        if (!island.empty())\n          islands.insert(normalize(island));\n      }\n\n    return islands.size();\n  }\n\n private:\n  void dfs(const vector<vector<int>>& grid, int i, int j,\n           vector<vector<bool>>& seen, vector<pair<int, int>>& island) {\n    if (i < 0 || i == grid.size() || j < 0 || j == grid[0].size())\n      return;\n    if (grid[i][j] == 0 || seen[i][j])\n      return;\n\n    seen[i][j] = true;\n    island.emplace_back(i, j);\n\n    dfs(grid, i + 1, j, seen, island);\n    dfs(grid, i - 1, j, seen, island);\n    dfs(grid, i, j + 1, seen, island);\n    dfs(grid, i, j - 1, seen, island);\n  }\n\n  vector<pair<int, int>> normalize(const vector<pair<int, int>>& island) {\n    // points[i] := 8 different rotations/reflections of an island\n    vector<vector<pair<int, int>>> points(8);\n\n    for (const auto& [i, j] : island) {\n      points[0].emplace_back(i, j);\n      points[1].emplace_back(i, -j);\n      points[2].emplace_back(-i, j);\n      points[3].emplace_back(-i, -j);\n      points[4].emplace_back(j, i);\n      points[5].emplace_back(j, -i);\n      points[6].emplace_back(-j, i);\n      points[7].emplace_back(-j, -i);\n    }\n\n    for (vector<pair<int, int>>& p : points)\n      ranges::sort(p);\n\n    for (vector<pair<int, int>>& p : points) {\n      for (int i = 1; i < island.size(); ++i)\n        p[i] = {p[i].first - p[0].first, p[i].second - p[0].second};\n      p[0] = {0, 0};\n    }\n\n    ranges::sort(points);\n    return points[0];\n  }\n};"
    }
  },
  "712": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "713": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numSubarrayProductLessThanK(int[] nums, int k) {\n        if (k <= 1) return 0; /\n        int left = 0;\n        int product = 1;\n        int count = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            product *= nums[right];\n            \n            while (product >= k) {\n                product /= nums[left];\n                left++;\n            }\n            \n            count += right - left + 1;\n        }\n        \n        return count;\n    }\n}"
    }
  },
  "714": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int maxProfit(int[] prices, int fee) {\n        int n = prices.length;\n        if (n == 0) return 0;\n\n        int[] dp0 = new int[n]; // Not holding stock\n        int[] dp1 = new int[n]; // Holding stock\n\n        dp0[0] = 0;\n        dp1[0] = -prices[0];\n\n        for (int i = 1; i < n; i++) {\n            dp0[i] = Math.max(dp0[i - 1], dp1[i - 1] + prices[i] - fee);\n            dp1[i] = Math.max(dp1[i - 1], dp0[i - 1] - prices[i]);\n        }\n\n        return dp0[n - 1];\n    }\n}"
    }
  },
  "715": {
    "solution": {
      "segment-tree": "class MyCalendarThree {\n\n    class Node {\n        int start, end, max, lazy;\n        Node left, right;\n\n        Node(int start, int end) {\n            this.start = start;\n            this.end = end;\n            this.max = 0;\n            this.lazy = 0;\n        }\n\n        private void push() {\n            if (left == null) {\n                int mid = start + (end - start) / 2;\n                left = new Node(start, mid);\n                right = new Node(mid + 1, end);\n            }\n            if (lazy != 0) {\n                left.max += lazy;\n                left.lazy += lazy;\n                right.max += lazy;\n                right.lazy += lazy;\n                lazy = 0;\n            }\n        }\n\n        public void update(int l, int r) {\n            if (r < start || end < l) return;\n            if (l <= start && end <= r) {\n                max++;\n                lazy++;\n                return;\n            }\n            push();\n            left.update(l, r);\n            right.update(l, r);\n            max = Math.max(left.max, right.max);\n        }\n    }\n\n    Node root;\n    int MAX_TIME = (int) 1e9;\n\n    public MyCalendarThree() {\n        root = new Node(0, MAX_TIME);\n    }\n\n    public int book(int start, int end) {\n        root.update(start, end - 1);\n        return root.max;\n    }\n}\n\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.book(startTime,endTime);\n */"
    }
  },
  "716": {
    "solution": {
      "doubly-linked-list": "class Node {\n    public int val;\n    public Node prev, next;\n\n    public Node() {\n    }\n\n    public Node(int val) {\n        this.val = val;\n    }\n}\n\nclass DoubleLinkedList {\n    private final Node head = new Node();\n    private final Node tail = new Node();\n\n    public DoubleLinkedList() {\n        head.next = tail;\n        tail.prev = head;\n    }\n\n    public Node append(int val) {\n        Node node = new Node(val);\n        node.next = tail;\n        node.prev = tail.prev;\n        tail.prev = node;\n        node.prev.next = node;\n        return node;\n    }\n\n    public static Node remove(Node node) {\n        node.prev.next = node.next;\n        node.next.prev = node.prev;\n        return node;\n    }\n\n    public Node pop() {\n        return remove(tail.prev);\n    }\n\n    public int peek() {\n        return tail.prev.val;\n    }\n}\n\nclass MaxStack {\n    private DoubleLinkedList stack = new DoubleLinkedList();\n    private TreeMap<Integer, List<Node>> map = new TreeMap<>();\n\n    public MaxStack() {\n    }\n\n    public void push(int x) {\n        Node node = stack.append(x);\n        map.computeIfAbsent(x, k -> new ArrayList<>()).add(node);\n    }\n\n    public int pop() {\n        Node node = stack.pop();\n        List<Node> nodes = map.get(node.val);\n        int x = nodes.remove(nodes.size() - 1).val;\n        if (nodes.isEmpty()) {\n            map.remove(node.val);\n        }\n        return x;\n    }\n\n    public int top() {\n        return stack.peek();\n    }\n\n    public int peekMax() {\n        return map.lastackey();\n    }\n\n    public int popMax() {\n        int x = peekMax();\n        List<Node> nodes = map.get(x);\n        Node node = nodes.remove(nodes.size() - 1);\n        if (nodes.isEmpty()) {\n            map.remove(x);\n        }\n        DoubleLinkedList.remove(node);\n        return x;\n    }\n}\n\n/**\n * Your MaxStack object will be instantiated and called as such:\n * MaxStack obj = new MaxStack();\n * obj.push(x);\n * int param_2 = obj.pop();\n * int param_3 = obj.top();\n * int param_4 = obj.peekMax();\n * int param_5 = obj.popMax();\n */"
    }
  },
  "717": {
    "solution": {
      "array": "class Solution {\n    public boolean isOneBitCharacter(int[] bits) {\n        int i = 0;\n        while (i < bits.length - 1) {\n            i += bits[i] == 1 ? 2 : 1;\n        }\n        return i == bits.length - 1;\n    }\n}"
    }
  },
  "718": {
    "solution": {
      "sliding-window": "class Solution {\n    public int findLength(int[] A, int[] B) {\n        int m = A.length;\n        int n = B.length;\n        int[][] dp = new int[m + 1][n + 1];\n        int maxLen = 0;\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                if (A[i - 1] == B[j - 1]) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    maxLen = Math.max(maxLen, dp[i][j]);\n                } else {\n                    dp[i][j] = 0;\n                }\n            }\n        }\n\n        return maxLen;\n    }\n}\n"
    }
  },
  "719": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int smallestDistancePair(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int left = 0;\n        int right = nums[n - 1] - nums[0];\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (countPairs(nums, mid) < k) {\n                left = mid + 1;\n            } else {\n                right = mid;\n            }\n        }\n\n        return left;\n    }\n\n    private int countPairs(int[] nums, int mid) {\n        int count = 0;\n        int n = nums.length;\n        for (int i = 0; i < n; i++) {\n            int j = i;\n            while (j < n && nums[j] - nums[i] <= mid) {\n                j++;\n            }\n            count += j - i - 1;\n        }\n        return count;\n    }\n}\n"
    }
  },
  "720": {
    "solution": {
      "trie": ""
    }
  },
  "721": {
    "solution": {
      "union-find": "class UF {\n  public UF(List<List<String>> accounts) {\n    for (List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i) {\n        final String email = account.get(i);\n        id.putIfAbsent(email, email);\n      }\n  }\n\n  public void union(final String u, final String v) {\n    id.put(find(u), find(v));\n  }\n\n  public String find(final String u) {\n    if (u != id.get(u))\n      id.put(u, find(id.get(u)));\n    return id.get(u);\n  }\n\n  private Map<String, String> id = new HashMap<>();\n}\n\nclass Solution {\n  public List<List<String>> accountsMerge(List<List<String>> accounts) {\n    List<List<String>> ans = new ArrayList<>();\n    Map<String, String> emailToName = new HashMap<>();\n    Map<String, TreeSet<String>> idEmailToEmails = new HashMap<>();\n    UF uf = new UF(accounts);\n    for (final List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i)\n        emailToName.putIfAbsent(account.get(i), account.get(0));\n    for (final List<String> account : accounts)\n      for (int i = 2; i < account.size(); ++i)\n        uf.union(account.get(i), account.get(i - 1));\n\n    for (final List<String> account : accounts)\n      for (int i = 1; i < account.size(); ++i) {\n        final String id = uf.find(account.get(i));\n        idEmailToEmails.putIfAbsent(id, new TreeSet<>());\n        idEmailToEmails.get(id).add(account.get(i));\n      }\n\n    for (final String idEmail : idEmailToEmails.keySet()) {\n      List<String> emails = new ArrayList<>(idEmailToEmails.get(idEmail));\n      final String name = emailToName.get(idEmail);\n      emails.add(0, name);\n      ans.add(emails);\n    }\n\n    return ans;\n  }\n}\n"
    }
  },
  "722": {
    "solution": {
      "string": ""
    }
  },
  "723": {
    "solution": {
      "two-pointers": ""
    }
  },
  "724": {
    "solution": {
      "prefix-sum": "public class Solution {\n    public int pivotIndex(int[] nums) {\n        int totalSum = 0;\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        int leftSum = 0;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (leftSum == totalSum - leftSum - nums[i]) {\n                return i;\n            }\n\n            leftSum += nums[i];\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 7, 3, 6, 5, 6};\n        System.out.println(solution.pivotIndex(nums)); // Output: 3\n    }\n}\n"
    }
  },
  "725": {
    "solution": {
      "linked-list": ""
    }
  },
  "726": {
    "solution": {
      "stack": "class Solution {\n    public String countOfAtoms(String formula) {\n        StringBuffer sb = new StringBuffer();\n        sb.append(formula.charAt(0));\n        char prevC = formula.charAt(0);\n        int length = formula.length();\n        for (int i = 1; i < length; i++) {\n            char c = formula.charAt(i);\n            boolean flag = Character.isLowerCase(c) || Character.isDigit(c) && Character.isDigit(prevC);\n            if (!flag)\n                sb.append(' ');\n            sb.append(c);\n            prevC = c;\n        }\n        String[] array = sb.toString().split(\" \");\n        Stack<String> stack = new Stack<String>();\n        int arrayLength = array.length;\n        for (int i = 0; i < arrayLength; i++) {\n            String str = array[i];\n            if (str.equals(\")\")) {\n                if (i < arrayLength - 1 && Character.isDigit(array[i + 1].charAt(0)))\n                    stack.push(str);\n                else {\n                    Stack<String> tempStack = new Stack<String>();\n                    while (!stack.peek().equals(\"(\"))\n                        tempStack.push(stack.pop());\n                    stack.pop();\n                    while (!tempStack.isEmpty())\n                        stack.push(tempStack.pop());\n                }\n            } else if (Character.isDigit(str.charAt(0))) {\n                int count = Integer.parseInt(str);\n                String prev = stack.pop();\n                if (prev.equals(\")\")) {\n                    Stack<String> tempStack = new Stack<String>();\n                    while (!stack.peek().equals(\"(\")) {\n                        String element = stack.pop();\n                        int index = element.indexOf(',');\n                        if (index >= 0) {\n                            String atom = element.substring(0, index);\n                            int atomCount = Integer.parseInt(element.substring(index + 1)) * count;\n                            tempStack.push(atom + \",\" + atomCount);\n                        } else\n                            tempStack.push(element + \",\" + str);\n                    }\n                    stack.pop();\n                    while (!tempStack.isEmpty())\n                        stack.push(tempStack.pop());\n                } else {\n                    String curStr = prev + \",\" + str;\n                    stack.push(curStr);\n                }\n            } else\n                stack.push(str);\n        }\n        TreeMap<String, Integer> map = new TreeMap<String, Integer>();\n        while (!stack.isEmpty()) {\n            String atomCount = stack.pop();\n            int index = atomCount.indexOf(',');\n            if (index >= 0) {\n                String atom = atomCount.substring(0, index);\n                int count = Integer.parseInt(atomCount.substring(index + 1));\n                count += map.getOrDefault(atom, 0);\n                map.put(atom, count);\n            } else {\n                int count = map.getOrDefault(atomCount, 0) + 1;\n                map.put(atomCount, count);\n            }\n        }\n        StringBuffer output = new StringBuffer();\n        Set<String> keySet = map.keySet();\n        for (String atom : keySet) {\n            int count = map.get(atom);\n            output.append(atom);\n            if (count > 1)\n                output.append(count);\n        }\n        return output.toString();\n    }\n}"
    }
  },
  "727": {
    "solution": {
      "sliding-window": "class Solution {\n  public String minWindow(String s1, String s2) {\n  int m = s2.length();\n  int n = s1.length();\n    int[][] dp = new int[m + 1][n + 1];\n\n    for (int j = 0; j <= n; ++j)\n      dp[0][j] = j + 1;\n\n    for (int i = 1; i <= m; ++i)\n      for (int j = 1; j <= n; ++j)\n        if (s2.charAt(i - 1) == s1.charAt(j - 1))\n          dp[i][j] = dp[i - 1][j - 1];\n        else\n          dp[i][j] = dp[i][j - 1];\n\n    int bestLeft = 0;\n    int minLength = Integer.MAX_VALUE;\n\n    for (int j = 1; j <= n; ++j)\n      if (dp[m][j] > 0 && j - dp[m][j] + 1 < minLength) {\n        bestLeft = dp[m][j] - 1;\n        minLength = j - dp[m][j] + 1;\n      }\n\n    return minLength == Integer.MAX_VALUE ? \"\" : s1.substring(bestLeft, bestLeft + minLength);\n  }\n}"
    }
  },
  "728": {
    "solution": {
      "math": "class Solution {\n    public List<Integer> selfDividingNumbers(int left, int right) {\n        List<Integer> result = new ArrayList<>();\n\n        for (int num = left; num <= right; num++) {\n            if (isSelfDividing(num)) {\n                result.add(num);\n            }\n        }\n\n        return result;\n    }\n\n    private boolean isSelfDividing(int num) {\n        int original = num;\n        while (num > 0) {\n            int digit = num % 10;\n            if (digit == 0 || original % digit != 0) {\n                return false;\n            }\n            num /= 10;\n        }\n        return true;\n    }\n}"
    }
  },
  "729": {
    "solution": {
      "design": "class MyCalendar {\n    private TreeMap<Integer, Integer> events;\n\n    public MyCalendar() {\n        events = new TreeMap<>();\n    }\n\n    public boolean book(int start, int end) {\n        events.put(start, events.getOrDefault(start, 0) + 1);\n        events.put(end, events.getOrDefault(end, 0) - 1);\n\n        int activeBookings = 0;\n        for (int count : events.values()) {\n            activeBookings += count;\n            if (activeBookings > 1) {\n                events.put(start, events.get(start) - 1);\n                if (events.get(start) == 0) events.remove(start);\n\n                events.put(end, events.get(end) + 1);\n                if (events.get(end) == 0) events.remove(end);\n\n                return false;\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "730": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "731": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "732": {
    "solution": {
      "segment-tree": "class MyCalendarThree {\n\n    class Node {\n        int start, end, max, lazy;\n        Node left, right;\n        Node(int start, int end) {\n            this.start = start;\n            this.end = end;\n            this.max = 0;\n            this.lazy = 0;\n        }\n\n        private void push() {\n            if (left == null) {\n                int mid = start + (end - start) / 2;\n                left = new Node(start, mid);\n                right = new Node(mid + 1, end);\n            }\n            if (lazy != 0) {\n                left.max += lazy;\n                left.lazy += lazy;\n                right.max += lazy;\n                right.lazy += lazy;\n                lazy = 0;\n            }\n        }\n\n        public void update(int l, int r) {\n            if (r < start || end < l) return;\n            if (l <= start && end <= r) {\n                max++;\n                lazy++;\n                return;\n            }\n            push();\n            left.update(l, r);\n            right.update(l, r);\n            max = Math.max(left.max, right.max);\n        }\n    }\n\n    Node root;\n    int MAX_TIME = (int) 1e9;\n\n    public MyCalendarThree() {\n        root = new Node(0, MAX_TIME);\n    }\n\n    public int book(int start, int end) {\n        root.update(start, end - 1);\n        return root.max;\n    }\n}\n\n\n/**\n * Your MyCalendarThree object will be instantiated and called as such:\n * MyCalendarThree obj = new MyCalendarThree();\n * int param_1 = obj.book(startTime,endTime);\n */"
    }
  },
  "733": {
    "solution": {
      "matrix": "class Solution {\n    // Directions: right, down, left, up\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] floodFill(int[][] image, int sr, int sc, int newColor) {\n        int originalColor = image[sr][sc];\n        \n        // If the original color is the same as the new color, no need to proceed\n        if (originalColor != newColor) {\n            dfs(image, sr, sc, newColor, originalColor);\n        }\n        \n        return image;\n    }\n    \n    private void dfs(int[][] image, int i, int j, int newColor, int originalColor) {\n        if (i < 0 || i >= image.length || j < 0 || j >= image[0].length || image[i][j] != originalColor) {\n            return;\n        }\n        \n        image[i][j] = newColor;\n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = i + direction[0];\n            int newCol = j + direction[1];\n            dfs(image, newRow, newCol, newColor, originalColor);\n        }\n    }\n}\n"
    }
  },
  "734": {
    "solution": {
      "hash-table": ""
    }
  },
  "735": {
    "solution": {
      "stack": "// [5,10,-5]\nclass Solution {\n    public int[] asteroidCollision(int[] asteroids) {\n        Stack<Integer> stack = new Stack<>();\n        for (final int a : asteroids)\n            if (a > 0) {\n                stack.push(a);\n            } else {\n                while (!stack.isEmpty() && stack.peek() > 0 && stack.peek() < -a)\n                    stack.pop();\n                if (stack.isEmpty() || stack.peek() < 0)\n                    stack.push(a);\n                else if (stack.peek() == -a)\n                    stack.pop();\n            }\n        int[] ans = new int[stack.size()];\n        for (int i = ans.length - 1; i >= 0; --i)\n            ans[i] = stack.pop();\n        return ans;\n    }\n}\n"
    }
  },
  "736": {
    "solution": {
      "stack": ""
    }
  },
  "737": {
    "solution": {
      "union-find": ""
    }
  },
  "738": {
    "solution": {
      "greedy": ""
    }
  },
  "739": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "740": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "741": {
    "solution": {
      "matrix": "public class Solution {\n    private int[][][] memo;\n\n    public int cherryPickup(int[][] grid) {\n        int n = grid.length;\n        memo = new int[n][n][n];\n        \n        // Initialize memoization array with -2 (uncomputed state)\n        for (int[][] row : memo) {\n            for (int[] col : row) {\n                Arrays.fill(col, -2);\n            }\n        }\n        \n        int result = dfs(grid, 0, 0, 0);\n        \n        return Math.max(0, result);\n    }\n\n    private int dfs(int[][] grid, int r1, int c1, int c2) {\n        int n = grid.length;\n        int r2 = r1 + c1 - c2;\n\n        // Out of bounds or blocked cell\n        if (r1 >= n || c1 >= n || r2 >= n || c2 >= n || grid[r1][c1] == -1 || grid[r2][c2] == -1) {\n            return -1;\n        }\n\n        // Base case: both players reached the bottom-right corner\n        if (r1 == n - 1 && c1 == n - 1) {\n            return grid[r1][c1];\n        }\n\n        // Return previously computed result\n        if (memo[r1][c1][c2] != -2) {\n            return memo[r1][c1][c2];\n        }\n\n        // Pick cherries at current positions\n        int cherries = grid[r1][c1];\n        if (c1 != c2) {\n            cherries += grid[r2][c2]; // Avoid double-counting if they're on the same cell\n        }\n\n        // Try all possible moves for both players\n        int maxCherries = Math.max(\n            Math.max(dfs(grid, r1 + 1, c1, c2 + 1), dfs(grid, r1 + 1, c1, c2)),\n            Math.max(dfs(grid, r1, c1 + 1, c2 + 1), dfs(grid, r1, c1 + 1, c2))\n        );\n\n        // If no valid path found, set to -1; otherwise, add collected cherries\n        if (maxCherries == -1) {\n            memo[r1][c1][c2] = -1;\n        } else {\n            memo[r1][c1][c2] = cherries + maxCherries;\n        }\n\n        return memo[r1][c1][c2];\n    }\n}\n"
    }
  },
  "742": {
    "solution": {
      "binary-tree": "class Solution {\n public:\n  int findClosestLeaf(TreeNode* root, int k) {\n    int ans = -1;\n    int minDist = 1000;\n    unordered_map<TreeNode*, int> nodeToDist;\n\n    getDists(root, k, nodeToDist);\n    dfs(root, 0, nodeToDist, minDist, ans);\n\n    return ans;\n  }\n\n private:\n  void getDists(TreeNode* root, int k,\n                unordered_map<TreeNode*, int>& nodeToDist) {\n    if (root == nullptr)\n      return;\n    if (root->val == k) {\n      nodeToDist[root] = 0;\n      return;\n    }\n\n    getDists(root->left, k, nodeToDist);\n    if (const auto it = nodeToDist.find(root->left); it != nodeToDist.cend()) {\n      nodeToDist[root] = it->second + 1;\n      return;\n    }\n\n    getDists(root->right, k, nodeToDist);\n    if (const auto it = nodeToDist.find(root->right); it != nodeToDist.cend())\n      nodeToDist[root] = it->second + 1;\n  }\n\n  void dfs(TreeNode* root, int dist,\n                      unordered_map<TreeNode*, int>& nodeToDist, int& minDist,\n                      int& ans) {\n    if (root == nullptr)\n      return;\n    if (nodeToDist.contains(root))\n      dist = nodeToDist[root];\n    if (root->left == nullptr && root->right == nullptr) {\n      if (dist < minDist) {\n        minDist = dist;\n        ans = root->val;\n      }\n      return;\n    }\n\n    dfs(root->left, dist + 1, nodeToDist, minDist, ans);\n    dfs(root->right, dist + 1, nodeToDist, minDist, ans);\n  }\n};"
    }
  },
  "743": {
    "solution": {
      "shortest-path": "import java.util.*;\n\npublic class Solution {\n\n    public int networkDelayTime(int[][] times, int totalNodes, int sourceNode) {\n        // Build adjacency list: node -> list of [neighbor, time]\n        Map<Integer, List<int[]>> adjacencyMap = new HashMap<>();\n        for (int[] edge : times) {\n            int from = edge[0], to = edge[1], weight = edge[2];\n            adjacencyMap.computeIfAbsent(from, k -> new ArrayList<>()).add(new int[]{to, weight});\n        }\n\n        // Min-heap priority queue: [currentTime, currentNode]\n        PriorityQueue<int[]> minHeap = new PriorityQueue<>(Comparator.comparingInt(a -> a[0]));\n        minHeap.offer(new int[]{0, sourceNode});\n\n        Map<Integer, Integer> shortestTimeToNode = new HashMap<>();\n\n        while (!minHeap.isEmpty()) {\n            int[] current = minHeap.poll();\n            int currentTime = current[0];\n            int currentNode = current[1];\n\n            if (shortestTimeToNode.containsKey(currentNode)) continue;\n\n            shortestTimeToNode.put(currentNode, currentTime);\n\n            if (adjacencyMap.containsKey(currentNode)) {\n                for (int[] neighbor : adjacencyMap.get(currentNode)) {\n                    int neighborNode = neighbor[0];\n                    int travelTime = neighbor[1];\n\n                    if (!shortestTimeToNode.containsKey(neighborNode)) {\n                        minHeap.offer(new int[]{currentTime + travelTime, neighborNode});\n                    }\n                }\n            }\n        }\n\n        // If we couldn't reach all nodes\n        if (shortestTimeToNode.size() != totalNodes) {\n            return -1;\n        }\n\n        int maxTime = 0;\n        for (int time : shortestTimeToNode.values()) {\n            maxTime = Math.max(maxTime, time);\n        }\n\n        return maxTime;\n    }\n\n    public static void main(String[] args) {\n        Solution solver = new Solution();\n        int[][] times = {\n            {2, 1, 1},\n            {2, 3, 1},\n            {3, 4, 1}\n        };\n        int totalNodes = 4;\n        int sourceNode = 2;\n\n        int result = solver.networkDelayTime(times, totalNodes, sourceNode);\n        System.out.println(\"Minimum time for all nodes to receive signal: \" + result);\n    }\n}"
    }
  },
  "744": {
    "solution": {
      "array": ""
    }
  },
  "745": {
    "solution": {
      "design": "class TrieNode {\n    TrieNode[] children;\n    int weight;\n\n    public TrieNode() {\n        children = new TrieNode[27]; // 26 letters + '{'\n        weight = -1;\n    }\n}\n\nclass Trie {\n    private TrieNode root;\n\n    public Trie() {\n        root = new TrieNode();\n    }\n\n    public void insert(String word, int weight) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = (c == '{') ? 26 : c - 'a';\n            if (node.children[index] == null) {\n                node.children[index] = new TrieNode();\n            }\n            node = node.children[index];\n            node.weight = weight;\n        }\n    }\n\n    public int startsWith(String word) {\n        TrieNode node = root;\n        for (char c : word.toCharArray()) {\n            int index = (c == '{') ? 26 : c - 'a';\n            if (node.children[index] == null) return -1;\n            node = node.children[index];\n        }\n        return node.weight;\n    }\n}\n\nclass WordFilter {\n    private Trie trie;\n\n    public WordFilter(String[] words) {\n        trie = new Trie();\n        for (int weight = 0; weight < words.length; weight++) {\n            String word = words[weight];\n            for (int i = 0; i <= word.length(); i++) {\n                String suffixPrefix = word.substring(i) + '{' + word;\n                trie.insert(suffixPrefix, weight);\n            }\n        }\n    }\n\n    public int f(String prefix, String suffix) {\n        return trie.startsWith(suffix + '{' + prefix);\n    }\n}"
    }
  },
  "746": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int minCostClimbingStairs(int[] cost) {\n        int n = cost.length;\n        int[] dp = new int[n + 1];\n\n        dp[0] = 0;\n        dp[1] = 0;\n\n        for (int i = 2; i <= n; i++) {\n            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);\n        }\n\n        return dp[n];\n    }\n}"
    }
  },
  "747": {
    "solution": {
      "sorting": "class Solution {\n    public int dominantIndex(int[] nums) {\n        int max1 = -1, max2 = -1, maxIndex = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] > max1) {\n                max2 = max1;\n                max1 = nums[i];\n                maxIndex = i;\n            } else if (nums[i] > max2) {\n                max2 = nums[i];\n            }\n        }\n\n        return (max1 >= 2 * max2) ? maxIndex : -1;\n    }\n}"
    }
  },
  "748": {
    "solution": {
      "hash-table": ""
    }
  },
  "749": {
    "solution": {
      "matrix": ""
    }
  },
  "750": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int countCornerRectangles(int[][] grid) {\n        int n = grid[0].length;\n        int ans = 0;\n        Map<String, Integer> countMap = new HashMap<>();\n\n        for (int[] row : grid) {\n            for (int i = 0; i < n; ++i) {\n                if (row[i] == 1) {\n                    for (int j = i + 1; j < n; ++j) {\n                        if (row[j] == 1) {\n                            String key = i + \",\" + j;\n                            int cnt = countMap.getOrDefault(key, 0);\n                            ans += cnt;\n                            countMap.put(key, cnt + 1);\n                        }\n                    }\n                }\n            }\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "751": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "752": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "753": {
    "solution": {
      "eulerian-circuit": "class Solution {\n\n    public String crackSafe(int n, int k) {\n        if (n == 1) {\n            StringBuilder sb = new StringBuilder();\n            for (int i = 0; i < k; i++) {\n                sb.append(i);\n            }\n            return sb.toString();\n        }\n\n        StringBuilder result = new StringBuilder();\n        Set<String> visited = new HashSet<>();\n        Stack<String> stack = new Stack<>();\n        String start = String.join('', Collections.nCopies(n - 1, '0'));\n        stack.push(start);\n\n        while (!stack.isEmpty()) {\n            String node = stack.peek();\n            boolean hasUnvisitedEdge = false;\n\n            // Try all possible edges from this node by appending each digit from 0 to k-1\n            for (int i = 0; i < k; i++) {\n                String next = node + i;\n                if (!visited.contains(next)) {\n                    visited.add(next);\n                    stack.push(next.substring(1));\n                    hasUnvisitedEdge = true;\n                    break;\n                }\n            }\n\n            // If all edges from this node are visited, backtrack and append the last\n            // character to the result\n            if (!hasUnvisitedEdge) {\n                result.append(stack.pop().charAt(node.length() - 1));\n            }\n        }\n\n        result.append(start.substring(0, start.length() - 1));\n        return result.toString();\n    }\n\n    // public String crackSafe(int n, int k) {\n    // StringBuilder result = new StringBuilder();\n    // Set<String> visited = new HashSet<>();\n    // String start = String.join('', Collections.nCopies(n - 1, '0'));\n    // dfs(start, k, visited, result, n);\n    // result.append(start);\n    // return result.toString();\n    // }\n    // private void dfs(String node, int k, Set<String> visited, StringBuilder\n    // result, int n) {\n    // for (int i = 0; i < k; i++) {\n    // String next = node + i;\n    // if (!visited.contains(next)) {\n    // visited.add(next);\n    // dfs(next.substring(1), k, visited, result, n);\n    // result.append(i);\n    // }\n    // }\n    // }\n\n}"
    }
  },
  "754": {
    "solution": {
      "math": ""
    }
  },
  "755": {
    "solution": {
      "array": ""
    }
  },
  "756": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "757": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int intersectionSizeTwo(int[][] intervals) {\n        Arrays.sort(intervals, (a, b) -> a[1] != b[1] ? a[1] - b[1] : b[0] - a[0]);\n\n        int largest = -1, secondLargest = -1, count = 0;\n        for (int[] interval : intervals) {\n            int start = interval[0], end = interval[1];\n\n            if (start > largest) {\n                count += 2;\n                secondLargest = end - 1;\n                largest = end;\n            } else if (start > secondLargest) {\n                count += 1;\n                secondLargest = largest;\n                largest = end;\n            }\n        }\n\n        return count;\n    }\n}"
    }
  },
  "758": {
    "solution": {
      "string-matching": ""
    }
  },
  "759": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "760": {
    "solution": {
      "hash-table": ""
    }
  },
  "761": {
    "solution": {
      "recursion": ""
    }
  },
  "762": {
    "solution": {
      "bit-manipulation": "import java.util.*;\n\nclass Solution {\n    private static final Set<Integer> PRIME_SET = new HashSet<>(Arrays.asList(\n        2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31\n    ));\n\n    public int countPrimeSetBits(int left, int right) {\n        int count = 0;\n        for (int num = left; num <= right; ++num) {\n            if (PRIME_SET.contains(Integer.bitCount(num))) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"
    }
  },
  "763": {
    "solution": {
      "two-pointers": ""
    }
  },
  "764": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "765": {
    "solution": {
      "graph": "class UnionFind {\n    private int[] parent, rank;\n    private int count;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        count = n;\n        for (int i = 0; i < n; i++) parent[i] = i;\n    }\n\n    public int find(int x) {\n        if (parent[x] != x)\n            parent[x] = find(parent[x]);\n        return parent[x];\n    }\n\n    public void union(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px == py) return;\n        if (rank[px] < rank[py]) parent[px] = py;\n        else if (rank[px] > rank[py]) parent[py] = px;\n        else {\n            parent[py] = px;\n            rank[px]++;\n        }\n        count--;\n    }\n\n    public int getCount() {\n        return count;\n    }\n}\n\nclass Solution {\n    public int minSwapsCouples(int[] row) {\n        int n = row.length / 2;\n        UnionFind uf = new UnionFind(n);\n        for (int i = 0; i < row.length; i += 2) {\n            uf.union(row[i] / 2, row[i + 1] / 2);\n        }\n        return n - uf.getCount();\n    }\n}"
    }
  },
  "766": {
    "solution": {
      "matrix": "class Solution {\n  public boolean isToeplitzMatrix(int[][] matrix) {\n    for (int i = 0; i + 1 < matrix.length; ++i)\n      for (int j = 0; j + 1 < matrix[0].length; ++j)\n        if (matrix[i][j] != matrix[i + 1][j + 1])\n          return false;\n    return true;\n  }\n}"
    }
  },
  "767": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "768": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int n = arr.length;\n        Stack<Integer> stack = new Stack<>();\n\n        for (int i = 0; i < n; i++) {\n            int max = arr[i];\n            while (!stack.isEmpty() && stack.peek() > arr[i]) {\n                max = Math.max(max, stack.pop());\n            }\n            stack.push(max);\n        }\n\n        return stack.size();\n    }\n}\n"
    }
  },
  "769": {
    "solution": {
      "monotonic-stack": "public class Solution {\n    public int maxChunksToSorted(int[] arr) {\n        int maxChunks = 0;\n        int maxElement = 0;\n\n        for (int i = 0; i < arr.length; i++) {\n            maxElement = Math.max(maxElement, arr[i]);\n            if (maxElement == i) {\n                maxChunks++;\n            }\n        }\n\n        return maxChunks;\n    }\n}\n"
    }
  },
  "770": {
    "solution": {
      "stack": ""
    }
  },
  "771": {
    "solution": {
      "hash-table": ""
    }
  },
  "772": {
    "solution": {
      "stack": ""
    }
  },
  "773": {
    "solution": {
      "matrix": ""
    }
  },
  "774": {
    "solution": {
      "array": ""
    }
  },
  "775": {
    "solution": {
      "math": ""
    }
  },
  "776": {
    "solution": {
      "binary-search-tree": "class Solution {\n    private int target;\n\n    public TreeNode[] splitBST(TreeNode root, int target) {\n        this.target = target;\n        return split(root);\n    }\n\n    private TreeNode[] split(TreeNode node) {\n        if (node == null) {\n            return new TreeNode[]{null, null};\n        }\n\n        if (node.val <= target) {\n            TreeNode[] rightSplit = split(node.right);\n            node.right = rightSplit[0];\n            rightSplit[0] = node;\n            return rightSplit;\n        } else {\n            TreeNode[] leftSplit = split(node.left);\n            node.left = leftSplit[1];\n            leftSplit[1] = node;\n            return leftSplit;\n        }\n    }\n}"
    }
  },
  "777": {
    "solution": {
      "two-pointers": ""
    }
  },
  "778": {
    "solution": {
      "union-find": ""
    }
  },
  "779": {
    "solution": {
      "recursion": "class Solution {\n    public int kthGrammar(int n, int k) {\n        if (n == 1 && k == 1) return 0;\n        int mid = 1 << (n - 2);\n        if (k <= mid) return kthGrammar(n - 1, k);\n        return 1 - kthGrammar(n - 1, k - mid);\n    }\n}"
    }
  },
  "780": {
    "solution": {
      "math": "class Solution {\n    public boolean reachingPoints(int sx, int sy, int tx, int ty) {\n        while (sx < tx && sy < ty) {\n            if (tx > ty) tx %= ty;\n            else ty %= tx;\n        }\n        return (sx == tx && sy <= ty && (ty - sy) % sx == 0) ||\n               (sy == ty && sx <= tx && (tx - sx) % sy == 0);\n    }\n}"
    }
  },
  "781": {
    "solution": {
      "greedy": ""
    }
  },
  "782": {
    "solution": {
      "matrix": "class Solution {\n  public int movesToChessboard(int[][] board) {\n    final int n = board.length;\n    int rowSum = 0;\n    int colSum = 0;\n    int rowSwaps = 0;\n    int colSwaps = 0;\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j)\n        if ((board[0][0] ^ board[i][0] ^ board[0][j] ^ board[i][j]) == 1)\n          return -1;\n\n    for (int i = 0; i < n; ++i) {\n      rowSum += board[0][i];\n      colSum += board[i][0];\n    }\n\n    if (rowSum != n / 2 && rowSum != (n + 1) / 2)\n      return -1;\n    if (colSum != n / 2 && colSum != (n + 1) / 2)\n      return -1;\n\n    for (int i = 0; i < n; ++i) {\n      if (board[i][0] == (i & 1))\n        ++rowSwaps;\n      if (board[0][i] == (i & 1))\n        ++colSwaps;\n    }\n\n    if (n % 2 == 1) {\n      if (rowSwaps % 2 == 1)\n        rowSwaps = n - rowSwaps;\n      if (colSwaps % 2 == 1)\n        colSwaps = n - colSwaps;\n    } else {\n      rowSwaps = Math.min(rowSwaps, n - rowSwaps);\n      colSwaps = Math.min(colSwaps, n - colSwaps);\n    }\n\n    return (rowSwaps + colSwaps) / 2;\n  }\n}"
    }
  },
  "783": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private Integer prev;\n    private int minDiff;\n\n    public int minDiffInBST(TreeNode root) {\n        minDiff = Integer.MAX_VALUE;\n        prev = null;\n        inorder(root);\n        return minDiff;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        \n        if (prev != null) {\n            minDiff = Math.min(minDiff, node.val - prev);\n        }\n        prev = node.val;\n        \n        inorder(node.right);\n    }\n}\n"
    }
  },
  "784": {
    "solution": {
      "backtracking": "class Solution {\n    public List<String> letterCasePermutation(String S) {\n        List<String> ans = new ArrayList<>();\n        dfs(new StringBuilder(S), 0, ans);\n        return ans;\n    }\n\n    private void dfs(StringBuilder sb, int i, List<String> ans) {\n        if (i == sb.length()) {\n            ans.add(sb.toString());\n            return;\n        }\n        if (Character.isDigit(sb.charAt(i))) {\n            dfs(sb, i + 1, ans);\n            return;\n        }\n        sb.setCharAt(i, Character.toLowerCase(sb.charAt(i)));\n        dfs(sb, i + 1, ans);\n        sb.setCharAt(i, Character.toUpperCase(sb.charAt(i)));\n        dfs(sb, i + 1, ans);\n    }\n}\n"
    }
  },
  "785": {
    "solution": {
      "graph": "class Solution {\n    public boolean isBipartite(int[][] graph) {\n        int n = graph.length;\n        int[] color = new int[n]; // 0: unvisited, 1: color1, -1: color2\n\n        for (int i = 0; i < n; i++) {\n            if (color[i] != 0)\n                continue; // already visited\n\n            Queue<Integer> queue = new LinkedList<>();\n            queue.offer(i);\n            color[i] = 1;\n\n            while (!queue.isEmpty()) {\n                int curr = queue.poll();\n\n                for (int neighbor : graph[curr]) {\n                    if (color[neighbor] == 0) {\n                        color[neighbor] = -color[curr]; // assign opposite color\n                        queue.offer(neighbor);\n                    } else if (color[neighbor] == color[curr]) {\n                        return false; // same color neighbor => not bipartite\n                    }\n                }\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "786": {
    "solution": {
      "heap-(priority-queue)": "import java.util.PriorityQueue;\n\npublic class Solution {\n    public int[] kthSmallestPrimeFraction(int[] arr, int k) {\n        int n = arr.length;\n        PriorityQueue<Fraction> minHeap = new PriorityQueue<>((a, b) -> Double.compare(a.value, b.value));\n\n        for (int i = 0; i < n - 1; i++) {\n            minHeap.offer(new Fraction(i, n - 1, (double) arr[i] / arr[n - 1]));\n        }\n\n        Fraction fraction = null;\n        for (int i = 0; i < k; i++) {\n            fraction = minHeap.poll();\n            int numeratorIndex = fraction.numeratorIndex;\n            int denominatorIndex = fraction.denominatorIndex;\n            if (denominatorIndex - 1 > numeratorIndex) {\n                minHeap.offer(new Fraction(numeratorIndex, denominatorIndex - 1,\n                        (double) arr[numeratorIndex] / arr[denominatorIndex - 1]));\n            }\n        }\n\n        return new int[] { arr[fraction.numeratorIndex], arr[fraction.denominatorIndex] };\n    }\n\n    private static class Fraction {\n        int numeratorIndex;\n        int denominatorIndex;\n        double value;\n\n        Fraction(int numeratorIndex, int denominatorIndex, double value) {\n            this.numeratorIndex = numeratorIndex;\n            this.denominatorIndex = denominatorIndex;\n            this.value = value;\n        }\n    }\n}\n"
    }
  },
  "787": {
    "solution": {
      "heap-(priority-queue)": "import java.util.*;\n\npublic class Solution {\n\n    static class Route {\n        int city, cost, stops;\n        Route(int city, int cost, int stops) {\n            this.city = city;\n            this.cost = cost;\n            this.stops = stops;\n        }\n    }\n\n    public int findCheapestPrice(int n, int[][] flights, int src, int dst, int k) {\n        // Build graph: from -> list of Route(to, cost, stops=0 not used in graph)\n        Map<Integer, List<Route>> graph = new HashMap<>();\n        for (int[] flight : flights) {\n            int from = flight[0], to = flight[1], price = flight[2];\n            graph.computeIfAbsent(from, x -> new ArrayList<>()).add(new Route(to, price, 0));\n        }\n\n        // Min-heap sorted by cost\n        PriorityQueue<Route> pq = new PriorityQueue<>(Comparator.comparingInt(r -> r.cost));\n        pq.offer(new Route(src, 0, 0));\n\n        // Track best known cost to reach (city, stops)\n        Map<String, Integer> visited = new HashMap<>();\n\n        while (!pq.isEmpty()) {\n            Route current = pq.poll();\n\n            if (current.city == dst) return current.cost;\n\n            String key = current.city + \",\" + current.stops;\n            if (visited.containsKey(key) && visited.get(key) <= current.cost) continue;\n            visited.put(key, current.cost);\n\n            if (current.stops > k) continue;\n\n            if (graph.containsKey(current.city)) {\n                for (Route neighbor : graph.get(current.city)) {\n                    pq.offer(new Route(neighbor.city, current.cost + neighbor.cost, current.stops + 1));\n                }\n            }\n        }\n\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solver = new Solution();\n        int[][] flights = {\n            {0, 1, 100},\n            {1, 2, 100},\n            {2, 3, 100},\n            {0, 2, 500}\n        };\n        int n = 4, src = 0, dst = 3, k = 1;\n\n        int result = solver.findCheapestPrice(n, flights, src, dst, k);\n        System.out.println(\"Cheapest price: \" + result);  // Output: 600\n    }\n}"
    }
  },
  "788": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "789": {
    "solution": {
      "math": ""
    }
  },
  "790": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "791": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public String customSortString(String order, String s) {\n        Map<Character, Integer> freq = new HashMap<>();\n        for (char c : s.toCharArray()) {\n            freq.put(c, freq.getOrDefault(c, 0) + 1);\n        }\n\n        StringBuilder sb = new StringBuilder();\n        for (char c : order.toCharArray()) {\n            if (freq.containsKey(c)) {\n                for (int i = 0; i < freq.get(c); i++) sb.append(c);\n                freq.remove(c);\n            }\n        }\n\n        for (Map.Entry<Character, Integer> entry : freq.entrySet()) {\n            for (int i = 0; i < entry.getValue(); i++) sb.append(entry.getKey());\n        }\n\n        return sb.toString();\n    }\n}"
    }
  },
  "792": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "793": {
    "solution": {
      "math": ""
    }
  },
  "794": {
    "solution": {
      "matrix": "class Solution {\n  public boolean validTicTacToe(String[] board) {\n    final int countX = sum(board, 'X');\n    final int countO = sum(board, 'O');\n\n    if (countX < countO || countX - countO > 1)\n      return false;\n    if (isWinned(board, 'X') && countX == countO ||\n        isWinned(board, 'O') && countX != countO)\n      return false;\n\n    return true;\n  }\n\n  private int sum(final String[] board, char c) {\n    int ans = 0;\n\n    for (String row : board)\n      ans += row.chars().filter(i -> i == c).count();\n\n    return ans;\n  }\n\n  private boolean isWinned(final String[] board, char c) {\n    String[] rotated = rotate(board);\n\n    return Arrays.stream(board).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\n        || Arrays.stream(rotated).anyMatch(row -> row.chars().filter(i -> i == c).count() == 3)\n        || board[0].charAt(0) == c && board[1].charAt(1) == c && board[2].charAt(2) == c\n        || board[0].charAt(2) == c && board[1].charAt(1) == c && board[2].charAt(0) == c;\n  }\n\n  private String[] rotate(final String[] board) {\n    String[] rotated = new String[3];\n\n    for (final String row : board)\n      for (int i = 0; i < 3; ++i)\n        rotated[i] += row.charAt(i);\n\n    return rotated;\n  }\n}"
    }
  },
  "795": {
    "solution": {
      "two-pointers": ""
    }
  },
  "796": {
    "solution": {
      "string-matching": "class Solution {\n    public boolean rotateString(String s, String goal) {\n        return s.length() == goal.length() && (s + s).contains(goal);\n    }\n}"
    }
  },
  "797": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    public List<List<Integer>> allPathsSourceTarget(int[][] graph) {\n        List<List<Integer>> result = new ArrayList<>();\n        List<Integer> path = new ArrayList<>();\n        dfs(graph, 0, path, result);\n        return result;\n    }\n\n    private void dfs(int[][] graph, int node, List<Integer> path, List<List<Integer>> result) {\n        path.add(node);\n        if (node == graph.length - 1) {\n            result.add(new ArrayList<>(path));\n        } else {\n            for (int next : graph[node]) {\n                dfs(graph, next, path, result);\n            }\n        }\n        path.remove(path.size() - 1);\n    }\n}"
    }
  },
  "798": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "799": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "800": {
    "solution": {
      "enumeration": ""
    }
  },
  "801": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "802": {
    "solution": {
      "graph": "class Solution {\n    public List<Integer> eventualSafeNodes(int[][] graph) {\n        int n = graph.length;\n        \n        List<List<Integer>> reversedGraph = new ArrayList<>();\n        int[] inDegree = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            reversedGraph.add(new ArrayList<>());\n        }\n\n        // Reverse the graph\n        for (int from = 0; from < n; from++) {\n            for (int to : graph[from]) {\n                reversedGraph.get(to).add(from);\n                inDegree[from]++;\n            }\n        }\n\n        // Kahns algorithm\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        boolean[] safe = new boolean[n];\n\n        while (!queue.isEmpty()) {\n            int node = queue.poll();\n            safe[node] = true;\n            for (int neighbor : reversedGraph.get(node)) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        List<Integer> result = new ArrayList<>();\n        for (int i = 0; i < n; i++) {\n            if (safe[i]) result.add(i);\n        }\n\n        return result;\n    }\n}"
    }
  },
  "803": {
    "solution": {
      "union-find": ""
    }
  },
  "804": {
    "solution": {
      "hash-table": ""
    }
  },
  "805": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "806": {
    "solution": {
      "string": ""
    }
  },
  "807": {
    "solution": {
      "greedy": "class Solution {\n    public int maxIncreaseKeepingSkyline(int[][] grid) {\n        int n = grid.length;\n        int[] rowMax = new int[n];\n        int[] colMax = new int[n];\n\n        // Find the max of each row and column\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                rowMax[i] = Math.max(rowMax[i], grid[i][j]);\n                colMax[j] = Math.max(colMax[j], grid[i][j]);\n            }\n        }\n\n        int totalIncrease = 0;\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                totalIncrease += Math.min(rowMax[i], colMax[j]) - grid[i][j];\n            }\n        }\n\n        return totalIncrease;\n    }\n}"
    }
  },
  "808": {
    "solution": {
      "probability-and-statistics": "class Solution {\n    public double soupServings(int n) {\n        // If n is large, directly return 1.0 as per problem statement\n        if (n >= 4800) return 1.0;\n        \n        // We need to calculate up to 2 * n\n        int m = n / 25 + (n % 25 == 0 ? 0 : 1);\n        \n        // dp[i][j] represents the probability that Chef A has i ml and Chef B has j ml\n        double[][] dp = new double[m + 1][m + 1];\n        \n        dp[0][0] = 0.5; // Both soups are empty initially\n        for (int i = 1; i <= m; i++) {\n            dp[0][i] = 1.0; // Chef A's soup is empty, Chef A has already lost\n            dp[i][0] = 0.0; // Chef B's soup is empty, Chef A wins\n        }\n        \n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= m; j++) {\n                dp[i][j] = 0.25 * (dp[Math.max(0, i - 4)][j] +\n                                   dp[Math.max(0, i - 3)][Math.max(0, j - 1)] +\n                                   dp[Math.max(0, i - 2)][Math.max(0, j - 2)] +\n                                   dp[Math.max(0, i - 1)][Math.max(0, j - 3)]);\n            }\n        }\n        \n        // The probability that both soups are empty at the same time when n ml are consumed in total\n        return dp[m][m];\n    }\n}\n"
    }
  },
  "809": {
    "solution": {
      "two-pointers": ""
    }
  },
  "810": {
    "solution": {
      "brainteaser": ""
    }
  },
  "811": {
    "solution": {
      "counting": ""
    }
  },
  "812": {
    "solution": {
      "geometry": ""
    }
  },
  "813": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "814": {
    "solution": {
      "tree": ""
    }
  },
  "815": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "816": {
    "solution": {
      "backtracking": ""
    }
  },
  "817": {
    "solution": {
      "linked-list": ""
    }
  },
  "818": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "819": {
    "solution": {
      "counting": ""
    }
  },
  "820": {
    "solution": {
      "trie": ""
    }
  },
  "821": {
    "solution": {
      "two-pointers": ""
    }
  },
  "822": {
    "solution": {
      "brute-force": "class Solution {\n    public int flipgame(int[] fronts, int[] backs) {\n        Set<Integer> same = new HashSet<>();\n        int n = fronts.length;\n\n        for (int i = 0; i < n; i++) {\n            if (fronts[i] == backs[i]) {\n                same.add(fronts[i]);\n            }\n        }\n\n        int res = Integer.MAX_VALUE;\n        for (int i = 0; i < n; i++) {\n            if (!same.contains(fronts[i])) {\n                res = Math.min(res, fronts[i]);\n            }\n            if (!same.contains(backs[i])) {\n                res = Math.min(res, backs[i]);\n            }\n        }\n\n        return res == Integer.MAX_VALUE ? 0 : res;\n    }\n}"
    }
  },
  "823": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "824": {
    "solution": {
      "string": ""
    }
  },
  "825": {
    "solution": {
      "two-pointers": ""
    }
  },
  "826": {
    "solution": {
      "two-pointers": ""
    }
  },
  "827": {
    "solution": {
      "matrix": "import java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int n;\n\n    public int largestIsland(int[][] grid) {\n        n = grid.length;\n        Map<Integer, Integer> islandAreaMap = new HashMap<>();\n        int islandId = 2;  \n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                if (grid[r][c] == 1) {\n                    int area = dfs(grid, r, c, islandId);\n                    islandAreaMap.put(islandId, area);\n                    islandId++;\n                }\n            }\n        }\n\n        int maxArea = islandAreaMap.values().stream().max(Integer::compare).orElse(0);  // In case all cells are 1s\n\n        for (int r = 0; r < n; r++) {\n            for (int c = 0; c < n; c++) {\n                if (grid[r][c] == 0) {\n                    Set<Integer> neighboringIslands = new HashSet<>();\n                    int potentialArea = 1;  // Start with 1 for the flipped cell\n\n                    for (int[] dir : DIRECTIONS) {\n                        int nr = r + dir[0], nc = c + dir[1];\n                        if (isInBounds(nr, nc) && grid[nr][nc] > 1) {\n                            neighboringIslands.add(grid[nr][nc]);\n                        }\n                    }\n\n                    // Sum the areas of all unique neighboring islands\n                    for (int id : neighboringIslands) {\n                        potentialArea += islandAreaMap.get(id);\n                    }\n\n                    maxArea = Math.max(maxArea, potentialArea);\n                }\n            }\n        }\n\n        return maxArea;\n    }\n\n    private int dfs(int[][] grid, int r, int c, int islandId) {\n        if (!isInBounds(r, c) || grid[r][c] != 1) {\n            return 0;\n        }\n\n        grid[r][c] = islandId;\n        int area = 1;\n\n        for (int[] dir : DIRECTIONS) {\n            area += dfs(grid, r + dir[0], c + dir[1], islandId);\n        }\n\n        return area;\n    }\n\n    private boolean isInBounds(int r, int c) {\n        return r >= 0 && r < n && c >= 0 && c < n;\n    }\n}\n",
      "union-find": ""
    }
  },
  "828": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "829": {
    "solution": {
      "enumeration": ""
    }
  },
  "830": {
    "solution": {
      "string": ""
    }
  },
  "831": {
    "solution": {
      "string": ""
    }
  },
  "832": {
    "solution": {
      "matrix": "public class Solution {\n    public int[][] flipAndInvertImage(int[][] image) {\n        int rows = image.length, cols = image[0].length;\n\n        for (int i = 0; i < rows; i++) {\n            int left = 0, right = cols - 1;\n\n            while (left <= right) {\n                // Swap and invert simultaneously\n                int temp = image[i][left] ^ 1;\n                image[i][left] = image[i][right] ^ 1;\n                image[i][right] = temp;\n\n                left++;\n                right--;\n            }\n        }\n        return image;\n    }\n}"
    }
  },
  "833": {
    "solution": {
      "sorting": "class Solution {\n  public String findReplaceString(String S, int[] indexes, String[] sources, String[] targets) {\n    List<Pair<Integer, Integer>> sortedIndexes = new ArrayList<>();\n\n    for (int i = 0; i < indexes.length; ++i)\n      sortedIndexes.add(new Pair<>(indexes[i], i));\n\n    Collections.sort(sortedIndexes, (a, b) -> b.getKey() - a.getKey());\n\n    for (var sortedIndex : sortedIndexes) {\n      final int index = sortedIndex.getKey();\n      final int i = sortedIndex.getValue();\n      final String source = sources[i];\n      final String target = targets[i];\n      if (S.substring(index, index + source.length()).equals(source))\n        S = S.substring(0, index) + target + S.substring(index + source.length());\n    }\n\n    return S;\n  }\n}\n"
    }
  },
  "834": {
    "solution": {
      "graph": "class Solution {\n    private List<Set<Integer>> tree;\n    private int[] res;\n    private int[] count;\n\n    public int[] sumOfDistancesInTree(int n, int[][] edges) {\n        tree = new ArrayList<>();\n        res = new int[n];\n        count = new int[n];\n        // Step 1: Build the graph\n        for (int i = 0; i < n; i++) {\n            tree.add(new HashSet<>());\n        }\n        for (int[] edge : edges) {\n            tree.get(edge[0]).add(edge[1]);\n            tree.get(edge[1]).add(edge[0]);\n        }\n        // Step 2: Postorder traversal to fill count[] and res[] for root = 0\n        postorder(0, -1);\n        // Step 3: Preorder traversal to propagate res[] to all nodes\n        preorder(0, -1);\n        return res;\n    }\n\n    // Postorder traversal: bottom-up\n    // Postorder calculates initial values from leaves to root.\n    private void postorder(int node, int parent) {\n        for (int child : tree.get(node)) {\n            if (child == parent) continue;\n            postorder(child, node);\n            count[node] += count[child];\n            res[node] += res[child] + count[child];\n        }\n        count[node] += 1; // include self\n    }\n\n    // Preorder traversal: top-down rerooting\n    // Preorder reroots and spreads the correct values from root to children.\n    private void preorder(int node, int parent) {\n        for (int child : tree.get(node)) {\n            if (child == parent) continue;\n            res[child] = res[node] - count[child] + (count.length - count[child]);\n            preorder(child, node);\n        }\n    }\n}"
    }
  },
  "835": {
    "solution": {
      "matrix": "class Solution {\n  public int largestOverlap(int[][] A, int[][] B) {\n    int n = A.length;\n    int magic = 100;\n    int ans = 0;\n    List<int[]> onesA = new ArrayList<>();\n    List<int[]> onesB = new ArrayList<>();\n    Map<Integer, Integer> map = new HashMap<>();\n\n    for (int i = 0; i < n; ++i)\n      for (int j = 0; j < n; ++j) {\n        if (A[i][j] == 1)\n          onesA.add(new int[] {i, j});\n        if (B[i][j] == 1)\n          onesB.add(new int[] {i, j});\n      }\n\n    for (int[] a : onesA)\n      for (int[] b : onesB) {\n        final int key = (a[0] - b[0]) * magic + a[1] - b[1];\n        map.put(key, map.getOrDefault(key, 0) + 1);\n      }\n\n    for (final int value : map.values())\n      ans = Math.max(ans, value);\n\n    return ans;\n  }\n}\n"
    }
  },
  "836": {
    "solution": {
      "geometry": ""
    }
  },
  "837": {
    "solution": {
      "probability-and-statistics": "class Solution {\n    public double new21Game(int N, int K, int W) {\n        if (K == 0 || N >= K + W) return 1.0;\n        \n        double[] dp = new double[N + 1];\n        double sum = 0.0;\n        dp[0] = 1.0;\n        sum += dp[0];\n        \n        for (int i = 1; i <= N; i++) {\n            dp[i] = sum / W;\n            if (i < K) sum += dp[i];\n            if (i - W >= 0) sum -= dp[i - W];\n        }\n        \n        double probability = 0.0;\n        for (int i = K; i <= N; i++) {\n            probability += dp[i];\n        }\n        \n        return probability;\n    }\n}\n"
    }
  },
  "838": {
    "solution": {
      "dynamic-programming": "class Solution {\n public:\n  string pushDominoes(string dominoes) {\n    int L = -1;\n    int R = -1;\n\n    for (int i = 0; i <= dominoes.length(); ++i)\n      if (i == dominoes.length() || dominoes[i] == 'R') {\n        if (L < R)\n          while (R < i)\n            dominoes[R++] = 'R';\n        R = i;\n      } else if (dominoes[i] == 'L') {\n        if (R < L || L == -1 && R == -1) {\n          if (L == -1 && R == -1)\n            ++L;\n          while (L < i)\n            dominoes[L++] = 'L';\n        } else {\n          int l = R + 1;\n          int r = i - 1;\n          while (l < r) {\n            dominoes[l++] = 'R';\n            dominoes[r--] = 'L';\n          }\n        }\n        L = i;\n      }\n\n    return dominoes;\n  }\n};"
    }
  },
  "839": {
    "solution": {
      "union-find": ""
    }
  },
  "840": {
    "solution": {
      "matrix": "public class Solution {\n    public int numMagicSquaresInside(int[][] grid) {\n        int count = 0;\n        \n        for (int r = 0; r < grid.length - 2; r++) {\n            for (int c = 0; c < grid[0].length - 2; c++) {\n                if (isMagicSquare(grid, r, c)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n\n    private boolean isMagicSquare(int[][] grid, int r, int c) {\n        if (grid[r + 1][c + 1] != 5) return false;\n\n        boolean[] seen = new boolean[10];\n        for (int i = 0; i < 3; i++) {\n            for (int j = 0; j < 3; j++) {\n                int num = grid[r + i][c + j];\n                if (num < 1 || num > 9 || seen[num]) return false;\n                seen[num] = true;\n            }\n        }\n\n        return (grid[r][c] + grid[r][c + 1] + grid[r][c + 2] == 15) &&  // Row 1\n               (grid[r + 1][c] + grid[r + 1][c + 1] + grid[r + 1][c + 2] == 15) &&  // Row 2\n               (grid[r + 2][c] + grid[r + 2][c + 1] + grid[r + 2][c + 2] == 15) &&  // Row 3\n               (grid[r][c] + grid[r + 1][c] + grid[r + 2][c] == 15) &&  // Column 1\n               (grid[r][c + 1] + grid[r + 1][c + 1] + grid[r + 2][c + 1] == 15) &&  // Column 2\n               (grid[r][c + 2] + grid[r + 1][c + 2] + grid[r + 2][c + 2] == 15) &&  // Column 3\n               (grid[r][c] + grid[r + 1][c + 1] + grid[r + 2][c + 2] == 15) &&  // Diagonal 1\n               (grid[r][c + 2] + grid[r + 1][c + 1] + grid[r + 2][c] == 15);    // Diagonal 2\n    }\n}\n"
    }
  },
  "841": {
    "solution": {
      "graph": ""
    }
  },
  "842": {
    "solution": {
      "backtracking": ""
    }
  },
  "843": {
    "solution": {
      "interactive": ""
    }
  },
  "844": {
    "solution": {
      "two-pointers": ""
    }
  },
  "845": {
    "solution": {
      "two-pointers": ""
    }
  },
  "846": {
    "solution": {
      "greedy": ""
    }
  },
  "847": {
    "solution": {
      "bitmask-dp": "class Solution {\n    public int shortestPathLength(int[][] graph) {\n        int n = graph.length;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[n][1 << n];\n\n        for (int i = 0; i < n; i++) {\n            queue.offer(new int[]{i, 1 << i, 0}); // node, mask, dist\n            visited[i][1 << i] = true;\n        }\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int node = curr[0], mask = curr[1], dist = curr[2];\n\n            if (mask == (1 << n) - 1) {\n                return dist;\n            }\n\n            for (int neighbor : graph[node]) {\n                int nextMask = mask | (1 << neighbor);\n                if (!visited[neighbor][nextMask]) {\n                    visited[neighbor][nextMask] = true;\n                    queue.offer(new int[]{neighbor, nextMask, dist + 1});\n                }\n            }\n        }\n\n        return -1;\n    }\n}"
    }
  },
  "848": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "849": {
    "solution": {
      "array": ""
    }
  },
  "850": {
    "solution": {
      "line-sweep": "class Event {\n  public int x;\n  public int y1;\n  public int y2;\n  public char type;\n  public Event(int x, int y1, int y2, char type) {\n    this.x = x;\n    this.y1 = y1;\n    this.y2 = y2;\n    this.type = type;\n  }\n}\n\nclass Solution {\n  public int rectangleArea(int[][] rectangles) {\n  int kMod = 1_000_000_007;\n    List<Event> events = new ArrayList<>();\n\n    for (int[] right : rectangles) {\n      events.add(new Event(right[0], right[1], right[3], 's'));\n      events.add(new Event(right[2], right[1], right[3], 'e'));\n    }\n\n    Collections.sort(events, (a, b) -> a.x - b.x);\n\n    long ans = 0;\n    int prevX = 0;\n    List<Pair<Integer, Integer>> yPairs = new ArrayList<>();\n\n    for (Event e : events) {\n      if (e.x > prevX) {\n      int width = e.x - prevX;\n        ans = (ans + width * getHeight(yPairs)) % kMod;\n        prevX = e.x;\n      }\n      if (e.type == 's') {\n        yPairs.add(new Pair<>(e.y1, e.y2));\n        Collections.sort(yPairs, Comparator.comparing(Pair::getKey));\n      } else { // type == 'e'\n        yPairs.remove(new Pair<>(e.y1, e.y2));\n      }\n    }\n\n    return (int) (ans % kMod);\n  }\n\n  private long getHeight(List<Pair<Integer, Integer>> yPairs) {\n    int height = 0;\n    int prevY = 0;\n\n    for (Pair<Integer, Integer> pair : yPairs) {\n    int y1 = pair.getKey();\n    int y2 = pair.getValue();\n      prevY = Math.max(prevY, y1);\n      if (y2 > prevY) {\n        height += y2 - prevY;\n        prevY = y2;\n      }\n    }\n\n    return height;\n  }\n}"
    }
  },
  "851": {
    "solution": {
      "topological-sort": ""
    }
  },
  "852": {
    "solution": {
      "binary-search": "class Solution {\n    public int peakIndexInMountainArray(int[] arr) {\n        int low = 0, high = arr.length - 1;\n\n        while (low < high) {\n            int mid = low + (high - low) / 2;\n\n            if (arr[mid] < arr[mid + 1]) {\n                low = mid + 1;\n            } else {\n                high = mid;\n            }\n        }\n\n        return low;\n    }\n}"
    }
  },
  "853": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "854": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "855": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "856": {
    "solution": {
      "stack": ""
    }
  },
  "857": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "858": {
    "solution": {
      "geometry": ""
    }
  },
  "859": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public boolean buddyStrings(String s, String goal) {\n        if (s.length() != goal.length()) {\n            return false;\n        }\n\n        if (s.equals(goal)) {\n            Set<Character> seen = new HashSet<>();\n            for (char c : s.toCharArray()) {\n                if (seen.contains(c)) {\n                    return true; // has duplicate\n                }\n                seen.add(c);\n            }\n            return false;\n        }\n\n        List<Integer> diff = new ArrayList<>();\n        for (int i = 0; i < s.length(); i++) {\n            if (s.charAt(i) != goal.charAt(i)) {\n                diff.add(i);\n            }\n        }\n\n        return diff.size() == 2 &&\n               s.charAt(diff.get(0)) == goal.charAt(diff.get(1)) &&\n               s.charAt(diff.get(1)) == goal.charAt(diff.get(0));\n    }\n}"
    }
  },
  "860": {
    "solution": {
      "greedy": ""
    }
  },
  "861": {
    "solution": {
      "matrix": ""
    }
  },
  "862": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n\n    public int shortestSubarray(int[] nums, int K) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        Deque<Integer> deque = new LinkedList<>();\n        int minLength = Integer.MAX_VALUE;\n        \n        for (int i = 0; i <= n; i++) {\n            while (!deque.isEmpty() && prefixSum[i] - prefixSum[deque.peekFirst()] >= K) {\n                minLength = Math.min(minLength, i - deque.pollFirst());\n            }            \n            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.addLast(i);\n        }\n        \n        return minLength == Integer.MAX_VALUE ? -1 : minLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {2, -1, 2};\n        int K = 3;\n        System.out.println(solution.shortestSubarray(nums, K)); \n    }\n}\n"
    }
  },
  "863": {
    "solution": {
      "binary-tree": "import java.util.*;\n\nclass Solution {\n    public List<Integer> distanceK(TreeNode root, TreeNode target, int k) {\n        Map<TreeNode, TreeNode> parentMap = new HashMap<>();\n        buildParentMap(root, null, parentMap);\n\n        Set<TreeNode> visited = new HashSet<>();\n        Queue<Pair<TreeNode, Integer>> queue = new LinkedList<>();\n        queue.offer(new Pair<>(target, 0));\n        visited.add(target);\n\n        List<Integer> result = new ArrayList<>();\n        while (!queue.isEmpty()) {\n            Pair<TreeNode, Integer> curr = queue.poll();\n            TreeNode node = curr.getKey();\n            int dist = curr.getValue();\n\n            if (dist == k) {\n                result.add(node.val);\n            }\n\n            if (dist < k) {\n                for (TreeNode neighbor : Arrays.asList(node.left, node.right, parentMap.get(node))) {\n                    if (neighbor != null && !visited.contains(neighbor)) {\n                        visited.add(neighbor);\n                        queue.offer(new Pair<>(neighbor, dist + 1));\n                    }\n                }\n            }\n        }\n\n        return result;\n    }\n\n    private void buildParentMap(TreeNode node, TreeNode parent, Map<TreeNode, TreeNode> parentMap) {\n        if (node == null) return;\n        parentMap.put(node, parent);\n        buildParentMap(node.left, node, parentMap);\n        buildParentMap(node.right, node, parentMap);\n    }\n\n    // TreeNode class definition assumed to be provided\n}"
    }
  },
  "864": {
    "solution": {
      "matrix": ""
    }
  },
  "865": {
    "solution": {
      "depth-first-search": "class Solution {\n    private class Result {\n        int depth;\n        TreeNode node;\n\n        Result(int depth, TreeNode node) {\n            this.depth = depth;\n            this.node = node;\n        }\n    }\n\n    public TreeNode subtreeWithAllDeepest(TreeNode root) {\n        return dfs(root).node;\n    }\n\n    private Result dfs(TreeNode node) {\n        if (node == null) return new Result(0, null);\n\n        Result left = dfs(node.left);\n        Result right = dfs(node.right);\n\n        if (left.depth == right.depth) {\n            return new Result(left.depth + 1, node);\n        } else if (left.depth > right.depth) {\n            return new Result(left.depth + 1, left.node);\n        } else {\n            return new Result(right.depth + 1, right.node);\n        }\n    }\n}"
    }
  },
  "866": {
    "solution": {
      "number-theory": ""
    }
  },
  "867": {
    "solution": {
      "matrix": "class Solution {\n    public int[][] transpose(int[][] matrix) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        int[][] result = new int[n][m];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[j][i] = matrix[i][j];\n            }\n        }\n\n        return result;\n    }\n}"
    }
  },
  "868": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int binaryGap(int n) {\n        int lastPosition = -1;\n        int maxGap = 0;\n        int currentPosition = 0;\n\n        while (n > 0) {\n            if ((n & 1) == 1) {\n                if (lastPosition != -1) {\n                    maxGap = Math.max(maxGap, currentPosition - lastPosition);\n                }\n                lastPosition = currentPosition;\n            }\n            n >>= 1;\n            currentPosition++;\n        }\n\n        return maxGap;\n    }\n}"
    }
  },
  "869": {
    "solution": {
      "counting": "import java.util.*;\n\nclass Solution {\n    private String countDigits(int num) {\n        int[] freq = new int[10];\n        while (num > 0) {\n            freq[num % 10]++;\n            num /= 10;\n        }\n        return Arrays.toString(freq);\n    }\n\n    public boolean reorderedPowerOf2(int n) {\n        String targetFreq = countDigits(n);\n\n        for (int i = 0; i < 31; ++i) {\n            int powerOf2 = 1 << i;\n            if (countDigits(powerOf2).equals(targetFreq)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "870": {
    "solution": {
      "two-pointers": ""
    }
  },
  "871": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "872": {
    "solution": {
      "tree": ""
    }
  },
  "873": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int lenLongestFibSubseq(int[] arr) {\n        int n = arr.length;\n        int maxLen = 0;\n        Map<Integer, Integer> indexMap = new HashMap<>();\n\n        for (int i = 0; i < n; i++) {\n            indexMap.put(arr[i], i);\n        }\n\n        int[][] dp = new int[n][n];\n\n        for (int j = 0; j < n; j++) {\n            for (int k = j + 1; k < n; k++) {\n                int ai = arr[k] - arr[j];\n                if (ai < arr[j] && indexMap.containsKey(ai)) {\n                    int i = indexMap.get(ai);\n                    dp[j][k] = dp[i][j] > 0 ? dp[i][j] + 1 : 3;\n                    maxLen = Math.max(maxLen, dp[j][k]);\n                }\n            }\n        }\n\n        return maxLen;\n    }\n}"
    }
  },
  "874": {
    "solution": {
      "hash-table": ""
    }
  },
  "875": {
    "solution": {
      "array": ""
    }
  },
  "876": {
    "solution": {
      "two-pointers": ""
    }
  },
  "877": {
    "solution": {
      "game-theory": "class Solution {\n    public boolean stoneGame(int[] piles) {\n        return true;\n    }\n}"
    }
  },
  "878": {
    "solution": {
      "math": ""
    }
  },
  "879": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "880": {
    "solution": {
      "stack": ""
    }
  },
  "881": {
    "solution": {
      "two-pointers": ""
    }
  },
  "882": {
    "solution": {
      "shortest-path": "class Solution {\n  public int reachableNodes(int[][] edges, int maxMoves, int n) {\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    Queue<int[]> minHeap = new PriorityQueue<>((a, b) -> a[0] - b[0]); // (d, u)\n    int[] dist = new int[n];\n    Arrays.fill(dist, maxMoves + 1);\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] e : edges) {\n      final int u = e[0];\n      final int v = e[1];\n      final int cnt = e[2];\n      graph[u].add(new Pair<>(v, cnt));\n      graph[v].add(new Pair<>(u, cnt));\n    }\n\n    minHeap.offer(new int[] {0, 0});\n    dist[0] = 0;\n\n    while (!minHeap.isEmpty()) {\n      final int d = minHeap.peek()[0];\n      final int u = minHeap.poll()[1];\n      if (d >= maxMoves)\n        break;\n      for (var node : graph[u]) {\n        final int v = node.getKey();\n        final int w = node.getValue();\n        final int newDist = d + w + 1;\n        if (newDist < dist[v]) {\n          dist[v] = newDist;\n          minHeap.offer(new int[] {newDist, v});\n        }\n      }\n    }\n\n    final int reachableNodes = (int) Arrays.stream(dist).filter(d -> d <= maxMoves).count();\n    int reachableSubnodes = 0;\n\n    for (int[] e : edges) {\n      final int u = e[0];\n      final int v = e[1];\n      final int cnt = e[2];\n      final int a = dist[u] > maxMoves ? 0 : Math.min(maxMoves - dist[u], cnt);\n      final int b = dist[v] > maxMoves ? 0 : Math.min(maxMoves - dist[v], cnt);\n      reachableSubnodes += Math.min(a + b, cnt);\n    }\n\n    return reachableNodes + reachableSubnodes;\n  }\n}"
    }
  },
  "883": {
    "solution": {
      "matrix": ""
    }
  },
  "884": {
    "solution": {
      "hash-table": ""
    }
  },
  "885": {
    "solution": {
      "matrix": "import java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] spiralMatrixIII(int R, int C, int rStart, int cStart) {\n        // Result array to store the visited cells in spiral order\n        int[][] result = new int[R * C][2];\n        int index = 0; \n        result[index++] = new int[]{rStart, cStart};\n\n        // Variables to track the current position and the number of steps to take in each direction\n        int steps = 1;\n        int r = rStart, c = cStart;\n        \n        // Continue until we have visited all the cells\n        while (index < R * C) {\n            // Loop over directions (right -> down -> left -> up)\n            for (int[] direction : DIRECTIONS) {\n                for (int i = 0; i < steps; i++) {\n                    // Move in the current direction\n                    r += direction[0];\n                    c += direction[1];\n                    \n                    // If the new cell is within bounds, add it to the result\n                    if (r >= 0 && r < R && c >= 0 && c < C) {\n                        result[index++] = new int[]{r, c};\n                    }\n                }\n                // After moving right or left, increase the number of steps\n                if (direction[0] != 0) {\n                    steps++;\n                }\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution spiralMatrix = new Solution();\n        int R = 5, C = 6, rStart = 1, cStart = 4;\n        int[][] result = spiralMatrix.spiralMatrixIII(R, C, rStart, cStart);\n        \n        for (int[] cell : result) {\n            System.out.println(\"[\" + cell[0] + \", \" + cell[1] + \"]\");\n        }\n    }\n}\n"
    }
  },
  "886": {
    "solution": {
      "union-find": ""
    }
  },
  "887": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int superEggDrop(int k, int n) {\n        int[][] dp = new int[k + 1][n + 1];\n\n        for (int i = 0; i <= k; i++) {\n            dp[i][0] = 0;\n            if (n >= 1) dp[i][1] = 1;\n        }\n\n        for (int j = 0; j <= n; j++) {\n            dp[1][j] = j;\n        }\n\n        for (int i = 2; i <= k; i++) {\n            for (int j = 2; j <= n; j++) {\n                int low = 1, high = j, ans = j;\n                while (low <= high) {\n                    int mid = low + (high - low) / 2;\n                    int breakEgg = dp[i - 1][mid - 1];\n                    int noBreakEgg = dp[i][j - mid];\n                    int worst = Math.max(breakEgg, noBreakEgg) + 1;\n                    ans = Math.min(ans, worst);\n\n                    if (breakEgg > noBreakEgg) {\n                        high = mid - 1;\n                    } else {\n                        low = mid + 1;\n                    }\n                }\n                dp[i][j] = ans;\n            }\n        }\n\n        return dp[k][n];\n    }\n}"
    }
  },
  "888": {
    "solution": {
      "sorting": ""
    }
  },
  "889": {
    "solution": {
      "tree": ""
    }
  },
  "890": {
    "solution": {
      "hash-table": ""
    }
  },
  "891": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int sumSubseqWidths(int[] nums) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        long mod = 1_000_000_007;\n        long[] power = new long[n];\n        power[0] = 1;\n\n        for (int i = 1; i < n; i++) {\n            power[i] = (power[i - 1] * 2) % mod;\n        }\n\n        long result = 0;\n        for (int i = 0; i < n; i++) {\n            result = (result + (power[i] - power[n - i - 1] + mod) % mod * nums[i]) % mod;\n        }\n\n        return (int) result;\n    }\n}"
    }
  },
  "892": {
    "solution": {
      "geometry": "class Solution {\n    public int surfaceArea(int[][] grid) {\n        int n = grid.length;\n        int totalSurfaceArea = 0;\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] > 0) {\n                    totalSurfaceArea += 2 + grid[i][j] * 4;\n\n                    if (i > 0) {\n                        totalSurfaceArea -= 2 * Math.min(grid[i][j], grid[i - 1][j]);\n                    }\n\n                    if (j > 0) {\n                        totalSurfaceArea -= 2 * Math.min(grid[i][j], grid[i][j - 1]);\n                    }\n                }\n            }\n        }\n\n        return totalSurfaceArea;\n    }\n}"
    }
  },
  "893": {
    "solution": {
      "sorting": ""
    }
  },
  "894": {
    "solution": {
      "memoization": "// n = 7\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\n\nclass Solution {\n  public List<TreeNode> allPossibleFBT(int n) {\n    if (n % 2 == 0)\n      return new ArrayList<>();\n    if (n == 1)\n      return Arrays.asList(new TreeNode(0));\n    if (memo.containsKey(n))\n      return memo.get(n);\n\n    List<TreeNode> ans = new ArrayList<>();\n\n    for (int leftCount = 0; leftCount < n; ++leftCount) {\n      final int rightCount = n - 1 - leftCount;\n      for (TreeNode left : allPossibleFBT(leftCount))\n        for (TreeNode right : allPossibleFBT(rightCount)) {\n          ans.add(new TreeNode(0));\n          ans.get(ans.size() - 1).left = left;\n          ans.get(ans.size() - 1).right = right;\n        }\n    }\n\n    memo.put(n, ans);\n    return ans;\n  }\n  private Map<Integer, List<TreeNode>> memo = new HashMap<>();\n}"
    }
  },
  "895": {
    "solution": {
      "stack": "class FreqStack {\n  public void push(int val) {\n    count.merge(val, 1, Integer::sum);\n    countToStack.putIfAbsent(count.get(val), new ArrayDeque<>());\n    countToStack.get(count.get(val)).push(val);\n    maxFreq = Math.max(maxFreq, count.get(val));\n  }\n\n  public int pop() {\n    final int val = countToStack.get(maxFreq).pop();\n    count.merge(val, -1, Integer::sum);\n    if (countToStack.get(maxFreq).isEmpty())\n      --maxFreq;\n    return val;\n  }\n\n  private int maxFreq = 0;\n  private Map<Integer, Integer> count = new HashMap<>();\n  private Map<Integer, Deque<Integer>> countToStack = new HashMap<>();\n}\n\n/**\n * Your FreqStack object will be instantiated and called as such:\n * FreqStack obj = new FreqStack();\n * obj.push(val);\n * int param_2 = obj.pop();\n */"
    }
  },
  "896": {
    "solution": {
      "array": ""
    }
  },
  "897": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private TreeNode result;\n\n    public TreeNode increasingBST(TreeNode root) {\n        TreeNode dummy = new TreeNode();\n        result = dummy;\n        inorder(root);\n        return dummy.right;\n    }\n    \n    private void inorder(TreeNode node) {\n        if (node == null) {\n            return;\n        }\n        \n        inorder(node.left);\n        \n        result.right = new TreeNode(node.val);\n        result = result.right;\n        \n        inorder(node.right);\n    }\n}\n"
    }
  },
  "898": {
    "solution": {
      "bit-manipulation": "class Solution {\n    public int subarrayBitwiseORs(int[] arr) {\n        Set<Integer> result = new HashSet<>();\n        Set<Integer> current = new HashSet<>();\n\n        for (int num : arr) {\n            Set<Integer> newCurrent = new HashSet<>();\n            newCurrent.add(num);\n            for (int prev : current) {\n                newCurrent.add(prev | num);\n            }\n            result.addAll(newCurrent);\n            current = newCurrent;\n        }\n\n        return result.size();\n    }\n}"
    }
  },
  "899": {
    "solution": {
      "sorting": "import java.util.Arrays;\n\nclass Solution {\n    public String orderlyQueue(String s, int k) {\n        if (k > 1) {\n            char[] chars = s.toCharArray();\n            Arrays.sort(chars);\n            return new String(chars);\n        }\n\n        String ans = s;\n        for (int i = 1; i < s.length(); i++) {\n            String rotated = s.substring(i) + s.substring(0, i);\n            if (rotated.compareTo(ans) < 0) {\n                ans = rotated;\n            }\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "900": {
    "solution": {
      "iterator": "class RLEIterator {\n    private int[] encoding;\n    private int index;\n\n    public RLEIterator(int[] encoding) {\n        this.encoding = encoding;\n        this.index = 0;\n    }\n\n    public int next(int n) {\n        while (index < encoding.length) {\n            if (n <= encoding[index]) {\n                encoding[index] -= n;\n                return encoding[index + 1];\n            } else {\n                n -= encoding[index];\n                index += 2;\n            }\n        }\n        return -1; \n    }\n}\n\n/**\n * Your RLEIterator object will be instantiated and called as such:\n * RLEIterator obj = new RLEIterator(encoding);\n * int param_1 = obj.next(n);\n */"
    }
  },
  "901": {
    "solution": {
      "monotonic-stack": "import java.util.Stack;\n\nclass StockSpanner {\n    Stack<int[]> stack;\n\n    public StockSpanner() {\n        stack = new Stack<>();\n    }\n\n    public int next(int price) {\n        int span = 1;\n        while (!stack.isEmpty() && stack.peek()[0] <= price) {\n            span += stack.pop()[1];\n        }\n        stack.push(new int[]{price, span});\n        return span;\n    }\n}\n\n/**\n * Your StockSpanner object will be instantiated and called as such:\n * StockSpanner obj = new StockSpanner();\n * int param_1 = obj.next(price);\n */\n"
    }
  },
  "902": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "903": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "904": {
    "solution": {
      "sliding-window": "class Solution {\n    public int totalFruit(int[] tree) {\n        int maxFruits = 0;\n        int start = 0;\n        Map<Integer, Integer> fruitCount = new HashMap<>();\n        \n        for (int end = 0; end < tree.length; end++) {\n            fruitCount.put(tree[end], fruitCount.getOrDefault(tree[end], 0) + 1);\n            \n            while (fruitCount.size() > 2) {\n                fruitCount.put(tree[start], fruitCount.get(tree[start]) - 1);\n                if (fruitCount.get(tree[start]) == 0) {\n                    fruitCount.remove(tree[start]);\n                }\n                start++;\n            }\n            \n            maxFruits = Math.max(maxFruits, end - start + 1);\n        }\n        \n        return maxFruits;\n    }\n}\n"
    }
  },
  "905": {
    "solution": {
      "two-pointers": ""
    }
  },
  "906": {
    "solution": {
      "enumeration": ""
    }
  },
  "907": {
    "solution": {
      "monotonic-stack": "import java.util.Stack;\n\npublic class Solution {\n    public int sumSubarrayMins(int[] arr) {\n        int MOD = 1_000_000_007;\n        int n = arr.length;\n        \n        Stack<Integer> stack = new Stack<>();        \n        int[] prevLess = new int[n];\n        int[] nextLess = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && arr[stack.peek()] >= arr[i]) {\n                stack.pop();\n            }\n            prevLess[i] = stack.isEmpty() ? -1 : stack.peek();\n            stack.push(i);\n        }\n        \n        stack.clear();\n        \n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && arr[stack.peek()] > arr[i]) {\n                stack.pop();\n            }\n            nextLess[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        \n        long result = 0;\n        \n        for (int i = 0; i < n; i++) {\n            int leftCount = i - prevLess[i];\n            int rightCount = nextLess[i] - i;\n            result = (result + (long) arr[i] * leftCount * rightCount) % MOD;\n        }\n        \n        return (int) result;\n    }\n}\n"
    }
  },
  "908": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public int smallestRangeI(int[] nums, int k) {\n        int min = Integer.MAX_VALUE;\n        int max = Integer.MIN_VALUE;\n\n        for (int num : nums) {\n            min = Math.min(min, num);\n            max = Math.max(max, num);\n        }\n\n        int range = max - min - 2 * k;\n        return Math.max(0, range);\n    }\n}"
    }
  },
  "909": {
    "solution": {
      "matrix": "import java.util.ArrayDeque;\nimport java.util.Queue;\n\npublic class Solution {\n    public int snakesAndLadders(int[][] board) {\n        int n = board.length;\n        int[] flattenedBoard = new int[n * n];\n        \n        int index = 0;\n        boolean leftToRight = true;\n        for (int i = n - 1; i >= 0; i--) {\n            if (leftToRight) {\n                for (int j = 0; j < n; j++) {\n                    flattenedBoard[index++] = board[i][j];\n                }\n            } else {\n                for (int j = n - 1; j >= 0; j--) {\n                    flattenedBoard[index++] = board[i][j];\n                }\n            }\n            leftToRight = !leftToRight;\n        }\n\n        Queue<Integer> queue = new ArrayDeque<>();\n        boolean[] visited = new boolean[n * n];\n        queue.offer(0);\n        visited[0] = true;\n        int moves = 0;\n\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int current = queue.poll();\n                \n                if (current == n * n - 1) { \n                    return moves;\n                }\n\n                for (int dice = 1; dice <= 6; dice++) {\n                    int next = current + dice;\n                    if (next >= n * n) break; \n                    int destination = flattenedBoard[next] == -1 ? next : flattenedBoard[next] - 1;\n                    if (!visited[destination]) {\n                        visited[destination] = true;\n                        queue.offer(destination);\n                    }\n                }\n            }\n            moves++; \n        }\n\n        return -1; \n    }\n}\n"
    }
  },
  "910": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int smallestRangeII(int[] nums, int k) {\n        Arrays.sort(nums);\n        int n = nums.length;\n        int ans = nums[n - 1] - nums[0];\n\n        for (int i = 0; i < n - 1; i++) {\n            int high = Math.max(nums[n - 1] - k, nums[i] + k);\n            int low = Math.min(nums[0] + k, nums[i + 1] - k);\n            ans = Math.min(ans, high - low);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "911": {
    "solution": {
      "design": ""
    }
  },
  "912": {
    "solution": {
      "radix-sort": "import java.util.Arrays;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length < 2) {\n            return nums;\n        }\n\n        // Find the maximum absolute value to handle negative numbers\n        int max = Arrays.stream(nums).map(Math::abs).max().getAsInt();\n        int exp = 1;\n\n        while (max / exp > 0) {\n            countingSort(nums, exp);\n            exp *= 10;\n        }\n\n        return nums;\n    }\n\n    private void countingSort(int[] nums, int exp) {\n        int n = nums.length;\n        int[] output = new int[n];\n        int[] count = new int[19]; // 19 because the range of values is [-9, 9]\n\n        for (int num : nums) {\n            int index = (num / exp) % 10 + 9; // Shifting by 9 to handle negative numbers\n            count[index]++;\n        }\n\n        for (int i = 1; i < 19; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            int index = (nums[i] / exp) % 10 + 9;\n            output[count[index] - 1] = nums[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, nums, 0, n);\n    }\n}\n",
      "bucket-sort": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\n\nclass Solution {\n    public int[] sortArray(int[] nums) {\n        if (nums == null || nums.length == 0) return nums;\n\n        int n = nums.length;\n        int minValue = nums[0];\n        int maxValue = nums[0];\n\n        for (int num : nums) {\n            if (num < minValue) {\n                minValue = num;\n            } else if (num > maxValue) {\n                maxValue = num;\n            }\n        }\n\n        int bucketCount = (maxValue - minValue) / n + 1;\n        List<Integer>[] buckets = new List[bucketCount];\n        for (int i = 0; i < bucketCount; i++) {\n            buckets[i] = new ArrayList<>();\n        }\n\n        for (int num : nums) {\n            int bucketIndex = (num - minValue) / n;\n            buckets[bucketIndex].add(num);\n        }\n\n        int index = 0;\n        for (List<Integer> bucket : buckets) {\n            Collections.sort(bucket);\n            for (int num : bucket) {\n                nums[index++] = num;\n            }\n        }\n\n        return nums;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {5, 2, 9, 1, 5, 6};\n        int[] sorted = solution.sortArray(nums);\n        for (int num : sorted) {\n            System.out.print(num + \" \");\n        }\n        // Output: 1 2 5 5 6 9\n    }\n}\n",
      "merge-sort": "class Solution {\n    public int[] sortArray(int[] nums) {\n        mergeSort(nums, 0, nums.length - 1);\n        return nums;\n    }\n    \n    private void mergeSort(int[] nums, int left, int right) {\n        if (left < right) {\n            int mid = left + (right - left) / 2;\n            mergeSort(nums, left, mid);\n            mergeSort(nums, mid + 1, right);\n            merge(nums, left, mid, right);\n        }\n    }\n    \n    private void merge(int[] nums, int left, int mid, int right) {\n        int n1 = mid - left + 1;\n        int n2 = right - mid;\n        \n        int[] leftArr = new int[n1];\n        int[] rightArr = new int[n2];\n        \n        for (int i = 0; i < n1; i++) {\n            leftArr[i] = nums[left + i];\n        }\n        \n        for (int j = 0; j < n2; j++) {\n            rightArr[j] = nums[mid + 1 + j];\n        }\n        \n        int i = 0, j = 0, k = left;\n        \n        while (i < n1 && j < n2) {\n            if (leftArr[i] <= rightArr[j]) {\n                nums[k++] = leftArr[i++];\n            } else {\n                nums[k++] = rightArr[j++];\n            }\n        }\n        \n        while (i < n1) {\n            nums[k++] = leftArr[i++];\n        }\n        \n        while (j < n2) {\n            nums[k++] = rightArr[j++];\n        }\n    }\n}\n"
    }
  },
  "913": {
    "solution": {
      "topological-sort": "// Input: graph = [[1,3],[0],[3],[0,2]]\n\nclass Solution {\n\n    public static final int HOLE = 0, MOUSE_START = 1, CAT_START = 2;\n    public static final int MOUSE_TURN = 0, CAT_TURN = 1;\n    public static final int MOUSE_WIN = 1, CAT_WIN = 2, UNKNOWN = 0;\n\n    public int catMouseGame(int[][] graph) {\n\n        int n = graph.length;\n        int[][][] degrees = new int[n][n][2];\n        int[][][] results = new int[n][n][2];\n        Queue<int[]> queue = new ArrayDeque<>();\n\n        for (int i = 0; i < n; i++) {\n            for (int j = 1; j < n; j++) {\n                degrees[i][j][MOUSE_TURN] = graph[i].length;\n                degrees[i][j][CAT_TURN] = graph[j].length;\n            }\n        }\n\n        for (int i = 0; i < n; i++) {\n            for (int j : graph[HOLE]) {\n                degrees[i][j][CAT_TURN]--;\n            }\n        }\n\n        for (int i = 1; i < n; i++) {\n            results[i][i][MOUSE_TURN] = CAT_WIN;\n            results[i][i][CAT_TURN] = CAT_WIN;\n            queue.offer(new int[] { i, i, MOUSE_TURN });\n            queue.offer(new int[] { i, i, CAT_TURN });\n        }\n\n        for (int j = 1; j < n; j++) {\n            results[0][j][MOUSE_TURN] = MOUSE_WIN;\n            results[0][j][CAT_TURN] = MOUSE_WIN;\n            queue.offer(new int[] { 0, j, MOUSE_TURN });\n            queue.offer(new int[] { 0, j, CAT_TURN });\n        }\n\n        while (!queue.isEmpty()) {\n            int[] state = queue.poll();\n            int Mouse = state[0], Cat = state[1], turn = state[2];\n            int result = results[Mouse][Cat][turn];\n            List<int[]> prevStates = getPrevStates(Mouse, Cat, turn, graph);\n\n            for (int[] prevState : prevStates) {\n                int prevMouse = prevState[0], prevCat = prevState[1], prevTurn = prevState[2];\n\n                if (results[prevMouse][prevCat][prevTurn] == UNKNOWN) {\n                    boolean winState = (result == MOUSE_WIN && prevTurn == MOUSE_TURN)\n                            || (result == CAT_WIN && prevTurn == CAT_TURN);\n\n                    if (winState) {\n                        results[prevMouse][prevCat][prevTurn] = result;\n                        queue.offer(new int[] { prevMouse, prevCat, prevTurn });\n                    } else {\n                        degrees[prevMouse][prevCat][prevTurn]--;\n\n                        if (degrees[prevMouse][prevCat][prevTurn] == 0) {\n                            results[prevMouse][prevCat][prevTurn] = result;\n                            queue.offer(new int[] { prevMouse, prevCat, prevTurn });\n                        }\n                    }\n                }\n            }\n        }\n\n        return results[MOUSE_START][CAT_START][MOUSE_TURN];\n    }\n\n    private List<int[]> getPrevStates(int Mouse, int Cat, int turn, int[][] graph) {\n        List<int[]> prevStates = new ArrayList<>();\n        int prevTurn = turn == MOUSE_TURN ? CAT_TURN : MOUSE_TURN;\n\n        if (prevTurn == CAT_TURN) {\n            for (int prevCat : graph[Cat]) {\n                if (prevCat != HOLE) {\n                    prevStates.add(new int[] { Mouse, prevCat, prevTurn });\n                }\n            }\n        } else {\n            for (int prevMouse : graph[Mouse]) {\n                prevStates.add(new int[] { prevMouse, Cat, prevTurn });\n            }\n        }\n\n        return prevStates;\n    }\n\n}"
    }
  },
  "914": {
    "solution": {
      "number-theory": ""
    }
  },
  "915": {
    "solution": {
      "array": "class Solution {\n    public int partitionDisjoint(int[] nums) {\n        int n = nums.length;\n        int maxLeft = nums[0];\n        int maxGlobal = nums[0];\n        int partitionIndex = 0;\n\n        for (int i = 1; i < n; i++) {\n            maxGlobal = Math.max(maxGlobal, nums[i]);\n            if (nums[i] < maxLeft) {\n                partitionIndex = i;\n                maxLeft = maxGlobal;\n            }\n        }\n\n        return partitionIndex + 1;\n    }\n}"
    }
  },
  "916": {
    "solution": {
      "hash-table": ""
    }
  },
  "917": {
    "solution": {
      "two-pointers": ""
    }
  },
  "918": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int maxSubarraySumCircular(int[] nums) {\n        int n = nums.length;\n        int[] extendedNums = new int[2 * n];        \n        System.arraycopy(nums, 0, extendedNums, 0, n);\n        System.arraycopy(nums, 0, extendedNums, n, n);        \n        long[] prefixSum = new long[2 * n + 1];\n        for (int i = 0; i < 2 * n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + extendedNums[i];\n        }\n        \n        Deque<Integer> deque = new LinkedList<>();\n        deque.add(0);\n        int maxSum = Integer.MIN_VALUE;\n        \n        for (int i = 1; i <= 2 * n; i++) {\n            if (deque.peekFirst() < i - n) {\n                deque.pollFirst();\n            }            \n            maxSum = Math.max(maxSum, (int)(prefixSum[i] - prefixSum[deque.peekFirst()]));\n            \n            // Maintain the deque's monotonic property\n            while (!deque.isEmpty() && prefixSum[i] <= prefixSum[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.addLast(i);\n        }\n        \n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, -2, 3, -2};\n        System.out.println(solution.maxSubarraySumCircular(nums));  // Output: 3\n    }\n}\n"
    }
  },
  "919": {
    "solution": {
      "tree": ""
    }
  },
  "920": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "921": {
    "solution": {
      "greedy": "class Solution {\n public:\n  int minAddToMakeValid(string s) {\n    int l = 0;\n    int r = 0;\n\n    for (const char c : s)\n      if (c == '(') {\n        ++l;\n      } else {\n        if (l == 0)\n          ++r;\n        else\n          --l;\n      }\n\n    return l + r;\n  }\n};"
    }
  },
  "922": {
    "solution": {
      "sorting": "class Solution {\n    public int[] sortArrayByParityII(int[] nums) {\n        int n = nums.length;\n        int evenIdx = 0, oddIdx = 1;\n\n        while (evenIdx < n && oddIdx < n) {\n            while (evenIdx < n && nums[evenIdx] % 2 == 0) {\n                evenIdx += 2;\n            }\n            while (oddIdx < n && nums[oddIdx] % 2 == 1) {\n                oddIdx += 2;\n            }\n            if (evenIdx < n && oddIdx < n) {\n                int temp = nums[evenIdx];\n                nums[evenIdx] = nums[oddIdx];\n                nums[oddIdx] = temp;\n            }\n        }\n\n        return nums;\n    }\n}"
    }
  },
  "923": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int threeSumMulti(int[] arr, int target) {\n        int MOD = 1_000_000_007;\n        Arrays.sort(arr);\n        int n = arr.length;\n        long result = 0;\n\n        for (int left = 0; left < n; left++) {\n            int T = target - arr[left];\n            int right = left + 1, k = n - 1;\n            while (right < k) {\n                if (arr[right] + arr[k] < T) {\n                    right++;\n                } else if (arr[right] + arr[k] > T) {\n                    k--;\n                } else if (arr[right] != arr[k]) {\n                    int leftCount = 1, rightCount = 1;\n                    while (right + 1 < k && arr[right] == arr[right + 1]) {\n                        leftCount++;\n                        right++;\n                    }\n                    while (k - 1 > right && arr[k] == arr[k - 1]) {\n                        rightCount++;\n                        k--;\n                    }\n                    result += leftCount * rightCount;\n                    result %= MOD;\n                    right++;\n                    k--;\n                } else {\n                    result += (k - right + 1) * (k - right) / 2;\n                    result %= MOD;\n                    break;\n                }\n            }\n        }\n\n        return (int) result;\n    }\n}\n"
    }
  },
  "924": {
    "solution": {
      "union-find": "// Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]\nclass UF {\n    public UF(int n) {\n        id = new int[n];\n        for (int i = 0; i < n; ++i)\n            id[i] = i;\n    }\n\n    public void union(int u, int v) {\n        id[find(u)] = find(v);\n    }\n\n    public int find(int u) {\n        return id[u] == u ? u : (id[u] = find(id[u]));\n    }\n\n    private int[] id;\n}\n\nclass Solution {\n    public int minMalwareSpread(int[][] graph, int[] initial) {\n        final int n = graph.length;\n        UF uf = new UF(n);\n        int[] ufSize = new int[n];\n        int[] malwareCount = new int[n];\n        for (int i = 0; i < n; ++i)\n            for (int j = i + 1; j < n; ++j)\n                if (graph[i][j] == 1)\n                    uf.union(i, j);\n        for (int i = 0; i < n; ++i)\n            ++ufSize[uf.find(i)];\n        for (final int i : initial)\n            ++malwareCount[uf.find(i)];\n        Arrays.sort(initial);\n        int ans = initial[0];\n        int maxUfSize = 0;\n        for (final int i : initial) {\n            final int id = uf.find(i);\n            if (ufSize[id] > maxUfSize && malwareCount[id] == 1) {\n                maxUfSize = ufSize[id];\n                ans = i;\n            }\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "925": {
    "solution": {
      "two-pointers": ""
    }
  },
  "926": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "927": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public int[] threeEqualParts(int[] arr) {\n        int totalOnes = 0;\n        for (int num : arr) {\n            if (num == 1) totalOnes++;\n        }\n\n        if (totalOnes % 3 != 0) return new int[]{-1, -1};\n        if (totalOnes == 0) return new int[]{0, arr.length - 1};\n\n        List<Integer> onesIndices = new ArrayList<>();\n        for (int i = 0; i < arr.length; i++) {\n            if (arr[i] == 1) onesIndices.add(i);\n        }\n\n        int part = totalOnes / 3;\n        int i1 = onesIndices.get(0);\n        int i2 = onesIndices.get(part);\n        int i3 = onesIndices.get(2 * part);\n\n        while (i3 < arr.length &&\n               arr[i1] == arr[i2] && arr[i2] == arr[i3]) {\n            i1++;\n            i2++;\n            i3++;\n        }\n\n        if (i3 == arr.length) return new int[]{i1 - 1, i2};\n        return new int[]{-1, -1};\n    }\n}"
    }
  },
  "928": {
    "solution": {
      "union-find": ""
    }
  },
  "929": {
    "solution": {
      "hash-table": ""
    }
  },
  "930": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numSubarraysWithSum(int[] nums, int goal) {\n        Map<Integer, Integer> prefixSumCount = new HashMap<>();\n        prefixSumCount.put(0, 1);\n        int prefixSum = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int currentSum = prefixSum - goal;\n            if (prefixSumCount.containsKey(currentSum)) {\n                count += prefixSumCount.get(currentSum);\n            }\n            prefixSumCount.put(prefixSum, prefixSumCount.getOrDefault(prefixSum, 0) + 1);\n        }\n\n        return count;\n    }\n}\n"
    }
  },
  "931": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int minFallingPathSum(int[][] matrix) {\n        int n = matrix.length;\n\n        for (int i = 1; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                int minAbove = matrix[i - 1][j];\n                if (j > 0) minAbove = Math.min(minAbove, matrix[i - 1][j - 1]);\n                if (j < n - 1) minAbove = Math.min(minAbove, matrix[i - 1][j + 1]);\n                matrix[i][j] += minAbove;\n            }\n        }\n\n        int minPath = Integer.MAX_VALUE;\n        for (int value : matrix[n - 1]) {\n            minPath = Math.min(minPath, value);\n        }\n        return minPath;\n    }\n}"
    }
  },
  "932": {
    "solution": {
      "divide-and-conquer": ""
    }
  },
  "933": {
    "solution": {
      "queue": ""
    }
  },
  "934": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    private final int[][] directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int shortestBridge(int[][] grid) {\n        int n = grid.length;\n        Queue<int[]> queue = new LinkedList<>();\n        boolean found = false;\n\n        // Step 1: Find and mark the first island with DFS\n        for (int i = 0; i < n; i++) {\n            if (found) break;\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 1) {\n                    dfsMarkIsland(grid, i, j, queue);\n                    found = true;\n                    break;\n                }\n            }\n        }\n\n        // Step 2: BFS from all boundary cells of the first island\n        int steps = 0;\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            for (int i = 0; i < size; i++) {\n                int[] cell = queue.poll();\n                int x = cell[0], y = cell[1];\n\n                for (int[] dir : directions) {\n                    int nx = x + dir[0];\n                    int ny = y + dir[1];\n\n                    if (nx < 0 || ny < 0 || nx >= n || ny >= n) continue;\n\n                    if (grid[nx][ny] == 1) return steps;\n\n                    if (grid[nx][ny] == 0) {\n                        grid[nx][ny] = 2;\n                        queue.offer(new int[]{nx, ny});\n                    }\n                }\n            }\n            steps++;\n        }\n\n        return -1;\n    }\n\n    private void dfsMarkIsland(int[][] grid, int x, int y, Queue<int[]> queue) {\n        int n = grid.length;\n        if (x < 0 || y < 0 || x >= n || y >= n || grid[x][y] != 1) return;\n\n        grid[x][y] = 2;\n        queue.offer(new int[]{x, y});\n\n        for (int[] dir : directions) {\n            dfsMarkIsland(grid, x + dir[0], y + dir[1], queue);\n        }\n    }\n}"
    }
  },
  "935": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "936": {
    "solution": {
      "queue": ""
    }
  },
  "937": {
    "solution": {
      "sorting": ""
    }
  },
  "938": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "939": {
    "solution": {
      "geometry": ""
    }
  },
  "940": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "941": {
    "solution": {
      "array": ""
    }
  },
  "942": {
    "solution": {
      "two-pointers": ""
    }
  },
  "943": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "944": {
    "solution": {
      "string": ""
    }
  },
  "945": {
    "solution": {
      "counting": ""
    }
  },
  "946": {
    "solution": {
      "stack": ""
    }
  },
  "947": {
    "solution": {
      "union-find": ""
    }
  },
  "948": {
    "solution": {
      "two-pointers": ""
    }
  },
  "949": {
    "solution": {
      "enumeration": ""
    }
  },
  "950": {
    "solution": {
      "queue": ""
    }
  },
  "951": {
    "solution": {
      "binary-tree": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public boolean flipEquiv(TreeNode root1, TreeNode root2) {\n        if (root1 == null && root2 == null) return true;\n        if (root1 == null || root2 == null || root1.val != root2.val) return false;\n\n        boolean noFlip = flipEquiv(root1.left, root2.left) && flipEquiv(root1.right, root2.right);\n        boolean flip = flipEquiv(root1.left, root2.right) && flipEquiv(root1.right, root2.left);\n\n        return noFlip || flip;\n    }\n}"
    }
  },
  "952": {
    "solution": {
      "union-find": ""
    }
  },
  "953": {
    "solution": {
      "hash-table": ""
    }
  },
  "954": {
    "solution": {
      "greedy": ""
    }
  },
  "955": {
    "solution": {
      "greedy": ""
    }
  },
  "956": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "957": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "958": {
    "solution": {
      "tree": ""
    }
  },
  "959": {
    "solution": {
      "union-find": ""
    }
  },
  "960": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "961": {
    "solution": {
      "hash-table": ""
    }
  },
  "962": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "963": {
    "solution": {
      "geometry": "import java.util.*;\n\nclass Solution {\n    public double minAreaFreeRect(int[][] points) {\n        long ans = Long.MAX_VALUE;\n        Map<String, List<int[]>> centerToPoints = new HashMap<>();\n\n        for (int[] A : points) {\n            for (int[] B : points) {\n                int[] key = new int[]{A[0] + B[0], A[1] + B[1]};\n                String centerKey = Arrays.toString(key);\n                centerToPoints.computeIfAbsent(centerKey, k -> new ArrayList<>()).add(new int[]{A[0], A[1], B[0], B[1]});\n            }\n        }\n\n        for (List<int[]> ps : centerToPoints.values()) {\n            for (int[] p1 : ps) {\n                for (int[] p2 : ps) {\n                    int ax = p1[0], ay = p1[1], bx = p1[2], by = p1[3];\n                    int cx = p2[0], cy = p2[1], dx = p2[2], dy = p2[3];\n\n                    if ((cx - ax) * (dx - ax) + (cy - ay) * (dy - ay) == 0) {\n                        long area = dist(ax, ay, cx, cy) * dist(ax, ay, dx, dy);\n                        if (area > 0) ans = Math.min(ans, area);\n                    }\n                }\n            }\n        }\n\n        return ans == Long.MAX_VALUE ? 0 : Math.sqrt(ans);\n    }\n\n    private long dist(int px, int py, int qx, int qy) {\n        return (long)(px - qx) * (px - qx) + (long)(py - qy) * (py - qy);\n    }\n}"
    }
  },
  "964": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "965": {
    "solution": {
      "tree": ""
    }
  },
  "966": {
    "solution": {
      "hash-table": ""
    }
  },
  "967": {
    "solution": {
      "backtracking": ""
    }
  },
  "968": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "969": {
    "solution": {
      "two-pointers": ""
    }
  },
  "970": {
    "solution": {
      "enumeration": ""
    }
  },
  "971": {
    "solution": {
      "binary-tree": "import java.util.*;\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    private int index = 0;\n    private List<Integer> result = new ArrayList<>();\n\n    public List<Integer> flipMatchVoyage(TreeNode root, int[] voyage) {\n        if (dfs(root, voyage)) {\n            return result;\n        }\n        return Arrays.asList(-1);\n    }\n\n    private boolean dfs(TreeNode node, int[] voyage) {\n        if (node == null) return true;\n\n        if (node.val != voyage[index++]) return false;\n\n        if (node.left != null && node.left.val != voyage[index]) {\n            result.add(node.val);\n            return dfs(node.right, voyage) && dfs(node.left, voyage);\n        }\n\n        return dfs(node.left, voyage) && dfs(node.right, voyage);\n    }\n}"
    }
  },
  "972": {
    "solution": {
      "math": ""
    }
  },
  "973": {
    "solution": {
      "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        int left = 0, right = points.length - 1;\n        while (left <= right) {\n            int pivotIndex = partition(points, left, right);\n            if (pivotIndex == k - 1) {\n                break;\n            } else if (pivotIndex < k - 1) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        \n        int[][] result = new int[k][2];\n        for (int i = 0; i < k; i++) {\n            result[i] = points[i];\n        }\n        \n        return result;\n    }\n    \n    private int partition(int[][] points, int left, int right) {\n        int pivotIndex = left + (right - left) / 2;\n        int[] pivot = points[pivotIndex];\n        int pivotDist = distance(pivot);\n        swap(points, pivotIndex, right);\n        int storeIndex = left;\n        for (int i = left; i < right; i++) {\n            if (distance(points[i]) < pivotDist) {\n                swap(points, storeIndex++, i);\n            }\n        }\n        swap(points, storeIndex, right);\n        return storeIndex;\n    }\n    \n    private int distance(int[] point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n    \n    private void swap(int[][] points, int i, int j) {\n        int[] temp = points[i];\n        points[i] = points[j];\n        points[j] = temp;\n    }\n}\n",
      "heap-(priority-queue)": "import java.util.*;\n\npublic class Solution {\n    public int[][] kClosest(int[][] points, int k) {\n        // Step 1: Calculate distances and store in a max heap (priority queue)\n        PriorityQueue<int[]> maxHeap = new PriorityQueue<>((a, b) -> distance(b) - distance(a));\n        \n        for (int[] point : points) {\n            maxHeap.offer(point);\n            if (maxHeap.size() > k) {\n                maxHeap.poll(); // Maintain heap size k by removing the farthest point\n            }\n        }\n        \n        // Step 2: Convert max heap to result array\n        int[][] result = new int[k][2];\n        int index = 0;\n        while (!maxHeap.isEmpty()) {\n            result[index++] = maxHeap.poll();\n        }\n        \n        return result;\n    }\n    \n    // Helper method to calculate distance from origin (0, 0)\n    private int distance(int[] point) {\n        return point[0] * point[0] + point[1] * point[1];\n    }\n}\n"
    }
  },
  "974": {
    "solution": {
      "prefix-sum": "import java.util.HashMap;\n\npublic class Solution {\n    public int subarraysDivByK(int[] nums, int k) {\n        HashMap<Integer, Integer> countMap = new HashMap<>();        \n        countMap.put(0, 1);\n\n        int prefixSum = 0;\n        int count = 0;\n\n        for (int num : nums) {\n            prefixSum += num;\n            int remainder = (prefixSum % k + k) % k;\n            count += countMap.getOrDefault(remainder, 0);\n            countMap.put(remainder, countMap.getOrDefault(remainder, 0) + 1);\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {23, 2, 4, 6, 7};\n        int k = 6;\n        System.out.println(solution.subarraysDivByK(nums, k)); // Output: 4\n    }\n}\n"
    }
  },
  "975": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int oddEvenJumps(int[] arr) {\n        int n = arr.length;\n        boolean[] odd = new boolean[n];\n        boolean[] even = new boolean[n];\n        odd[n - 1] = even[n - 1] = true;\n\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(arr[n - 1], n - 1);\n\n        for (int i = n - 2; i >= 0; i--) {\n            Map.Entry<Integer, Integer> ceil = map.ceilingEntry(arr[i]);\n            Map.Entry<Integer, Integer> floor = map.floorEntry(arr[i]);\n\n            if (ceil != null) odd[i] = even[ceil.getValue()];\n            if (floor != null) even[i] = odd[floor.getValue()];\n\n            map.put(arr[i], i);\n        }\n\n        int count = 0;\n        for (boolean canReach : odd) {\n            if (canReach) count++;\n        }\n        return count;\n    }\n}"
    }
  },
  "976": {
    "solution": {
      "greedy": ""
    }
  },
  "977": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\n\npublic class Solution {\n    public int[] sortedSquares(int[] nums) {\n        int n = nums.length;\n        int[] result = new int[n];\n        int left = 0, right = n - 1;\n\n        for (int i = n - 1; i >= 0; i--) {\n            if (Math.abs(nums[left]) > Math.abs(nums[right])) {\n                result[i] = nums[left] * nums[left];\n                left++;\n            } else {\n                result[i] = nums[right] * nums[right];\n                right--;\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "978": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxTurbulenceSize(int[] arr) {\n        int ans = 1;\n        int increasing = 1;\n        int decreasing = 1;\n\n        for (int i = 1; i < arr.length; ++i) {\n            if (arr[i] > arr[i - 1]) {\n                increasing = decreasing + 1;\n                decreasing = 1;\n            } else if (arr[i] < arr[i - 1]) {\n                decreasing = increasing + 1;\n                increasing = 1;\n            } else {\n                increasing = 1;\n                decreasing = 1;\n            }\n            ans = Math.max(ans, Math.max(increasing, decreasing));\n        }\n\n        return ans;\n    }\n}\n"
    }
  },
  "979": {
    "solution": {
      "tree": ""
    }
  },
  "980": {
    "solution": {
      "matrix": "public class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int emptyCells = 0;\n    private int uniquePaths = 0;\n\n    public int uniquePathsIII(int[][] grid) {\n        int startRow = 0, startCol = 0;\n        \n        for (int r = 0; r < grid.length; r++) {\n            for (int c = 0; c < grid[0].length; c++) {\n                if (grid[r][c] == 1) {  \n                    startRow = r;\n                    startCol = c;\n                }\n                if (grid[r][c] != -1) {  \n                    emptyCells++;\n                }\n            }\n        }\n        \n        dfs(grid, startRow, startCol, 1);  \n        return uniquePaths;\n    }\n\n    private void dfs(int[][] grid, int row, int col, int visitedCells) {\n        if (row < 0 || row >= grid.length || col < 0 || col >= grid[0].length || grid[row][col] == -1) {\n            return;\n        }\n        \n        if (grid[row][col] == 2) {\n            if (visitedCells == emptyCells) {\n                uniquePaths++;\n            }\n            return;\n        }\n        \n        int temp = grid[row][col];\n        grid[row][col] = -1;  \n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = row + direction[0];\n            int newCol = col + direction[1];\n            dfs(grid, newRow, newCol, visitedCells + 1);\n        }\n        \n        grid[row][col] = temp;\n    }\n}\n"
    }
  },
  "981": {
    "solution": {
      "design": "import java.util.*;\n\nclass TimeMap {\n    private static class TimeValue {\n        String value;\n        int timestamp;\n\n        TimeValue(String value, int timestamp) {\n            this.value = value;\n            this.timestamp = timestamp;\n        }\n    }\n\n    private Map<String, List<TimeValue>> map;\n\n    public TimeMap() {\n        map = new HashMap<>();\n    }\n\n    public void set(String key, String value, int timestamp) {\n        map.computeIfAbsent(key, k -> new ArrayList<>()).add(new TimeValue(value, timestamp));\n    }\n\n    public String get(String key, int timestamp) {\n        if (!map.containsKey(key)) {\n            return \"\";\n        }\n\n        List<TimeValue> list = map.get(key);\n        int left = 0, right = list.size() - 1, ans = -1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (list.get(mid).timestamp <= timestamp) {\n                ans = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return ans == -1 ? \"\" : list.get(ans).value;\n    }\n}"
    }
  },
  "982": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "983": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "984": {
    "solution": {
      "greedy": "class Solution {\n    public String strWithout3a3b(int A, int B) {\n        StringBuilder sb = new StringBuilder();\n        char a = 'a', b = 'b';\n\n        if (B > A) {\n            int temp = A;\n            A = B;\n            B = temp;\n            a = 'b';\n            b = 'a';\n        }\n\n        while (A > 0 || B > 0) {\n            if (A > 0) {\n                sb.append(a);\n                A--;\n            }\n            if (A > B) {\n                sb.append(a);\n                A--;\n            }\n            if (B > 0) {\n                sb.append(b);\n                B--;\n            }\n        }\n\n        return sb.toString();\n    }\n}"
    }
  },
  "985": {
    "solution": {
      "array": ""
    }
  },
  "986": {
    "solution": {
      "two-pointers": ""
    }
  },
  "987": {
    "solution": {
      "binary-tree": "import java.util.*;\n\nclass Solution {\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    public List<List<Integer>> verticalTraversal(TreeNode root) {\n        TreeMap<Integer, List<int[]>> columnMap = new TreeMap<>();\n        Queue<NodeInfo> queue = new LinkedList<>();\n        queue.offer(new NodeInfo(root, 0, 0));\n\n        while (!queue.isEmpty()) {\n            NodeInfo current = queue.poll();\n            columnMap.computeIfAbsent(current.col, k -> new ArrayList<>())\n                     .add(new int[]{current.row, current.node.val});\n\n            if (current.node.left != null) {\n                queue.offer(new NodeInfo(current.node.left, current.col - 1, current.row + 1));\n            }\n            if (current.node.right != null) {\n                queue.offer(new NodeInfo(current.node.right, current.col + 1, current.row + 1));\n            }\n        }\n\n        List<List<Integer>> result = new ArrayList<>();\n        for (List<int[]> entries : columnMap.values()) {\n            entries.sort((a, b) -> a[0] == b[0] ? Integer.compare(a[1], b[1]) : Integer.compare(a[0], b[0]));\n            List<Integer> colList = new ArrayList<>();\n            for (int[] pair : entries) {\n                colList.add(pair[1]);\n            }\n            result.add(colList);\n        }\n        return result;\n    }\n\n    static class NodeInfo {\n        TreeNode node;\n        int col;\n        int row;\n        NodeInfo(TreeNode node, int col, int row) {\n            this.node = node;\n            this.col = col;\n            this.row = row;\n        }\n    }\n}"
    }
  },
  "988": {
    "solution": {
      "backtracking": "class Solution {\n    static class TreeNode {\n        int val;\n        TreeNode left, right;\n        TreeNode(int val) { this.val = val; }\n        TreeNode(int val, TreeNode left, TreeNode right) {\n            this.val = val;\n            this.left = left;\n            this.right = right;\n        }\n    }\n\n    private String smallest = null;\n\n    public String smallestFromLeaf(TreeNode root) {\n        dfs(root, new StringBuilder());\n        return smallest;\n    }\n\n    private void dfs(TreeNode node, StringBuilder sb) {\n        if (node == null) return;\n\n        sb.insert(0, (char) ('a' + node.val));\n\n        if (node.left == null && node.right == null) {\n            String current = sb.toString();\n            if (smallest == null || current.compareTo(smallest) < 0) {\n                smallest = current;\n            }\n        }\n\n        dfs(node.left, sb);\n        dfs(node.right, sb);\n        sb.deleteCharAt(0); // backtrack\n    }\n}"
    }
  },
  "989": {
    "solution": {
      "math": ""
    }
  },
  "990": {
    "solution": {
      "union-find": ""
    }
  },
  "991": {
    "solution": {
      "greedy": ""
    }
  },
  "992": {
    "solution": {
      "sliding-window": "class Solution {\n    public int subarraysWithKDistinct(int[] nums, int k) {\n        return atMostackDistinct(nums, k) - atMostackDistinct(nums, k - 1);\n    }\n    \n    private int atMostackDistinct(int[] nums, int k) {\n        int n = nums.length;\n        int left = 0;\n        int count = 0;\n        Map<Integer, Integer> frequency = new HashMap<>();\n        int distinctCount = 0;\n        \n        for (int right = 0; right < n; right++) {\n            int num = nums[right];\n            if (frequency.getOrDefault(num, 0) == 0) {\n                distinctCount++;\n            }\n            frequency.put(num, frequency.getOrDefault(num, 0) + 1);\n            \n            while (distinctCount > k) {\n                int leftNum = nums[left++];\n                frequency.put(leftNum, frequency.get(leftNum) - 1);\n                if (frequency.get(leftNum) == 0) {\n                    distinctCount--;\n                }\n            }\n            \n            count += right - left + 1;\n        }\n        \n        return count;\n    }\n}\n"
    }
  },
  "993": {
    "solution": {
      "tree": ""
    }
  },
  "994": {
    "solution": {
      "breadth-first-search": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n\n    private static final int[][] DIRECTIONS = {\n            {0, 1}, {1, 0}, {0, -1}, {-1, 0}\n    };\n\n    public static int orangesRotting(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        Queue<int[]> queue = new LinkedList<>();\n        int freshOranges = 0;\n\n        // Step 1: Initialize the queue with all initially rotten oranges\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 2) {\n                    queue.offer(new int[]{i, j});\n                } else if (grid[i][j] == 1) {\n                    freshOranges++;\n                }\n            }\n        }\n\n        if (freshOranges == 0) return 0;\n\n        int minutes = -1;\n\n        // Step 2: BFS traversal\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            minutes++;\n            for (int k = 0; k < size; k++) {\n                int[] cell = queue.poll();\n                int row = cell[0];\n                int col = cell[1];\n\n                for (int[] dir : DIRECTIONS) {\n                    int newRow = row + dir[0];\n                    int newCol = col + dir[1];\n\n                    if (isValid(newRow, newCol, m, n, grid)) {\n                        grid[newRow][newCol] = 2;\n                        freshOranges--;\n                        queue.offer(new int[]{newRow, newCol});\n                    }\n                }\n            }\n        }\n\n        return freshOranges == 0 ? minutes : -1;\n    }\n\n    private static boolean isValid(int i, int j, int m, int n, int[][] grid) {\n        return i >= 0 && i < m && j >= 0 && j < n && grid[i][j] == 1;\n    }\n\n    public static void main(String[] args) {\n        int[][] grid = {\n                {2, 1, 1},\n                {1, 1, 0},\n                {0, 1, 1}\n        };\n        System.out.println(orangesRotting(grid)); // Output: 4\n    }\n}"
    }
  },
  "995": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int minKBitFlips(int[] nums, int k) {\n        int ans = 0;\n        int flippedTime = 0;\n        int left = 0;\n        for (int right = 0; right < nums.length; ++right) {\n            if (right >= k && nums[right - k] == 2)\n                --flippedTime;\n\n            if (flippedTime % 2 == nums[right]) {\n                if (right + k > nums.length)\n                    return -1;\n                ++ans;\n                ++flippedTime;\n                nums[right] = 2;\n            }\n        }\n\n        return ans;\n    }\n}\n"
    }
  },
  "996": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    private int count = 0;\n\n    public int numSquarefulPerms(int[] nums) {\n        Arrays.sort(nums);\n        boolean[] visited = new boolean[nums.length];\n        dfs(nums, visited, new ArrayList<>());\n        return count;\n    }\n\n    private void dfs(int[] nums, boolean[] visited, List<Integer> current) {\n        if (current.size() == nums.length) {\n            count++;\n            return;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (visited[i]) continue;\n            if (i > 0 && nums[i] == nums[i - 1] && !visited[i - 1]) continue;\n            if (!current.isEmpty() && !isPerfectSquare(current.get(current.size() - 1) + nums[i])) continue;\n\n            visited[i] = true;\n            current.add(nums[i]);\n            dfs(nums, visited, current);\n            visited[i] = false;\n            current.remove(current.size() - 1);\n        }\n    }\n\n    private boolean isPerfectSquare(int num) {\n        int sqrt = (int) Math.sqrt(num);\n        return sqrt * sqrt == num;\n    }\n}"
    }
  },
  "997": {
    "solution": {
      "graph": "class Solution {\n    public int findJudge(int n, int[][] trust) {\n        int[] trustScore = new int[n + 1];\n\n        for (int[] t : trust) {\n            trustScore[t[0]]--; // person who trusts loses a point\n            trustScore[t[1]]++; // person who is trusted gains a point\n        }\n\n        for (int i = 1; i <= n; i++) {\n            if (trustScore[i] == n - 1) return i;\n        }\n\n        return -1;\n    }\n}"
    }
  },
  "998": {
    "solution": {
      "binary-tree": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public TreeNode insertIntoMaxTree(TreeNode root, int val) {\n        if (root == null) {\n            return new TreeNode(val);\n        }\n\n        if (val > root.val) {\n            TreeNode newRoot = new TreeNode(val);\n            newRoot.left = root;\n            return newRoot;\n        }\n\n        root.right = insertIntoMaxTree(root.right, val);\n        return root;\n    }\n}"
    }
  },
  "999": {
    "solution": {
      "matrix": ""
    }
  },
  "1000": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1001": {
    "solution": {
      "hash-table": ""
    }
  },
  "1002": {
    "solution": {
      "hash-table": ""
    }
  },
  "1003": {
    "solution": {
      "stack": ""
    }
  },
  "1004": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int longestOnes(int[] nums, int k) {\n        int left = 0;\n        int right = 0;\n        int maxOnes = 0;\n        int zerosCount = 0;\n\n        for (right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zerosCount++;\n            }\n\n            while (zerosCount > k) {\n                if (nums[left] == 0) {\n                    zerosCount--;\n                }\n                left++;\n            }\n\n            maxOnes = Math.max(maxOnes, right - left + 1);\n        }\n\n        return maxOnes;\n    }\n\n// /**\n//  * @param {number[]} nums\n//  * @param {number} k\n//  * @return {number}\n//  */\n// var longestOnes = function(nums, k) {\n//     let ans = 0;\n//     for (let l = 0, r = 0; r < nums.length; ++r) {\n//         if (nums[r] == 0)\n//             --k;\n//         while (k < 0)\n//             if (nums[l++] == 0)\n//                 ++k;\n//         ans = Math.max(ans, r - l + 1);\n//     }\n//     return ans;\n// };\n// console.log(longestOnes([1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0], 2))\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 0};\n        int k = 2;\n        System.out.println(solution.longestOnes(nums, k)); // Output: 6\n    }\n}"
    }
  },
  "1005": {
    "solution": {
      "sorting": "import java.util.Arrays;\n\nclass Solution {\n    public int largestSumAfterKNegations(int[] nums, int k) {\n        Arrays.sort(nums);\n\n        for (int i = 0; i < nums.length && k > 0; i++) {\n            if (nums[i] < 0) {\n                nums[i] = -nums[i];\n                k--;\n            }\n        }\n\n        Arrays.sort(nums); // Resort to get the smallest element at index 0\n\n        if (k % 2 == 1) {\n            nums[0] = -nums[0];\n        }\n\n        int sum = 0;\n        for (int num : nums) {\n            sum += num;\n        }\n\n        return sum;\n    }\n}"
    }
  },
  "1006": {
    "solution": {
      "stack": ""
    }
  },
  "1007": {
    "solution": {
      "greedy": ""
    }
  },
  "1008": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int index = 0;\n\n    public TreeNode bstFromPreorder(int[] preorder) {\n        return bstFromPreorder(preorder, Integer.MIN_VALUE, Integer.MAX_VALUE);\n    }\n    \n    private TreeNode bstFromPreorder(int[] preorder, int lower, int upper) {\n        if (index == preorder.length || preorder[index] < lower || preorder[index] > upper) {\n            return null;\n        }\n        \n        int val = preorder[index++];\n        TreeNode root = new TreeNode(val);\n        root.left = bstFromPreorder(preorder, lower, val - 1);\n        root.right = bstFromPreorder(preorder, val + 1, upper);\n        \n        return root;\n    }\n}\n"
    }
  },
  "1009": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1010": {
    "solution": {
      "counting": ""
    }
  },
  "1011": {
    "solution": {
      "array": ""
    }
  },
  "1012": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numDupDigitsAtMostN(int n) {\n        return n - countSpecialNumbers(n);\n    }\n\n    private int countSpecialNumbers(int n) {\n        String numStr = Integer.toString(n);\n        int len = numStr.length();\n        int[][][] memo = new int[len + 1][1 << 10][2];\n\n        for (int[][] layer : memo) {\n            for (int[] row : layer) {\n                Arrays.fill(row, -1);\n            }\n        }\n\n        return count(numStr, 0, 0, true, memo) - 1;\n    }\n\n    private int count(String number, int index, int usedMask, boolean isTight, int[][][] memo) {\n        if (index == number.length()) {\n            return 1;\n        }\n\n        int tightFlag = isTight ? 1 : 0;\n        if (memo[index][usedMask][tightFlag] != -1) {\n            return memo[index][usedMask][tightFlag];\n        }\n\n        int result = 0;\n        int maxDigit = isTight ? number.charAt(index) - '0' : 9;\n\n        for (int digit = 0; digit <= maxDigit; digit++) {\n            if ((usedMask >> digit & 1) == 1) continue;\n            boolean nextTight = isTight && (digit == maxDigit);\n            if (usedMask == 0 && digit == 0) {\n                result += count(number, index + 1, usedMask, nextTight, memo);\n            } else {\n                result += count(number, index + 1, usedMask | (1 << digit), nextTight, memo);\n            }\n        }\n\n        memo[index][usedMask][tightFlag] = result;\n        return result;\n    }\n}"
    }
  },
  "1013": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public boolean canThreePartsEqualSum(int[] arr) {\n        int totalSum = Arrays.stream(arr).sum();\n        if (totalSum % 3 != 0) return false;\n\n        int target = totalSum / 3;\n        int sum = 0, count = 0;\n\n        for (int num : arr) {\n            sum += num;\n            if (sum == target) {\n                count++;\n                sum = 0;\n            }\n        }\n\n        return count >= 3;\n    }\n}"
    }
  },
  "1014": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1015": {
    "solution": {
      "math": ""
    }
  },
  "1016": {
    "solution": {
      "string": ""
    }
  },
  "1017": {
    "solution": {
      "math": "class Solution {\n    public String baseNeg2(int n) {\n        if (n == 0) return \"0\";\n\n        StringBuilder sb = new StringBuilder();\n        while (n != 0) {\n            int remainder = n % -2;\n            n /= -2;\n            if (remainder < 0) {\n                remainder += 2;\n                n++;\n            }\n            sb.append(remainder);\n        }\n\n        return sb.reverse().toString();\n    }\n}"
    }
  },
  "1018": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1019": {
    "solution": {
      "monotonic-stack": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public int[] nextLargerNodes(ListNode head) {\n        List<Integer> nums = new ArrayList<>();\n        for (; head != null; head = head.next) {\n            nums.add(head.val);\n        }\n        Deque<Integer> stack = new ArrayDeque<>();\n        int n = nums.size();\n        int[] ans = new int[n];\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && stack.peek() <= nums.get(i)) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                ans[i] = stack.peek();\n            }\n            stack.push(nums.get(i));\n        }\n        return ans;\n    }\n}"
    }
  },
  "1020": {
    "solution": {
      "union-find": ""
    }
  },
  "1021": {
    "solution": {
      "stack": ""
    }
  },
  "1022": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int sumRootToLeaf(TreeNode root) {\n        return dfs(root, 0);\n    }\n\n    private int dfs(TreeNode node, int currentSum) {\n        if (node == null) return 0;\n        currentSum = (currentSum << 1) | node.val;\n        if (node.left == null && node.right == null) {\n            return currentSum;\n        }\n        return dfs(node.left, currentSum) + dfs(node.right, currentSum);\n    }\n}"
    }
  },
  "1023": {
    "solution": {
      "string-matching": "class Solution {\n    public List<Boolean> camelMatch(String[] queries, String pattern) {\n        List<Boolean> result = new ArrayList<>();\n        for (String query : queries) {\n            result.add(matches(query, pattern));\n        }\n        return result;\n    }\n\n    private boolean matches(String query, String pattern) {\n        int i = 0, j = 0;\n        while (i < query.length() && j < pattern.length()) {\n            if (query.charAt(i) == pattern.charAt(j)) {\n                i++;\n                j++;\n            } else if (Character.isUpperCase(query.charAt(i))) {\n                return false;\n            } else {\n                i++;\n            }\n        }\n        while (i < query.length()) {\n            if (Character.isUpperCase(query.charAt(i))) return false;\n            i++;\n        }\n        return j == pattern.length();\n    }\n}"
    }
  },
  "1024": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1025": {
    "solution": {
      "brainteaser": ""
    }
  },
  "1026": {
    "solution": {
      "binary-tree": "class Solution {\n    public int maxAncestorDiff(TreeNode root) {\n        return dfs(root, root.val, root.val);\n    }\n\n    private int dfs(TreeNode node, int minVal, int maxVal) {\n        if (node == null) return maxVal - minVal;\n        minVal = Math.min(minVal, node.val);\n        maxVal = Math.max(maxVal, node.val);\n        return Math.max(dfs(node.left, minVal, maxVal), dfs(node.right, minVal, maxVal));\n    }\n}"
    }
  },
  "1027": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1028": {
    "solution": {
      "binary-tree": "class Solution {\n    int index = 0;\n\n    public TreeNode recoverFromPreorder(String traversal) {\n        return helper(traversal, 0);\n    }\n\n    private TreeNode helper(String s, int depth) {\n        int dashes = 0;\n        while (index + dashes < s.length() && s.charAt(index + dashes) == '-') {\n            dashes++;\n        }\n        if (dashes != depth) return null;\n        index += dashes;\n        int start = index;\n        while (index < s.length() && Character.isDigit(s.charAt(index))) index++;\n        int val = Integer.parseInt(s.substring(start, index));\n        TreeNode node = new TreeNode(val);\n        node.left = helper(s, depth + 1);\n        node.right = helper(s, depth + 1);\n        return node;\n    }\n}"
    }
  },
  "1029": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int twoCitySchedCost(int[][] costs) {\n        Arrays.sort(costs, (a, b) -> (a[0] - a[1]) - (b[0] - b[1]));\n        int total = 0;\n        int n = costs.length / 2;\n        for (int i = 0; i < n; i++) total += costs[i][0];\n        for (int i = n; i < 2 * n; i++) total += costs[i][1];\n        return total;\n    }\n}"
    }
  },
  "1030": {
    "solution": {
      "matrix": ""
    }
  },
  "1031": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int maxSumTwoNoOverlap(int[] nums, int L, int M) {\n        int n = nums.length;\n        int[] prefixSum = new int[n + 1];\n        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        int maxL = 0, maxM = 0, result = 0;\n        \n        for (int i = L + M; i <= n; i++) {\n            maxL = Math.max(maxL, prefixSum[i - M] - prefixSum[i - M - L]);\n            maxM = Math.max(maxM, prefixSum[i - L] - prefixSum[i - L - M]);\n            result = Math.max(result, Math.max(maxL + prefixSum[i] - prefixSum[i - M], maxM + prefixSum[i] - prefixSum[i - L]));\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {0, 6, 5, 2, 2, 5, 1, 9, 4};\n        int L = 1;\n        int M = 2;\n        System.out.println(solution.maxSumTwoNoOverlap(nums, L, M)); // Output: 20\n    }\n}\n"
    }
  },
  "1032": {
    "solution": {
      "data-stream": ""
    }
  },
  "1033": {
    "solution": {
      "brainteaser": ""
    }
  },
  "1034": {
    "solution": {
      "matrix": ""
    }
  },
  "1035": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1036": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "1037": {
    "solution": {
      "geometry": ""
    }
  },
  "1038": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "1039": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1040": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1041": {
    "solution": {
      "math": ""
    }
  },
  "1042": {
    "solution": {
      "graph": ""
    }
  },
  "1043": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1044": {
    "solution": {
      "suffix-array": "import java.util.Arrays;\n\npublic class Solution {\n\n    public String longestDupSubstring(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(suffixArray, s);\n\n        int pos = -1, maxLen = 0;\n        for (int i = 0; i < n - 1; i++) {\n            if (lcpArray[i] > maxLen) {\n                maxLen = lcpArray[i];\n                pos = suffixArray[i];\n            }\n        }\n\n        return pos == -1 ? \"\" : s.substring(pos, pos + maxLen);\n    }\n\n    private int[] buildSuffixArray(String S) {\n        int n = S.length();\n        Integer[] order = new Integer[n];\n        for (int i = 0; i < n; i++)\n            order[i] = n - 1 - i;\n\n        Arrays.sort(order, (a, b) -> Character.compare(S.charAt(a), S.charAt(b)));\n\n        int[] suffixArray = new int[n];\n        int[] classes = new int[n];\n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = order[i];\n            classes[i] = S.charAt(i);\n        }\n\n        for (int len = 1; len < n; len *= 2) {\n            int[] c = classes.clone();\n            for (int i = 0; i < n; i++) {\n                classes[suffixArray[i]] = i > 0 && c[suffixArray[i - 1]] == c[suffixArray[i]] && suffixArray[i - 1] + len < n\n                        && c[suffixArray[i - 1] + len / 2] == c[suffixArray[i] + len / 2] ? classes[suffixArray[i - 1]] : i;\n            }\n\n            int[] count = new int[n];\n            for (int i = 0; i < n; i++)\n                count[i] = i;\n            int[] s = suffixArray.clone();\n            for (int i = 0; i < n; i++) {\n                int s1 = s[i] - len;\n                if (s1 >= 0)\n                    suffixArray[count[classes[s1]]++] = s1;\n            }\n        }\n\n        return suffixArray;\n    }\n\n    private int[] buildLCPArray(int[] suffixArray, String s) {\n        int n = suffixArray.length;\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++)\n            rank[suffixArray[i]] = i;\n        int[] lcpArray = new int[n - 1];\n        for (int i = 0, h = 0; i < n; i++) {\n            if (rank[i] < n - 1) {\n                int j = suffixArray[rank[i] + 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i]] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n        return lcpArray;\n    }\n}\n",
      "rolling-hash": "class Solution {\n    public String longestDupSubstring(String s) {\n        int kMod = 1_000_000_007;\n        int n = s.length();\n        int[] pows = new int[n];\n        int bestStart = -1;\n        int left = 1;\n        int right = n;\n\n        pows[0] = 1;\n        for (int i = 1; i < n; ++i)\n            pows[i] = (int) ((pows[i - 1] * 26L) % (long) kMod);\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            int start = getStart(s, mid, pows, kMod);\n            if (start == -1) {\n                right = mid;\n            } else {\n                bestStart = start;\n                left = mid + 1;\n            }\n        }\n\n        if (bestStart == -1)\n            return \"\";\n        if (getStart(s, left, pows, kMod) == -1)\n            return s.substring(bestStart, bestStart + left - 1);\n        return s.substring(bestStart, bestStart + left);\n    }\n\n    private int getStart(String s, int k, int[] pows, int kMod) {\n        Map<Long, List<Integer>> hashToStarts = new HashMap<>();\n        long hash = 0;\n\n        for (int i = 0; i < k; ++i)\n            hash = ((hash * 26) % kMod + val(s.charAt(i))) % kMod;\n        hashToStarts.put(hash, new ArrayList<>());\n        hashToStarts.get(hash).add(0);\n\n        for (int i = k; i < s.length(); ++i) {\n            int startIndex = i - k + 1;\n            hash = ((hash - (long) (pows[k - 1]) * val(s.charAt(i - k))) % kMod + kMod) % kMod;\n            hash = (hash * 26 + val(s.charAt(i))) % kMod;\n            if (hashToStarts.containsKey(hash)) {\n                String currSub = s.substring(startIndex, startIndex + k);\n                for (int start : hashToStarts.get(hash))\n                    if (s.substring(start, start + k).equals(currSub))\n                        return startIndex;\n            }\n            hashToStarts.put(hash, new ArrayList<>());\n            hashToStarts.get(hash).add(startIndex);\n        }\n\n        return -1;\n    }\n\n    private int val(char c) {\n        return c - 'a';\n    }\n}"
    }
  },
  "1045": {
    "solution": {
      "database": ""
    }
  },
  "1046": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1047": {
    "solution": {
      "stack": ""
    }
  },
  "1048": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1049": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int lastStoneWeightII(int[] stones) {\n        int sum = Arrays.stream(stones).sum();\n        boolean[] dp = new boolean[sum + 1];\n        dp[0] = true;\n        int maxWeight = 0;\n\n        for (int stone : stones) {\n            for (int j = sum / 2; j >= stone; j--) {\n                dp[j] = dp[j] || dp[j - stone];\n                if (dp[j]) maxWeight = Math.max(maxWeight, j);\n            }\n        }\n\n        return sum - 2 * maxWeight;\n    }\n}"
    }
  },
  "1050": {
    "solution": {
      "database": ""
    }
  },
  "1051": {
    "solution": {
      "counting-sort": "class Solution {\n    public int heightChecker(int[] heights) {\n        int maxNum = 100; // As the problem states that heights are between 1 and 100\n        int[] count = new int[maxNum + 1];\n        \n        for (int height : heights) {\n            count[height]++;\n        }\n        \n        int[] sortedHeights = new int[heights.length];\n        int index = 0;\n        for (int i = 1; i <= maxNum; i++) {\n            while (count[i] > 0) {\n                sortedHeights[index++] = i;\n                count[i]--;\n            }\n        }\n        \n        // Count the number of heights that are out of place\n        int result = 0;\n        for (int i = 0; i < heights.length; i++) {\n            if (heights[i] != sortedHeights[i]) {\n                result++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "1052": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int maxSatisfied(int[] customers, int[] grumpy, int X) {\n        int n = customers.length;\n        int totalSatisfied = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (grumpy[i] == 0) {\n                totalSatisfied += customers[i];\n            }\n        }\n\n        int maxAdditionalSatisfied = 0;\n        int currentAdditionalSatisfied = 0;\n\n        for (int i = 0; i < n; i++) {\n            if (grumpy[i] == 1) {\n                currentAdditionalSatisfied += customers[i];\n            }\n            if (i >= X) {\n                if (grumpy[i - X] == 1) {\n                    currentAdditionalSatisfied -= customers[i - X];\n                }\n            }\n\n            maxAdditionalSatisfied = Math.max(maxAdditionalSatisfied, currentAdditionalSatisfied);\n        }\n\n        return totalSatisfied + maxAdditionalSatisfied;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] customers = {1, 0, 1, 2, 1, 1, 7, 5};\n        int[] grumpy = {0, 1, 0, 1, 0, 1, 0, 1};\n        int X = 3;\n        System.out.println(solution.maxSatisfied(customers, grumpy, X)); \n    }\n}\n"
    }
  },
  "1053": {
    "solution": {
      "greedy": "class Solution {\n    public int[] prevPermOpt1(int[] arr) {\n        int n = arr.length;\n        for (int i = n - 2; i >= 0; i--) {\n            if (arr[i] > arr[i + 1]) {\n                int j = n - 1;\n                while (arr[j] >= arr[i] || (j > 0 && arr[j] == arr[j - 1])) j--;\n                int temp = arr[i];\n                arr[i] = arr[j];\n                arr[j] = temp;\n                break;\n            }\n        }\n        return arr;\n    }\n}"
    }
  },
  "1054": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1055": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1056": {
    "solution": {
      "math": "class Solution {\n    public boolean confusingNumber(int n) {\n        int[] map = {0, 1, -1, -1, -1, -1, 9, -1, 8, 6};\n        int original = n, rotated = 0;\n        while (n > 0) {\n            int d = n % 10;\n            if (map[d] == -1) return false;\n            rotated = rotated * 10 + map[d];\n            n /= 10;\n        }\n        return rotated != original;\n    }\n}"
    }
  },
  "1057": {
    "solution": {
      "greedy": ""
    }
  },
  "1058": {
    "solution": {
      "greedy": ""
    }
  },
  "1059": {
    "solution": {
      "topological-sort": "import java.util.List;\n\nclass Solution {\n    private List<Integer>[] g;\n    private int[] f;\n    private boolean[] vis;\n    private int k;\n\n    public boolean leadsToDestination(int n, int[][] edges, int source, int destination) {\n        Set<Integer>[] graph = new Set[n]; // node => set of its next nodes\n\n        for (int i = 0; i < n; i++) {\n            graph[i] = new HashSet<Integer>();\n        }\n\n        int[] inDegrees = new int[n];\n        for (int[] edge : edges) {\n            graph[edge[0]].add(edge[1]);\n            inDegrees[edge[1]]++;\n        }\n\n        LinkedList<Integer> q = new LinkedList<Integer>();\n        q.add(source);\n\n        while (!q.isEmpty()) {\n            int cur = q.poll();\n            if (graph[cur].size() == 0 && cur != destination) {\n                return false;\n            }\n\n            for (int nei : graph[cur]) {\n                if (inDegrees[nei] < 0) {\n                    return false;\n                }\n\n                inDegrees[nei]--;\n\n                q.add(nei);\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "1060": {
    "solution": {
      "array": ""
    }
  },
  "1061": {
    "solution": {
      "union-find": "class Solution {\n    int[] parent = new int[26];\n\n    public String smallestEquivalentString(String s1, String s2, String baseStr) {\n        for (int i = 0; i < 26; i++) parent[i] = i;\n        for (int i = 0; i < s1.length(); i++) {\n            union(s1.charAt(i) - 'a', s2.charAt(i) - 'a');\n        }\n        StringBuilder sb = new StringBuilder();\n        for (char c : baseStr.toCharArray()) {\n            sb.append((char)(find(c - 'a') + 'a'));\n        }\n        return sb.toString();\n    }\n\n    private int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    private void union(int x, int y) {\n        int px = find(x), py = find(y);\n        if (px != py) {\n            if (px < py) parent[py] = px;\n            else parent[px] = py;\n        }\n    }\n}"
    }
  },
  "1062": {
    "solution": {
      "suffix-array": "import java.util.*;\n\npublic class Solution {\n    public String longestRepeatingSubstring(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(s, suffixArray);\n        \n        int left = 1, right = n;\n        int maxLength = 0;\n        String result = \"\";\n        \n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (hasRepeatedSubstring(mid, n, suffixArray, lcpArray)) {\n                maxLength = mid;\n                left = mid + 1;\n            } else {\n                right = mid - 1;\n            }\n        }\n        \n        for (int i = 0; i <= n - maxLength; i++) {\n            String candidate = s.substring(suffixArray[i], suffixArray[i] + maxLength);\n            if (hasRepeatedSubstring(candidate, s, maxLength)) {\n                return candidate;\n            }\n        }\n        \n        return result;\n    }\n    \n    private boolean hasRepeatedSubstring(int len, int n, int[] suffixArray, int[] lcpArray) {\n        for (int i = 1; i < n; i++) {\n            if (lcpArray[i] >= len) {\n                int start1 = suffixArray[i - 1];\n                int start2 = suffixArray[i];\n                if ((start1 < n - len && start2 > n - len) || (start1 > n - len && start2 < n - len)) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n    \n    private boolean hasRepeatedSubstring(String candidate, String s, int len) {\n        int count = 0;\n        int index = s.indexOf(candidate);\n        while (index != -1) {\n            count++;\n            index = s.indexOf(candidate, index + 1);\n        }\n        return count > 1;\n    }\n    \n    private int[] buildSuffixArray(String s) {\n        int n = s.length();\n        Integer[] order = new Integer[n];\n        for (int i = 0; i < n; i++) {\n            order[i] = i;\n        }\n        \n        Arrays.sort(order, (a, b) -> Character.compare(s.charAt(a), s.charAt(b)));\n        \n        int[] suffixArray = new int[n];\n        int[] classes = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = order[i];\n            classes[i] = s.charAt(i);\n        }\n        \n        for (int len = 1; len < n; len *= 2) {\n            int[] c = classes.clone();\n            for (int i = 0; i < n; i++) {\n                classes[suffixArray[i]] = i > 0 && c[suffixArray[i - 1]] == c[suffixArray[i]] && suffixArray[i - 1] + len < n\n                        && c[suffixArray[i - 1] + len / 2] == c[suffixArray[i] + len / 2] ? classes[suffixArray[i - 1]] : i;\n            }\n            \n            int[] count = new int[n];\n            for (int i = 0; i < n; i++) {\n                count[i] = i;\n            }\n            \n            int[] s = suffixArray.clone();\n            for (int i = 0; i < n; i++) {\n                int s1 = s[i] - len;\n                if (s1 >= 0) {\n                    suffixArray[count[classes[s1]]++] = s1;\n                }\n            }\n        }\n        \n        return suffixArray;\n    }\n    \n    private int[] buildLCPArray(String s, int[] suffixArray) {\n        int n = s.length();\n        int[] rank = new int[n];\n        for (int i = 0; i < n; i++) {\n            rank[suffixArray[i]] = i;\n        }\n        \n        int[] lcpArray = new int[n - 1];\n        int h = 0;\n        \n        for (int i = 0; i < n; i++) {\n            if (rank[i] > 0) {\n                int j = suffixArray[rank[i] - 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i] - 1] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n        \n        return lcpArray;\n    }\n}\n",
      "dynamic-programming": "class Solution {\n    public int longestRepeatingSubstring(String s) {\n        int n = s.length();\n        int ans = 0;\n        int[][] dp = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = i > 0 ? dp[i - 1][j - 1] + 1 : 1;\n                    ans = Math.max(ans, dp[i][j]);\n                }\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "1063": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int validSubarrays(int[] nums) {\n        int n = nums.length;\n        int[] right = new int[n];\n        Arrays.fill(right, n);\n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            if (!stack.isEmpty()) {\n                right[i] = stack.peek();\n            }\n            stack.push(i);\n        }\n        int ans = 0;\n        for (int i = 0; i < n; ++i) {\n            ans += right[i] - i;\n        }\n        return ans;\n    }\n}"
    }
  },
  "1064": {
    "solution": {
      "array": ""
    }
  },
  "1065": {
    "solution": {
      "trie": "class Trie {\n    Trie[] children = new Trie[26];\n    boolean isEnd = false;\n\n    void insert(String word) {\n        Trie node = this;\n        for (char c : word.toCharArray()) {\n            int idx = c - 'a';\n            if (node.children[idx] == null) node.children[idx] = new Trie();\n            node = node.children[idx];\n        }\n        node.isEnd = true;\n    }\n}\n\nclass Solution {\n    public int[][] indexPairs(String text, String[] words) {\n        Trie root = new Trie();\n        for (String word : words) root.insert(word);\n        List<int[]> result = new ArrayList<>();\n\n        for (int i = 0; i < text.length(); i++) {\n            Trie node = root;\n            for (int j = i; j < text.length(); j++) {\n                int idx = text.charAt(j) - 'a';\n                if (node.children[idx] == null) break;\n                node = node.children[idx];\n                if (node.isEnd) result.add(new int[]{i, j});\n            }\n        }\n\n        return result.toArray(new int[0][]);\n    }\n}"
    }
  },
  "1066": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1067": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1068": {
    "solution": {
      "database": ""
    }
  },
  "1069": {
    "solution": {
      "database": ""
    }
  },
  "1070": {
    "solution": {
      "database": ""
    }
  },
  "1071": {
    "solution": {
      "math": ""
    }
  },
  "1072": {
    "solution": {
      "matrix": ""
    }
  },
  "1073": {
    "solution": {
      "math": "class Solution {\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\n        List<Integer> result = new ArrayList<>();\n        int i = arr1.length - 1, j = arr2.length - 1, carry = 0;\n\n        while (i >= 0 || j >= 0 || carry != 0) {\n            int x = i >= 0 ? arr1[i--] : 0;\n            int y = j >= 0 ? arr2[j--] : 0;\n            int sum = x + y + carry;\n            result.add(sum & 1);\n            carry = -(sum >> 1);\n        }\n\n        while (result.size() > 1 && result.get(result.size() - 1) == 0) {\n            result.remove(result.size() - 1);\n        }\n\n        Collections.reverse(result);\n        return result.stream().mapToInt(Integer::intValue).toArray();\n    }\n}"
    }
  },
  "1074": {
    "solution": {
      "matrix": "class Solution {\n  public int numSubmatrixSumTarget(int[][] matrix, int target) {\n    int m = matrix.length;\n    int n = matrix[0].length;\n    int ans = 0;\n\n    for (int[] row : matrix)\n      for (int i = 1; i < n; ++i)\n        row[i] += row[i - 1];\n\n    for (int baseCol = 0; baseCol < n; ++baseCol)\n      for (int j = baseCol; j < n; ++j) {\n        Map<Integer, Integer> prefixCount = new HashMap<>();\n        prefixCount.put(0, 1);\n        int sum = 0;\n        for (int i = 0; i < m; ++i) {\n          if (baseCol > 0)\n            sum -= matrix[i][baseCol - 1];\n          sum += matrix[i][j];\n          ans += prefixCount.getOrDefault(sum - target, 0);\n          prefixCount.merge(sum, 1, Integer::sum);\n        }\n      }\n\n    return ans;\n  }\n}"
    }
  },
  "1075": {
    "solution": {
      "database": ""
    }
  },
  "1076": {
    "solution": {
      "database": ""
    }
  },
  "1077": {
    "solution": {
      "database": ""
    }
  },
  "1078": {
    "solution": {
      "string": "class Solution {\n    public String[] findOcurrences(String text, String first, String second) {\n        String[] words = text.split(\" \");\n        List<String> result = new ArrayList<>();\n        for (int i = 0; i < words.length - 2; i++) {\n            if (words[i].equals(first) && words[i + 1].equals(second)) {\n                result.add(words[i + 2]);\n            }\n        }\n        return result.toArray(new String[0]);\n    }\n}"
    }
  },
  "1079": {
    "solution": {
      "backtracking": ""
    }
  },
  "1080": {
    "solution": {
      "binary-tree": "class Solution {\n    public TreeNode sufficientSubset(TreeNode root, int limit) {\n        return dfs(root, 0, limit);\n    }\n\n    private TreeNode dfs(TreeNode node, int sum, int limit) {\n        if (node == null) return null;\n\n        sum += node.val;\n\n        if (node.left == null && node.right == null) {\n            return sum >= limit ? node : null;\n        }\n\n        node.left = dfs(node.left, sum, limit);\n        node.right = dfs(node.right, sum, limit);\n\n        return (node.left == null && node.right == null) ? null : node;\n    }\n}"
    }
  },
  "1081": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1082": {
    "solution": {
      "database": ""
    }
  },
  "1083": {
    "solution": {
      "database": ""
    }
  },
  "1084": {
    "solution": {
      "database": ""
    }
  },
  "1085": {
    "solution": {
      "math": ""
    }
  },
  "1086": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1087": {
    "solution": {
      "backtracking": ""
    }
  },
  "1088": {
    "solution": {
      "backtracking": ""
    }
  },
  "1089": {
    "solution": {
      "two-pointers": "public class Solution {\n    public void duplicateZeros(int[] arr) {\n        int n = arr.length;\n        \n        int zeroCount = 0;\n        for (int num : arr) {\n            if (num == 0) {\n                zeroCount++;\n            }\n        }\n        \n        int lastIndex = n - 1;\n        for (int i = lastIndex; i >= 0; i--) {\n            if (arr[i] == 0) {\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = 0;\n                }\n                zeroCount--;\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = 0;\n                }\n            } else {\n                if (i + zeroCount <= lastIndex) {\n                    arr[i + zeroCount] = arr[i];\n                }\n            }\n        }\n    }\n}\n"
    }
  },
  "1090": {
    "solution": {
      "counting": ""
    }
  },
  "1091": {
    "solution": {
      "matrix": "class Solution {\n\n  private static int[][] dirs = {{-1, -1}, {-1, 0}, {-1, 1}, {0, -1}, {0, 1}, {1, -1}, {1, 0}, {1, 1}};\n\n  public int shortestPathBinaryMatrix(int[][] grid) {\n    int n = grid.length;\n    if (grid[0][0] == 0 && n == 1)\n      return 1;\n    if (grid[0][0] == 1 || grid[n - 1][n - 1] == 1)\n      return -1;\n\n    Queue<Pair<Integer, Integer>> q = new ArrayDeque<>(List.of(new Pair<>(0, 0)));\n    boolean[][] seen = new boolean[n][n];\n    seen[0][0] = true;\n\n    for (int step = 1; !q.isEmpty(); ++step)\n      for (int sz = q.size(); sz > 0; --sz) {\n        int i = q.peek().getKey();\n        int j = q.poll().getValue();\n\n        for (int[] dir : dirs) {\n          int x = i + dir[0];\n          int y = j + dir[1];\n          if (x < 0 || x == n || y < 0 || y == n)\n            continue;\n          if (grid[x][y] != 0 || seen[x][y])\n            continue;\n          if (x == n - 1 && y == n - 1)\n            return step + 1;\n          q.offer(new Pair<>(x, y));\n          seen[x][y] = true;\n        }\n      }\n\n    return -1;\n  }\n}"
    }
  },
  "1092": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public String shortestCommonSupersequence(String str1, String str2) {\n        int m = str1.length(), n = str2.length();\n        int[][] dp = new int[m + 1][n + 1];\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (str1.charAt(i) == str2.charAt(j)) {\n                    dp[i + 1][j + 1] = dp[i][j] + 1;\n                } else {\n                    dp[i + 1][j + 1] = Math.max(dp[i][j + 1], dp[i + 1][j]);\n                }\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        int i = m, j = n;\n        while (i > 0 && j > 0) {\n            if (str1.charAt(i - 1) == str2.charAt(j - 1)) {\n                sb.append(str1.charAt(i - 1));\n                i--;\n                j--;\n            } else if (dp[i - 1][j] >= dp[i][j - 1]) {\n                sb.append(str1.charAt(i - 1));\n                i--;\n            } else {\n                sb.append(str2.charAt(j - 1));\n                j--;\n            }\n        }\n        while (i > 0) sb.append(str1.charAt(--i));\n        while (j > 0) sb.append(str2.charAt(--j));\n\n        return sb.reverse().toString();\n    }\n}"
    }
  },
  "1093": {
    "solution": {
      "probability-and-statistics": "class Solution {\n    public double[] sampleStats(int[] count) {\n      int n = Arrays.stream(count).sum();\n        return new double[] {\n                getMinimum(count), \n                getMaximum(count), \n                getMean(count, n), \n                (getLeftMedian(count, n) + getRightMedian(count, n)) / 2.0,\n                getMode(count),\n        };\n    }\n\n    private double getMinimum(int[] count) {\n        for (int i = 0; i < count.length; ++i)\n            if (count[i] > 0)\n                return i;\n        return -1;\n    }\n\n    private double getMaximum(int[] count) {\n        for (int i = count.length - 1; i >= 0; --i)\n            if (count[i] > 0)\n                return i;\n        return -1;\n    }\n\n    private double getMean(int[] count, double n) {\n        double mean = 0;\n        for (int i = 0; i < count.length; ++i)\n            mean += ((long) i * (long) count[i]) / n;\n        return mean;\n    }\n\n    private double getLeftMedian(int[] count, double n) {\n        int numCount = 0;\n        for (int i = 0; i < count.length; ++i) {\n            numCount += count[i];\n            if (numCount >= n / 2)\n                return i;\n        }\n        return -1;\n    }\n\n    private double getRightMedian(int[] count, double n) {\n        int numCount = 0;\n        for (int i = count.length - 1; i >= 0; --i) {\n            numCount += count[i];\n            if (numCount >= n / 2)\n                return i;\n        }\n        return -1;\n    }\n\n    private double getMode(int[] count) {\n        int mode = -1;\n        int maxCount = 0;\n        for (int i = 0; i < count.length; ++i)\n            if (count[i] > maxCount) {\n                maxCount = count[i];\n                mode = i;\n            }\n        return mode;\n    }\n}"
    }
  },
  "1094": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1095": {
    "solution": {
      "interactive": ""
    }
  },
  "1096": {
    "solution": {
      "stack": ""
    }
  },
  "1097": {
    "solution": {
      "database": "# Write your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            player_id,\n            event_date,\n            MIN(event_date) OVER (PARTITION BY player_id) AS install_dt\n        FROM Activity\n    )\nSELECT\n    install_dt,\n    COUNT(DISTINCT player_id) AS installs,\n    ROUND(\n        SUM(DATEDIFF(event_date, install_dt) = 1) / COUNT(DISTINCT player_id),\n        2\n    ) AS day1_retention\nFROM T\nGROUP BY 1;"
    }
  },
  "1098": {
    "solution": {
      "database": ""
    }
  },
  "1099": {
    "solution": {
      "two-pointers": "class Solution {\n    public int twoSumLessThanK(int[] nums, int k) {\n        Arrays.sort(nums);\n        int ans = -1;\n        int n = nums.length;\n        for (int i = 0; i < n; ++i) {\n            int j = search(nums, k - nums[i], i + 1, n) - 1;\n            if (i < j) {\n                ans = Math.max(ans, nums[i] + nums[j]);\n            }\n        }\n        return ans;\n    }\n\n    private int search(int[] nums, int x, int left, int right) {\n        while (left < right) {\n            int mid = (left + right) >> 1;\n            if (nums[mid] >= x) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return left;\n    }\n}\n"
    }
  },
  "1100": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int numKLenSubstrNoRepeats(String S, int K) {\n        int n = S.length();\n        if (n < K) return 0;\n\n        HashSet<Character> set = new HashSet<>();\n        int count = 0;\n\n        for (int i = 0; i <= n - K; i++) {\n            set.clear();\n            boolean isValid = true;\n            for (int j = i; j < i + K; j++) {\n                char ch = S.charAt(j);\n                if (set.contains(ch)) {\n                    isValid = false;\n                    break;\n                }\n                set.add(ch);\n            }\n            if (isValid) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"
    }
  },
  "1101": {
    "solution": {
      "union-find": ""
    }
  },
  "1102": {
    "solution": {
      "depth-first-search": "class Solution {\n    public int maximumMinimumPath(int[][] grid) {\n        int rows = grid.length, cols = grid[0].length;\n        int[] parent = new int[rows * cols];\n        for (int i = 0; i < parent.length; i++) parent[i] = i;\n\n        List<int[]> cells = new ArrayList<>();\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                cells.add(new int[] {grid[r][c], r, c});\n            }\n        }\n        cells.sort((a, b) -> Integer.compare(b[0], a[0])); // Descending\n\n        boolean[][] visited = new boolean[rows][cols];\n        int[][] dirs = {{0,1}, {1,0}, {0,-1}, {-1,0}};\n\n        for (int[] cell : cells) {\n            int val = cell[0], r = cell[1], c = cell[2];\n            visited[r][c] = true;\n            int id = r * cols + c;\n            for (int[] d : dirs) {\n                int nr = r + d[0], nc = c + d[1];\n                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && visited[nr][nc]) {\n                    int nid = nr * cols + nc;\n                    union(parent, id, nid);\n                }\n            }\n            if (find(parent, 0) == find(parent, rows * cols - 1)) {\n                return val;\n            }\n        }\n        return -1;\n    }\n\n    private int find(int[] parent, int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent, parent[x]);\n        }\n        return parent[x];\n    }\n\n    private void union(int[] parent, int x, int y) {\n        int px = find(parent, x);\n        int py = find(parent, y);\n        if (px != py) {\n            parent[py] = px;\n        }\n    }\n}"
    }
  },
  "1103": {
    "solution": {
      "math": ""
    }
  },
  "1104": {
    "solution": {
      "binary-tree": "class Solution {\n    public List<Integer> pathInZigZagTree(int label) {\n        List<Integer> path = new ArrayList<>();\n        int level = (int)(Math.log(label) / Math.log(2));\n\n        while (label > 0) {\n            path.add(0, label);\n            int levelStart = (int)Math.pow(2, level);\n            int levelEnd = (int)Math.pow(2, level + 1) - 1;\n            label = (levelStart + levelEnd - label) / 2;\n            level--;\n        }\n\n        return path;\n    }\n}"
    }
  },
  "1105": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1106": {
    "solution": {
      "recursion": "class Solution {\n    public boolean parseBoolExpr(String expression) {\n        Stack<Character> stack = new Stack<>();\n\n        for (char c : expression.toCharArray()) {\n            if (c == ',') continue;\n            if (c != ')') {\n                stack.push(c);\n            } else {\n                Set<Character> seen = new HashSet<>();\n                while (stack.peek() != '(') {\n                    seen.add(stack.pop());\n                }\n                stack.pop(); // remove '('\n                char op = stack.pop();\n                if (op == '&') {\n                    stack.push(seen.contains('f') ? 'f' : 't');\n                } else if (op == '|') {\n                    stack.push(seen.contains('t') ? 't' : 'f');\n                } else { // '!' operator\n                    stack.push(seen.contains('t') ? 'f' : 't');\n                }\n            }\n        }\n\n        return stack.pop() == 't';\n    }\n}"
    }
  },
  "1107": {
    "solution": {
      "database": ""
    }
  },
  "1108": {
    "solution": {
      "string": ""
    }
  },
  "1109": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1110": {
    "solution": {
      "tree": ""
    }
  },
  "1111": {
    "solution": {
      "stack": ""
    }
  },
  "1112": {
    "solution": {
      "database": ""
    }
  },
  "1113": {
    "solution": {
      "shortest-path": "class Solution {\n    public int largestUniqueNumber(int[] nums) {\n        int[] count = new int[1001];\n\n        for (int num : nums) {\n            count[num]++;\n        }\n\n        for (int i = 1000; i >= 0; i--) {\n            if (count[i] == 1) {\n                return i;\n            }\n        }\n\n        return -1;\n    }\n}"
    }
  },
  "1114": {
    "solution": {
      "concurrency": "class Foo {\n    private final Object lock = new Object();\n    private boolean firstExecuted;\n    private boolean secondExecuted;\n\n    public Foo() {\n        firstExecuted = false;\n        secondExecuted = false;\n    }\n\n    public void first(Runnable printFirst) throws InterruptedException {\n        synchronized (lock) {\n            printFirst.run();\n            firstExecuted = true;\n            lock.notifyAll(); // Notify waiting threads that first() has completed\n        }\n    }\n\n    public void second(Runnable printSecond) throws InterruptedException {\n        synchronized (lock) {\n            while (!firstExecuted) {\n                lock.wait(); // Wait until first() has completed\n            }\n            printSecond.run();\n            secondExecuted = true;\n            lock.notifyAll(); // Notify waiting threads that second() has completed\n        }\n    }\n\n    public void third(Runnable printThird) throws InterruptedException {\n        synchronized (lock) {\n            while (!secondExecuted) {\n                lock.wait(); // Wait until second() has completed\n            }\n            printThird.run();\n        }\n    }\n}\n"
    }
  },
  "1115": {
    "solution": {
      "concurrency": "import java.util.concurrent.Semaphore;\n\nclass FooBar {\n    private int n;\n    private Semaphore fooSemaphore;\n    private Semaphore barSemaphore;\n\n    public FooBar(int n) {\n        this.n = n;\n        this.fooSemaphore = new Semaphore(1); // Initially fooSemaphore is available\n        this.barSemaphore = new Semaphore(0); // Initially barSemaphore is not available\n    }\n\n    public void foo(Runnable printFoo) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            fooSemaphore.acquire();\n            printFoo.run();\n            barSemaphore.release();\n        }\n    }\n\n    public void bar(Runnable printBar) throws InterruptedException {\n        for (int i = 0; i < n; i++) {\n            barSemaphore.acquire();\n            printBar.run();\n            fooSemaphore.release();\n        }\n    }\n\n    public static void main(String[] args) {\n        FooBar fooBar = new FooBar(5);\n\n        Runnable printFoo = () -> System.out.print(\"foo\");\n        Runnable printBar = () -> System.out.print(\"bar\");\n\n        Thread threadFoo = new Thread(() -> {\n            try {\n                fooBar.foo(printFoo);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        Thread threadBar = new Thread(() -> {\n            try {\n                fooBar.bar(printBar);\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        });\n\n        threadFoo.start();\n        threadBar.start();\n    }\n\n}\n"
    }
  },
  "1116": {
    "solution": {
      "concurrency": "import java.util.concurrent.Semaphore;\nimport java.util.function.IntConsumer;\n\nclass ZeroEvenOdd {\n    private int n;\n    private Semaphore zeroSemaphore;\n    private Semaphore evenSemaphore;\n    private Semaphore oddSemaphore;\n\n    public ZeroEvenOdd(int n) {\n        this.n = n;\n        this.zeroSemaphore = new Semaphore(1);\n        this.evenSemaphore = new Semaphore(0);\n        this.oddSemaphore = new Semaphore(0);\n    }\n\n    public void zero(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 1; i <= n; i++) {\n            zeroSemaphore.acquire();\n            printNumber.accept(0);\n            if (i % 2 == 0) {\n                evenSemaphore.release();\n            } else {\n                oddSemaphore.release();\n            }\n        }\n    }\n\n    public void even(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 2; i <= n; i += 2) {\n            evenSemaphore.acquire();\n            printNumber.accept(i);\n            zeroSemaphore.release();\n        }\n    }\n\n    public void odd(IntConsumer printNumber) throws InterruptedException {\n        for (int i = 1; i <= n; i += 2) {\n            oddSemaphore.acquire();\n            printNumber.accept(i);\n            zeroSemaphore.release();\n        }\n    }\n}\n"
    }
  },
  "1117": {
    "solution": {
      "concurrency": "import java.util.concurrent.Semaphore;\n\nclass H2O {\n    private Semaphore hydrogenSemaphore;\n    private Semaphore oxygenSemaphore;\n    private int hydrogenCount;\n\n    public H2O() {\n        hydrogenSemaphore = new Semaphore(2); // Allow up to 2 hydrogen atoms\n        oxygenSemaphore = new Semaphore(1); // Allow up to 1 oxygen atom\n        hydrogenCount = 0;\n    }\n\n    public void hydrogen(Runnable releaseHydrogen) throws InterruptedException {\n        hydrogenSemaphore.acquire();\n        synchronized (this) {\n            hydrogenCount++;\n            releaseHydrogen.run();\n            if (hydrogenCount == 2) {\n                oxygenSemaphore.release();            }\n        }\n    }\n\n    public void oxygen(Runnable releaseOxygen) throws InterruptedException {\n        oxygenSemaphore.acquire();\n        synchronized (this) {\n            releaseOxygen.run();\n            hydrogenCount = 0;\n            hydrogenSemaphore.release(2);\n        }\n    }\n}\n"
    }
  },
  "1118": {
    "solution": {
      "math": "class Solution {\n    public int numberOfDays(int year, int month) {\n        boolean leap = (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);\n        int[] days = {0, 31, leap ? 29 : 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n        return days[month];\n    }\n}"
    }
  },
  "1119": {
    "solution": {
      "string": ""
    }
  },
  "1120": {
    "solution": {
      "binary-tree": "class Solution {\n    private double maxAvg = 0;\n\n    public double maximumAverageSubtree(TreeNode root) {\n        dfs(root);\n        return maxAvg;\n    }\n\n    private int[] dfs(TreeNode node) {\n        if (node == null) return new int[]{0, 0};\n\n        int[] left = dfs(node.left);\n        int[] right = dfs(node.right);\n\n        int sum = node.val + left[0] + right[0];\n        int count = 1 + left[1] + right[1];\n\n        maxAvg = Math.max(maxAvg, (double) sum / count);\n\n        return new int[]{sum, count};\n    }\n}"
    }
  },
  "1121": {
    "solution": {
      "counting": ""
    }
  },
  "1122": {
    "solution": {
      "counting-sort": "class Solution {\n    public int[] relativeSortArray(int[] arr1, int[] arr2) {\n        int maxNum = 1000; // assuming the values in arr1 are between 0 and 1000\n        int[] count = new int[maxNum + 1];\n        \n        for (int num : arr1) {\n            count[num]++;\n        }\n        \n        int[] result = new int[arr1.length];\n        int index = 0;\n        \n        for (int num : arr2) {\n            while (count[num] > 0) {\n                result[index++] = num;\n                count[num]--;\n            }\n        }\n        \n        for (int i = 0; i <= maxNum; i++) {\n            while (count[i] > 0) {\n                result[index++] = i;\n                count[i]--;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "1123": {
    "solution": {
      "binary-tree": "class Solution {\n    public TreeNode lcaDeepestLeaves(TreeNode root) {\n        return dfs(root).node;\n    }\n\n    private Result dfs(TreeNode node) {\n        if (node == null) return new Result(null, 0);\n\n        Result left = dfs(node.left);\n        Result right = dfs(node.right);\n\n        if (left.depth > right.depth) return new Result(left.node, left.depth + 1);\n        if (right.depth > left.depth) return new Result(right.node, right.depth + 1);\n        return new Result(node, left.depth + 1);\n    }\n\n    private static class Result {\n        TreeNode node;\n        int depth;\n        Result(TreeNode n, int d) {\n            node = n;\n            depth = d;\n        }\n    }\n}"
    }
  },
  "1124": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1125": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1126": {
    "solution": {
      "database": ""
    }
  },
  "1127": {
    "solution": {
      "database": ""
    }
  },
  "1128": {
    "solution": {
      "counting": ""
    }
  },
  "1129": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public int[] shortestAlternatingPaths(int n, int[][] redEdges, int[][] blueEdges) {\n        // Adjacency lists for red and blue edges\n        List<Integer>[] redGraph = new ArrayList[n];\n        List<Integer>[] blueGraph = new ArrayList[n];\n        for (int i = 0; i < n; i++) {\n            redGraph[i] = new ArrayList<>();\n            blueGraph[i] = new ArrayList<>();\n        }\n\n        for (int[] edge : redEdges) {\n            redGraph[edge[0]].add(edge[1]);\n        }\n        for (int[] edge : blueEdges) {\n            blueGraph[edge[0]].add(edge[1]);\n        }\n\n        int[] res = new int[n];\n        Arrays.fill(res, -1);\n\n        // Queue: node, distance, lastColorUsed (-1 for none, 0 for red, 1 for blue)\n        Queue<int[]> queue = new LinkedList<>();\n        boolean[][] visited = new boolean[n][2]; // visited[node][color]\n\n        queue.offer(new int[]{0, 0, -1});\n        visited[0][0] = true;\n        visited[0][1] = true;\n        res[0] = 0;\n\n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int node = current[0], distance = current[1], lastColor = current[2];\n\n            if (lastColor != 0) { // last was not red  try red edges\n                for (int neighbor : redGraph[node]) {\n                    if (!visited[neighbor][0]) {\n                        visited[neighbor][0] = true;\n                        queue.offer(new int[]{neighbor, distance + 1, 0});\n                        if (res[neighbor] == -1) res[neighbor] = distance + 1;\n                    }\n                }\n            }\n\n            if (lastColor != 1) { // last was not blue  try blue edges\n                for (int neighbor : blueGraph[node]) {\n                    if (!visited[neighbor][1]) {\n                        visited[neighbor][1] = true;\n                        queue.offer(new int[]{neighbor, distance + 1, 1});\n                        if (res[neighbor] == -1) res[neighbor] = distance + 1;\n                    }\n                }\n            }\n        }\n\n        return res;\n    }\n\n    public static void main(String[] args) {\n        int n = 3;\n        int[][] redEdges = {{0, 1}, {1, 2}};\n        int[][] blueEdges = {}; // no blue edges\n\n        Solution solution = new Solution();\n        int[] result = solution.shortestAlternatingPaths(n, redEdges, blueEdges);\n\n        System.out.println(\"Output: \" + Arrays.toString(result));\n    }\n}"
    }
  },
  "1130": {
    "solution": {
      "monotonic-stack": "class Solution {\n  public int mctFromLeafValues(int[] arr) {\n    int ans = 0;\n    Deque<Integer> stack = new ArrayDeque<>();\n    stack.push(Integer.MAX_VALUE);\n\n    for (int a : arr) {\n      while (stack.peek() <= a) {\n        int mid = stack.pop();\n        ans += Math.min(stack.peek(), a) * mid;\n      }\n      stack.push(a);\n    }\n\n    while (stack.size() > 2)\n      ans += stack.pop() * stack.peek();\n\n    return ans;\n  }\n}"
    }
  },
  "1131": {
    "solution": {
      "math": ""
    }
  },
  "1132": {
    "solution": {
      "database": ""
    }
  },
  "1133": {
    "solution": {
      "sorting": "class Solution {\n    public int largestUniqueNumber(int[] nums) {\n        int[] count = new int[1001];\n        for (int num : nums) {\n            count[num]++;\n        }\n        for (int i = 1000; i >= 0; i--) {\n            if (count[i] == 1) {\n                return i;\n            }\n        }\n        return -1;\n    }\n}"
    }
  },
  "1134": {
    "solution": {
      "math": "class Solution {\n    public boolean isArmstrong(int n) {\n        String s = Integer.toString(n);\n        int k = s.length();\n        int sum = 0, temp = n;\n        while (temp > 0) {\n            int digit = temp % 10;\n            sum += Math.pow(digit, k);\n            temp /= 10;\n        }\n        return sum == n;\n    }\n}"
    }
  },
  "1135": {
    "solution": {
      "minimum-spanning-tree": "class UnionFind {\n public:\n  UnionFind(int n) : parent(n), rank(n) {\n    iota(parent.begin(), parent.end(), 0);\n  }\n\n  void unionByRank(int u, int v) {\n    const int i = find(u);\n    const int j = find(v);\n    if (i == j)\n      return;\n    if (rank[i] < rank[j]) {\n      parent[i] = j;\n    } else if (rank[i] > rank[j]) {\n      parent[j] = i;\n    } else {\n      parent[i] = j;\n      ++rank[j];\n    }\n  }\n\n  int find(int u) {\n    return parent[u] == u ? u : parent[u] = find(parent[u]);\n  }\n\n private:\n  vector<int> parent;\n  vector<int> rank;\n};\n\nclass Solution {\n public:\n  int minimumCost(int n, vector<vector<int>>& connections) {\n    int ans = 0;\n    UnionFind uf(n + 1);\n\n    // Sort by cost.\n    ranges::sort(connections, ranges::less{},\n                 [](const vector<int>& connection) { return connection[2]; });\n\n    for (const vector<int>& connection : connections) {\n      const int u = connection[0];\n      const int v = connection[1];\n      const int cost = connection[2];\n      if (uf.find(u) == uf.find(v))\n        continue;\n      uf.unionByRank(u, v);\n      ans += cost;\n    }\n\n    const int root = uf.find(1);\n    for (int i = 1; i <= n; ++i)\n      if (uf.find(i) != root)\n        return -1;\n\n    return ans;\n  }\n};"
    }
  },
  "1136": {
    "solution": {
      "topological-sort": "class Solution {\n    public int minimumSemesters(int n, int[][] relations) {\n        List<Integer>[] g = new List[n];\n        Arrays.setAll(g, k -> new ArrayList<>());\n        int[] indeg = new int[n];\n        for (var r : relations) {\n            int prev = r[0] - 1, nxt = r[1] - 1;\n            g[prev].add(nxt);\n            ++indeg[nxt];\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = 0; i < n; ++i) {\n            if (indeg[i] == 0) {\n                q.offer(i);\n            }\n        }\n        int ans = 0;\n        while (!q.isEmpty()) {\n            ++ans;\n            for (int k = q.size(); k > 0; --k) {\n                int i = q.poll();\n                --n;\n                for (int j : g[i]) {\n                    if (--indeg[j] == 0) {\n                        q.offer(j);\n                    }\n                }\n            }\n        }\n        return n == 0 ? ans : -1;\n    }\n}"
    }
  },
  "1137": {
    "solution": {
      "dynamic-programming": "",
      "memoization": "public class Solution {\n    private HashMap<Integer, Integer> memo = new HashMap<>();\n\n    public int tribonacci(int n) {\n        if (n == 0)\n            return 0;\n        if (n == 1 || n == 2)\n            return 1;\n\n        if (memo.containsKey(n)) {\n            return memo.get(n);\n        }\n\n        int result = tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);\n        memo.put(n, result);\n\n        return result;\n    }\n\n}"
    }
  },
  "1138": {
    "solution": {
      "hash-table": "class Solution {\n    public String alphabetBoardPath(String target) {\n        StringBuilder ans = new StringBuilder();\n        int i = 0, j = 0;\n        for (char c : target.toCharArray()) {\n            int v = c - 'a';\n            int x = v / 5, y = v % 5;\n            while (j > y) {\n                j--;\n                ans.append('L');\n            }\n            while (i > x) {\n                i--;\n                ans.append('U');\n            }\n            while (j < y) {\n                j++;\n                ans.append('R');\n            }\n            while (i < x) {\n                i++;\n                ans.append('D');\n            }\n            ans.append('!');\n        }\n        return ans.toString();\n    }\n}"
    }
  },
  "1139": {
    "solution": {
      "matrix": "public class Solution {\n    public int largest1BorderedSquare(int[][] grid) {\n        int rows = grid.length, cols = grid[0].length;\n        int[][] horizontal = new int[rows][cols];\n        int[][] vertical = new int[rows][cols];\n\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i][j] == 1) {\n                    horizontal[i][j] = (j > 0 ? horizontal[i][j - 1] : 0) + 1;\n                    vertical[i][j] = (i > 0 ? vertical[i - 1][j] : 0) + 1;\n                }\n            }\n        }\n\n        int maxSide = 0;  \n        for (int i = rows - 1; i >= 0; i--) {\n            for (int j = cols - 1; j >= 0; j--) {\n                int possibleSide = Math.min(horizontal[i][j], vertical[i][j]);\n                \n                while (possibleSide > maxSide) {\n                    if (horizontal[i - possibleSide + 1][j] >= possibleSide &&\n                        vertical[i][j - possibleSide + 1] >= possibleSide) {\n                        maxSide = possibleSide; \n                    }\n                    possibleSide--; \n                }\n            }\n        }\n\n        return maxSide * maxSide;\n    }\n}\n"
    }
  },
  "1140": {
    "solution": {
      "breadth-first-search": "class Solution {\n    public int stoneGameII(int[] piles) {\n        int n = piles.length;\n        int[][] dp = new int[n + 1][n + 1];\n        int[] suffixSum = new int[n + 1];\n\n        for (int i = n - 1; i >= 0; i--) {\n            suffixSum[i] = suffixSum[i + 1] + piles[i];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int M = 1; M <= n; M++) {\n                for (int X = 1; X <= 2 * M && i + X <= n; X++) {\n                    dp[i][M] = Math.max(dp[i][M], suffixSum[i] - dp[i + X][Math.max(M, X)]);\n                }\n            }\n        }\n\n        return dp[0][1];\n    }\n}"
    }
  },
  "1141": {
    "solution": {
      "database": ""
    }
  },
  "1142": {
    "solution": {
      "database": ""
    }
  },
  "1143": {
    "solution": {
      "dynamic-programming": "class Solution {\n public:\n  int longestCommonSubsequence(string text1, string text2) {\n    const int m = text1.length();\n    const int n = text2.length();\n    // dp[i][j] := the length of LCS(text1[0..i), text2[0..j))\n    vector<vector<int>> dp(m + 1, vector<int>(n + 1));\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        dp[i + 1][j + 1] = text1[i] == text2[j]\n                               ? 1 + dp[i][j]\n                               : max(dp[i][j + 1], dp[i + 1][j]);\n\n    return dp[m][n];\n  }\n};"
    }
  },
  "1144": {
    "solution": {
      "greedy": "class Solution {\n    public int movesToMakeZigzag(int[] nums) {\n        int evenMoves = 0, oddMoves = 0;\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            int left = (i > 0) ? nums[i - 1] : Integer.MAX_VALUE;\n            int right = (i < n - 1) ? nums[i + 1] : Integer.MAX_VALUE;\n            int minNeighbor = Math.min(left, right);\n            int moves = Math.max(0, nums[i] - minNeighbor + 1);\n            \n            if (i % 2 == 0) {\n                evenMoves += moves;\n            } else {\n                oddMoves += moves;\n            }\n        }\n        return Math.min(evenMoves, oddMoves);\n    }\n}"
    }
  },
  "1145": {
    "solution": {
      "tree": ""
    }
  },
  "1146": {
    "solution": {
      "design": ""
    }
  },
  "1147": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1148": {
    "solution": {
      "database": ""
    }
  },
  "1149": {
    "solution": {
      "database": ""
    }
  },
  "1150": {
    "solution": {
      "array": ""
    }
  },
  "1151": {
    "solution": {
      "sliding-window": "class Solution {\n  public int minSwaps(int[] data) {\n      int sum = 0;\n      for (int v : data) {\n          sum += v;\n      }\n      int sumK = 0;\n      for (int i = 0; i < sum; ++i) {\n          sumK += data[i];\n      }\n      int max = sumK;\n      for (int i = sum; i < data.length; ++i) {\n          sumK += data[i];\n          sumK -= data[i - sum];\n          max = Math.max(max, sumK);\n      }\n      return sum - max;\n  }\n}"
    }
  },
  "1152": {
    "solution": {
      "sorting": ""
    }
  },
  "1153": {
    "solution": {
      "hash-table": ""
    }
  },
  "1154": {
    "solution": {
      "math": ""
    }
  },
  "1155": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1156": {
    "solution": {
      "sliding-window": "public class Solution {\n    public int maxRepOpt1(String text) {\n        int[] count = new int[26];\n        for (char c : text.toCharArray()) {\n            count[c - 'a']++;\n        }\n        int maxLen = 0;\n        for (int i = 0; i < text.length(); ) {\n            char currentChar = text.charAt(i);\n            int start = i;            \n            while (i < text.length() && text.charAt(i) == currentChar) {\n                i++;\n            }\n            int blockLen = i - start;            \n            int nextBlockStart = i + 1;\n            while (nextBlockStart < text.length() && text.charAt(nextBlockStart) == currentChar) {\n                nextBlockStart++;\n            }\n            int totalLen = blockLen + (nextBlockStart - i - 1);            \n            maxLen = Math.max(maxLen, Math.min(totalLen + 1, count[currentChar - 'a']));            \n            i = start + blockLen;\n        }\n\n        return maxLen;\n    }\n}\n"
    }
  },
  "1157": {
    "solution": {
      "design": ""
    }
  },
  "1158": {
    "solution": {
      "database": ""
    }
  },
  "1159": {
    "solution": {
      "database": ""
    }
  },
  "1160": {
    "solution": {
      "hash-table": ""
    }
  },
  "1161": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\nclass Solution {\n    public int maxLevelSum(TreeNode root) {\n        if (root == null) return 0;\n\n        int maxSum = Integer.MIN_VALUE;\n        int maxLevel = 0;\n        int currentLevel = 0;\n\n        Queue<TreeNode> queue = new LinkedList<>();\n        queue.offer(root);\n\n        while (!queue.isEmpty()) {\n            int levelSum = 0;\n            int levelSize = queue.size();\n            currentLevel++;\n\n            for (int i = 0; i < levelSize; i++) {\n                TreeNode node = queue.poll();\n                levelSum += node.val;\n\n                if (node.left != null) queue.offer(node.left);\n                if (node.right != null) queue.offer(node.right);\n            }\n\n            if (levelSum > maxSum) {\n                maxSum = levelSum;\n                maxLevel = currentLevel;\n            }\n        }\n\n        return maxLevel;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode(int val) { this.val = val; }\n}"
    }
  },
  "1162": {
    "solution": {
      "matrix": ""
    }
  },
  "1163": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1164": {
    "solution": {
      "database": ""
    }
  },
  "1165": {
    "solution": {
      "hash-table": ""
    }
  },
  "1166": {
    "solution": {
      "trie": ""
    }
  },
  "1167": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1168": {
    "solution": {
      "minimum-spanning-tree": "import java.util.*;\n\npublic class Solution {\n\n    static class Edge {\n        int from, to, cost;\n\n        Edge(int from, int to, int cost) {\n            this.from = from;\n            this.to = to;\n            this.cost = cost;\n        }\n    }\n\n    public int minCostToSupplyWater(int n, int[] wells, int[][] pipes) {\n        List<Edge>[] graph = new ArrayList[n + 1]; // 0 is virtual well node\n        for (int i = 0; i <= n; i++) graph[i] = new ArrayList<>();\n\n        // Connect virtual node 0 to each house with well cost\n        for (int i = 0; i < n; i++) {\n            graph[0].add(new Edge(0, i + 1, wells[i]));\n            graph[i + 1].add(new Edge(i + 1, 0, wells[i]));\n        }\n\n        // Add all pipe connections\n        for (int[] pipe : pipes) {\n            int u = pipe[0], v = pipe[1], cost = pipe[2];\n            graph[u].add(new Edge(u, v, cost));\n            graph[v].add(new Edge(v, u, cost));\n        }\n\n        // Prims Algorithm\n        boolean[] visited = new boolean[n + 1];\n        PriorityQueue<Edge> pq = new PriorityQueue<>(Comparator.comparingInt(e -> e.cost));\n        visited[0] = true;\n        pq.addAll(graph[0]);\n\n        int totalCost = 0;\n\n        while (!pq.isEmpty()) {\n            Edge edge = pq.poll();\n            if (visited[edge.to]) continue;\n\n            visited[edge.to] = true;\n            totalCost += edge.cost;\n\n            for (Edge neighbor : graph[edge.to]) {\n                if (!visited[neighbor.to]) {\n                    pq.offer(neighbor);\n                }\n            }\n        }\n\n        return totalCost;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n\n        int n = 3;\n        int[] wells = {1, 2, 2};\n        int[][] pipes = {\n                {1, 2, 1},\n                {2, 3, 1}\n        };\n\n        int result = sol.minCostToSupplyWater(n, wells, pipes);\n        System.out.println(\"Minimum cost to supply water: \" + result);\n    }\n}"
    }
  },
  "1169": {
    "solution": {
      "sorting": ""
    }
  },
  "1170": {
    "solution": {
      "sorting": ""
    }
  },
  "1171": {
    "solution": {
      "linked-list": ""
    }
  },
  "1172": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1173": {
    "solution": {
      "database": ""
    }
  },
  "1174": {
    "solution": {
      "database": ""
    }
  },
  "1175": {
    "solution": {
      "math": ""
    }
  },
  "1176": {
    "solution": {
      "sliding-window": "class Solution {\n    public int dietPlanPerformance(int[] calories, int k, int lower, int upper) {\n        int n = calories.length;\n        int[] s = new int[n + 1];\n        for (int i = 0; i < n; ++i) {\n            s[i + 1] = s[i] + calories[i];\n        }\n        int ans = 0;\n        for (int i = 0; i < n - k + 1; ++i) {\n            int t = s[i + k] - s[i];\n            if (t < lower) {\n                --ans;\n            } else if (t > upper) {\n                ++ans;\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "1177": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1178": {
    "solution": {
      "trie": ""
    }
  },
  "1179": {
    "solution": {
      "database": ""
    }
  },
  "1180": {
    "solution": {
      "math": ""
    }
  },
  "1181": {
    "solution": {
      "sorting": ""
    }
  },
  "1182": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1183": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int maximumNumberOfOnes(int width, int height, int sideLength, int maxOnes) {\n        int x = sideLength;\n        int[] count = new int[x * x];\n        for (int i = 0; i < width; ++i) {\n            for (int j = 0; j < height; ++j) {\n                int k = (i % x) * x + (j % x);\n                count[k]++;\n            }\n        }\n        Arrays.sort(count);\n        int ans = 0;\n        for (int i = count.length - 1; i >= count.length - maxOnes; --i) {\n            ans += count[i];\n        }\n        return ans;\n    }\n}"
    }
  },
  "1184": {
    "solution": {
      "array": ""
    }
  },
  "1185": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public String dayOfTheWeek(int day, int month, int year) {\n        if (month < 3) {\n            month += 12;\n            year -= 1;\n        }\n        int k = year % 100;\n        int j = year / 100;\n        int dayOfWeek = (day + (13 * (month + 1)) / 5 + k + k / 4 + j / 4 + 5 * j) % 7;\n        String[] days = {\"Saturday\", \"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\"};\n        return days[dayOfWeek];\n    }\n}"
    }
  },
  "1186": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1187": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1188": {
    "solution": {
      "concurrency": "class BoundedBlockingQueue {\n    private Semaphore s1;\n    private Semaphore s2;\n    private Deque<Integer> q = new ArrayDeque<>();\n\n    public BoundedBlockingQueue(int capacity) {\n        s1 = new Semaphore(capacity);\n        s2 = new Semaphore(0);\n    }\n\n    public void enqueue(int element) throws InterruptedException {\n        s1.acquire();\n        q.offer(element);\n        s2.release();\n    }\n\n    public int dequeue() throws InterruptedException {\n        s2.acquire();\n        int ans = q.poll();\n        s1.release();\n        return ans;\n    }\n\n    public int size() {\n        return q.size();\n    }\n}"
    }
  },
  "1189": {
    "solution": {
      "counting": ""
    }
  },
  "1190": {
    "solution": {
      "stack": "class Solution {\n    public String reverseParentheses(String s) {\n        Stack<Integer> stack = new Stack<>();\n        StringBuilder sb = new StringBuilder();\n        \n        for (int i = 0; i < s.length(); i++) {\n            char c = s.charAt(i);\n            if (c == '(') {\n                stack.push(sb.length());\n            } else if (c == ')') {\n                int start = stack.pop();\n                int end = sb.length() - 1;\n                reverse(sb, start, end);\n            } else {\n                sb.append(c);\n            }\n        }\n        \n        return sb.toString();\n    }\n    \n    private void reverse(StringBuilder sb, int start, int end) {\n        while (start < end) {\n            char temp = sb.charAt(start);\n            sb.setCharAt(start++, sb.charAt(end));\n            sb.setCharAt(end--, temp);\n        }\n    }\n}\n"
    }
  },
  "1191": {
    "solution": {
      "dynamic-programming": "class Solution {\n    private static final int MOD = 1_000_000_007;\n\n    public int kConcatenationMaxSum(int[] arr, int k) {\n        int n = arr.length;\n        long arrSum = 0;\n        for (int num : arr) arrSum += num;\n\n        long maxKadane = kadane(arr, k == 1 ? n : 2 * n);\n\n        if (arrSum > 0 && k > 2) {\n            maxKadane = maxKadane + arrSum * (k - 2);\n        }\n\n        return (int)(maxKadane % MOD);\n    }\n\n    private long kadane(int[] arr, int length) {\n        long maxEndingHere = 0, maxSoFar = 0;\n        for (int i = 0; i < length; i++) {\n            int val = arr[i % arr.length];\n            maxEndingHere = Math.max(val, maxEndingHere + val);\n            maxSoFar = Math.max(maxSoFar, maxEndingHere);\n        }\n        return maxSoFar;\n    }\n}"
    }
  },
  "1192": {
    "solution": {
      "biconnected-component": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}",
      "graph": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}",
      "depth-first-search": "import java.util.*;\n\nclass Solution {\n    List<List<Integer>> graph;\n    int[] low;\n    int[] disc;\n    int time;\n    List<List<Integer>> result;\n    \n    public List<List<Integer>> criticalConnections(int n, List<List<Integer>> connections) {\n        graph = new ArrayList<>();\n        low = new int[n];\n        disc = new int[n];\n        result = new ArrayList<>();\n        time = 0;\n        \n        for (int i = 0; i < n; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        for (List<Integer> conn : connections) {\n            int u = conn.get(0);\n            int v = conn.get(1);\n            graph.get(u).add(v);\n            graph.get(v).add(u);\n        }\n        \n        dfs(0, -1);\n        \n        return result;\n    }\n    \n    private void dfs(int u, int parent) {\n        low[u] = disc[u] = ++time;\n        \n        for (int v : graph.get(u)) {\n            if (v == parent) continue;\n            \n            if (disc[v] == 0) { // If v is not visited\n                dfs(v, u);\n                low[u] = Math.min(low[u], low[v]);\n                if (low[v] > disc[u]) {\n                    // (u, v) is a critical connection\n                    result.add(Arrays.asList(u, v));\n                }\n            } else {\n                low[u] = Math.min(low[u], disc[v]);\n            }\n        }\n    }\n}"
    }
  },
  "1193": {
    "solution": {
      "database": ""
    }
  },
  "1194": {
    "solution": {
      "database": "# Write your MySQL query statement below\nWITH\n    s AS (\n        SELECT first_player AS player_id, first_score AS score, group_id\n        FROM\n            Matches AS m\n            JOIN Players AS p ON m.first_player = p.player_id\n        UNION ALL\n        SELECT second_player AS player_id, second_score AS score, group_id\n        FROM\n            Matches AS m\n            JOIN Players AS p ON m.second_player = p.player_id\n    ),\n    t AS (\n        SELECT group_id, player_id, SUM(score) AS scores\n        FROM s\n        GROUP BY player_id\n    ),\n    p AS (\n        SELECT\n            group_id,\n            player_id,\n            RANK() OVER (\n                PARTITION BY group_id\n                ORDER BY scores DESC, player_id\n            ) AS rk\n        FROM t\n    )\nSELECT group_id, player_id\nFROM p\nWHERE rk = 1;"
    }
  },
  "1195": {
    "solution": {
      "concurrency": "import java.util.function.IntConsumer;\n\npublic class FizzBuzz {\n    private int n;\n    private int current = 1;\n\n    public FizzBuzz(int n) {\n        this.n = n;\n    }\n\n    public synchronized void fizz(Runnable printFizz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 != 0 || current % 5 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printFizz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void buzz(Runnable printBuzz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 5 != 0 || current % 3 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printBuzz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void fizzbuzz(Runnable printFizzBuzz) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 != 0 || current % 5 != 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printFizzBuzz.run();\n                current++;\n                notifyAll();\n            }\n        }\n    }\n\n    public synchronized void number(IntConsumer printNumber) throws InterruptedException {\n        while (current <= n) {\n            while (current <= n && (current % 3 == 0 || current % 5 == 0)) {\n                wait();\n            }\n            if (current <= n) {\n                printNumber.accept(current);\n                current++;\n                notifyAll();\n            }\n        }\n    }\n}\n"
    }
  },
  "1196": {
    "solution": {
      "sorting": "import java.util.Arrays;\n\nclass Solution {\n    public int maxNumberOfApples(int[] weight) {\n        Arrays.sort(weight);\n        int sum = 0;\n        for (int i = 0; i < weight.length; i++) {\n            sum += weight[i];\n            if (sum > 5000) {\n                return i;\n            }\n        }\n        return weight.length;\n    }\n}"
    }
  },
  "1197": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "1198": {
    "solution": {
      "matrix": ""
    }
  },
  "1199": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1200": {
    "solution": {
      "shortest-path": "class Solution {\n public:\n  vector<vector<int>> minimumAbsDifference(vector<int>& arr) {\n    vector<vector<int>> ans;\n    int mn = INT_MAX;\n\n    ranges::sort(arr);\n\n    for (int i = 1; i < arr.size(); ++i) {\n      const int diff = arr[i] - arr[i - 1];\n      if (diff < mn) {\n        mn = diff;\n        ans.clear();\n      }\n      if (diff == mn)\n        ans.push_back({arr[i - 1], arr[i]});\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "1201": {
    "solution": {
      "binary-search": "class Solution {\n    public int nthUglyNumber(int n, int a, int b, int c) {\n        long ab = lcm(a, b);\n        long bc = lcm(b, c);\n        long ac = lcm(a, c);\n        long abc = lcm(ab, c);\n        long left = 1, right = 2_000_000_000L;\n        while (left < right) {\n            long mid = left + (right - left) / 2;\n            if (countUgly(mid, a, b, c, ab, bc, ac, abc) >= n) {\n                right = mid;\n            } else {\n                left = mid + 1;\n            }\n        }\n        return (int) left;\n    }\n\n    private long countUgly(long x, long a, long b, long c, long ab, long bc, long ac, long abc) {\n        return x / a + x / b + x / c - x / ab - x / bc - x / ac + x / abc;\n    }\n\n    private long gcd(long x, long y) {\n        while (y != 0) {\n            long temp = y;\n            y = x % y;\n            x = temp;\n        }\n        return x;\n    }\n\n    private long lcm(long x, long y) {\n        return x / gcd(x, y) * y;\n    }\n}"
    }
  },
  "1202": {
    "solution": {
      "union-find": ""
    }
  },
  "1203": {
    "solution": {
      "topological-sort": ""
    }
  },
  "1204": {
    "solution": {
      "database": ""
    }
  },
  "1205": {
    "solution": {
      "database": ""
    }
  },
  "1206": {
    "solution": {
      "linked-list": ""
    }
  },
  "1207": {
    "solution": {
      "hash-table": "import java.util.HashMap;\nimport java.util.HashSet;\n\nclass Solution {\n    public boolean uniqueOccurrences(int[] arr) {\n        HashMap<Integer, Integer> frequencyMap = new HashMap<>();\n        for (int num : arr) {\n            frequencyMap.put(num, frequencyMap.getOrDefault(num, 0) + 1);\n        }\n\n        HashSet<Integer> occurrencesSet = new HashSet<>();\n        for (int count : frequencyMap.values()) {\n            if (occurrencesSet.contains(count)) {\n                return false;\n            }\n            occurrencesSet.add(count);\n        }\n        return true;\n    }\n}"
    }
  },
  "1208": {
    "solution": {
      "sliding-window": "class Solution {\n    public int equalSubstring(String s, String t, int maxCost) {\n        int n = s.length();\n        int[] cost = new int[n];\n        \n        for (int i = 0; i < n; i++) {\n            cost[i] = Math.abs(s.charAt(i) - t.charAt(i));\n        }\n        \n        int left = 0, right = 0;\n        int currentCost = 0;\n        int maxLength = 0;\n        \n        while (right < n) {\n            currentCost += cost[right];\n            \n            while (currentCost > maxCost) {\n                currentCost -= cost[left];\n                left++;\n            }\n            \n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        }\n        \n        return maxLength;\n    }\n}\n"
    }
  },
  "1209": {
    "solution": {
      "stack": "class Solution {\n    public String removeDuplicates(String s, int k) {\n        Stack<Pair<Character, Integer>> stack = new Stack<>();\n\n        for (char c : s.toCharArray()) {\n            if (!stack.isEmpty() && stack.peek().getKey() == c) {\n                Pair<Character, Integer> top = stack.pop();\n                if (top.getValue() + 1 < k) {\n                    stack.push(new Pair<>(c, top.getValue() + 1));\n                }\n            } else {\n                stack.push(new Pair<>(c, 1));\n            }\n        }\n\n        StringBuilder sb = new StringBuilder();\n        while (!stack.isEmpty()) {\n            Pair<Character, Integer> pair = stack.pop();\n            for (int i = 0; i < pair.getValue(); i++) {\n                sb.append(pair.getKey());\n            }\n        }\n\n        return sb.reverse().toString();\n    }\n}\n"
    }
  },
  "1210": {
    "solution": {
      "matrix": ""
    }
  },
  "1211": {
    "solution": {
      "database": ""
    }
  },
  "1212": {
    "solution": {
      "database": ""
    }
  },
  "1213": {
    "solution": {
      "counting": "import java.util.ArrayList;\nimport java.util.List;\n\nclass Solution {\n    public List<Integer> arraysIntersection(int[] arr1, int[] arr2, int[] arr3) {\n        int[] cnt = new int[2001];\n        for (int x : arr1) {\n            cnt[x]++;\n        }\n        for (int x : arr2) {\n            cnt[x]++;\n        }\n        List<Integer> ans = new ArrayList<>();\n        for (int x : arr3) {\n            cnt[x]++;\n            if (cnt[x] == 3) {\n                ans.add(x);\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "1214": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1215": {
    "solution": {
      "backtracking": ""
    }
  },
  "1216": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public boolean isValidPalindrome(String s, int k) {\n        int n = s.length();\n\n        // dp[i][j] will store the length of the longest palindromic subsequence in s[i..j]\n        int[][] dp = new int[n][n];\n\n        // Every single character is a palindrome of length 1\n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = 1;\n        }\n\n        // Build the dp table\n        for (int len = 2; len <= n; ++len) {\n            for (int i = 0; i <= n - len; ++i) {\n                int j = i + len - 1;\n\n                // If characters match, extend the palindrome length by 2\n                if (s.charAt(i) == s.charAt(j)) {\n                    dp[i][j] = dp[i + 1][j - 1] + 2;\n                } else {\n                    // Else take the maximum length from removing either character\n                    dp[i][j] = Math.max(dp[i + 1][j], dp[i][j - 1]);\n                }\n\n                // If the palindromic subsequence is large enough to form a valid palindrome\n                if (dp[i][j] + k >= n) {\n                    return true;\n                }\n            }\n        }\n\n        return false;\n    }\n}"
    }
  },
  "1217": {
    "solution": {
      "greedy": ""
    }
  },
  "1218": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1219": {
    "solution": {
      "matrix": ""
    }
  },
  "1220": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1221": {
    "solution": {
      "counting": ""
    }
  },
  "1222": {
    "solution": {
      "matrix": ""
    }
  },
  "1223": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1224": {
    "solution": {
      "hash-table": "import java.util.HashMap;\n\nclass Solution {\n    public int maxEqualFreq(int[] nums) {\n        int ans = 0;\n        int maxFreq = 0;\n        HashMap<Integer, Integer> count = new HashMap<>();\n        HashMap<Integer, Integer> freq = new HashMap<>();\n\n        for (int i = 0; i < nums.length; i++) {\n            int num = nums[i];\n            int c = count.getOrDefault(num, 0);\n            freq.put(c, freq.getOrDefault(c, 0) - 1);\n            if (freq.get(c) == 0) freq.remove(c);\n            count.put(num, c + 1);\n            freq.put(c + 1, freq.getOrDefault(c + 1, 0) + 1);\n\n            maxFreq = Math.max(maxFreq, c + 1);\n\n            if (maxFreq == 1 ||\n                maxFreq * freq.get(maxFreq) == i + 1 ||\n                (maxFreq - 1) * (freq.getOrDefault(maxFreq - 1, 0) + 1) == i + 1) {\n                ans = i + 1;\n            }\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "1225": {
    "solution": {
      "database": ""
    }
  },
  "1226": {
    "solution": {
      "concurrency": "import java.util.concurrent.TimeUnit;\nimport java.util.concurrent.locks.Lock;\nimport java.util.concurrent.locks.ReentrantLock;\n\npublic class DiningPhilosophers {\n\n    private Lock leftForkLock = new ReentrantLock();\n    private Lock rightForkLock = new ReentrantLock();\n\n    public DiningPhilosophers() {\n\n    }\n\n    // call the run() method of any runnable to execute its code\n    public void wantsToEat(int philosopher,\n            Runnable pickLeftFork,\n            Runnable pickRightFork,\n            Runnable eat,\n            Runnable putLeftFork,\n            Runnable putRightFork) throws InterruptedException {\n\n        while (true) {\n            if (leftForkLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n                try {\n                    pickLeftFork.run();\n                    if (rightForkLock.tryLock(100, TimeUnit.MILLISECONDS)) {\n                        try {\n                            pickRightFork.run();\n                            eat.run();\n                            putRightFork.run();\n                            return;\n                        } finally {\n                            rightForkLock.unlock();\n                        }\n                    }\n\n                } finally {\n                    putLeftFork.run();\n                    leftForkLock.unlock();\n                }\n            }\n        }\n    }\n}"
    }
  },
  "1227": {
    "solution": {
      "probability-and-statistics": "class Solution {\n  public double nthPersonGetsNthSeat(int n) {\n    return n == 1 ? 1 : 0.5;\n  }\n}"
    }
  },
  "1228": {
    "solution": {
      "math": "import java.util.Arrays;\n\nclass Solution {\n    public int missingNumber(int[] arr) {\n        int n = arr.length;\n        int x = (arr[0] + arr[n - 1]) * (n + 1) / 2;\n        int y = Arrays.stream(arr).sum();\n        return x - y;\n    }\n}"
    }
  },
  "1229": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1230": {
    "solution": {
      "probability-and-statistics": "class Solution {\n    public double probabilityOfHeads(double[] prob, int target) {\n        int n = prob.length;\n        double[][] dp = new double[n + 1][target + 1];\n        dp[0][0] = 1;\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 0; j <= Math.min(i, target); ++j) {\n                dp[i][j] = (1 - prob[i - 1]) * dp[i - 1][j];\n                if (j > 0) {\n                    dp[i][j] += prob[i - 1] * dp[i - 1][j - 1];\n                }\n            }\n        }\n        return dp[n][target];\n    }\n}"
    }
  },
  "1231": {
    "solution": {
      "array": ""
    }
  },
  "1232": {
    "solution": {
      "geometry": "class Solution {\n    public boolean checkStraightLine(int[][] coordinates) {\n        int n = coordinates.length;\n        if (n < 2) return false; // At least two points needed\n\n        int x1 = coordinates[0][0], y1 = coordinates[0][1];\n        int x2 = coordinates[1][0], y2 = coordinates[1][1];\n\n        for (int i = 2; i < n; i++) {\n            int x3 = coordinates[i][0], y3 = coordinates[i][1];\n            if ((y2 - y1) * (x3 - x2) != (y3 - y2) * (x2 - x1)) {\n                return false;\n            }\n        }\n        return true;\n    }\n}"
    }
  },
  "1233": {
    "solution": {
      "trie": ""
    }
  },
  "1234": {
    "solution": {
      "sliding-window": "class Solution {\n  public int balancedString(String s) {\n  int n = s.length();\n  int k = n / 4;\n    int ans = n;\n    int[] count = new int[128];\n\n    for (final char c : s.toCharArray())\n      ++count[c];\n\n    for (int i = 0, j = 0; i < n; ++i) {\n      --count[s.charAt(i)];\n      while (j < n && count['Q'] <= k && count['W'] <= k && count['E'] <= k && count['R'] <= k) {\n        ans = Math.min(ans, i - j + 1);\n        ++count[s.charAt(j)];\n        ++j;\n      }\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "1235": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1236": {
    "solution": {
      "breadth-first-search": "import java.util.*;\n\ninterface HtmlParser {\n    List<String> getUrls(String url);\n}\n\nclass Solution {\n    private List<String> ans = new ArrayList<>();\n    private Set<String> visited = new HashSet<>();\n    private String hostName;\n\n    public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n        hostName = getHostName(startUrl);\n        dfs(startUrl, htmlParser);\n        return ans;\n    }\n\n    private void dfs(String url, HtmlParser htmlParser) {\n        if (visited.contains(url)) return;\n        visited.add(url);\n        ans.add(url);\n        for (String next : htmlParser.getUrls(url)) {\n            if (getHostName(next).equals(hostName)) {\n                dfs(next, htmlParser);\n            }\n        }\n    }\n\n    private String getHostName(String url) {\n        int start = url.indexOf(\"//\") + 2;\n        int end = url.indexOf('/', start);\n        if (end == -1) {\n            end = url.length();\n        }\n        return url.substring(start, end);\n    }\n}"
    }
  },
  "1237": {
    "solution": {
      "two-pointers": "",
      "interactive": "import java.util.*;\n\n/*\n * // This is the custom function interface.\n * // You should not implement it, or speculate about its implementation\n * interface CustomFunction {\n *     // Returns f(x, y) for any given positive integers x and y.\n *     // Note that f(x, y) is increasing with respect to both x and y.\n *     // i.e. f(x, y) < f(x + 1, y), f(x, y) < f(x, y + 1)\n *     int f(int x, int y);\n * }\n */\n\nclass Solution {\n    public List<List<Integer>> findSolution(CustomFunction customfunction, int z) {\n        List<List<Integer>> result = new ArrayList<>();\n        int x = 1, y = 1000; // Start with x=1 and maximum y\n\n        while (x <= 1000 && y > 0) {\n            int val = customfunction.f(x, y);\n            if (val == z) {\n                result.add(Arrays.asList(x, y));\n                x++;\n                y--;\n            } else if (val < z) {\n                x++;\n            } else {\n                y--;\n            }\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "1238": {
    "solution": {
      "backtracking": ""
    }
  },
  "1239": {
    "solution": {
      "backtracking": ""
    }
  },
  "1240": {
    "solution": {
      "backtracking": ""
    }
  },
  "1241": {
    "solution": {
      "database": ""
    }
  },
  "1242": {
    "solution": {
      "concurrency": "import java.net.URI;\nimport java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentSkipListSet;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic class Web_Crawler_Multithreaded {\n\n    class Solution_1_synchronizedList {\n        private final Set<String> set = Collections.newSetFromMap(new ConcurrentHashMap<String, Boolean>());\n        private final List<String> result = Collections.synchronizedList(new ArrayList<String>());\n        private String HOSTNAME = null;\n\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            initHostName(startUrl);\n            set.add(startUrl);\n            getUrlDfs(startUrl, htmlParser);\n            return result;\n        }\n\n        private boolean judgeHostname(String url) {\n            int idx = url.indexOf('/', 7);\n            String hostName = (idx != -1) ? url.substring(0, idx) : url;\n            return hostName.equals(HOSTNAME);\n        }\n\n        private void initHostName(String url) {\n            int idx = url.indexOf('/', 7);\n            HOSTNAME = (idx != -1) ? url.substring(0, idx) : url;\n        }\n\n        private void getUrlDfs(String startUrl, HtmlParser htmlParser) {\n            result.add(startUrl);\n            List<String> res = htmlParser.getUrls(startUrl);\n            List<Thread> threads = new ArrayList<>();\n            for (String url : res) {\n                if (judgeHostname(url) && !set.contains(url)) {\n                    set.add(url);\n                    threads.add(new Thread(() -> {\n                        getUrlDfs(url, htmlParser);\n                    }));\n                }\n            }\n            for (Thread thread : threads) {\n                thread.start();\n            }\n            try {\n                for (Thread thread : threads) {\n                    thread.join(); \n                }\n            } catch (InterruptedException e) {\n                e.printStackTrace();\n            }\n        }\n\n    }\n\n    class Solution_2_ConcurrentSkipListSet {\n\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            Set<String> visited = new ConcurrentSkipListSet<>();\n            String hostname = getHostname(startUrl);\n            visited.add(startUrl);\n\n            return crawlDfs(startUrl, htmlParser, hostname, visited).collect(Collectors.toList());\n        }\n\n        private Stream<String> crawlDfs(String startUrl, HtmlParser htmlParser, String hostname,\n                                     Set<String> visited) {\n            try (Stream<String> stream = htmlParser.getUrls(startUrl)\n                .parallelStream()\n                .filter(url -> isSameHostname(url, hostname))\n                .filter(visited::add)\n                .flatMap(url -> crawlDfs(url, htmlParser, hostname, visited))) {\n\n                return Stream.concat(Stream.of(startUrl), stream);\n            }\n        }\n\n        private String getHostname(String url) {\n            int idx = url.indexOf('/', 7);\n            return (idx != -1) ? url.substring(0, idx) : url;\n        }\n\n        private boolean isSameHostname(String url, String hostname) {\n            return url.startsWith(hostname) && (url.length() == hostname.length()\n                || url.charAt(hostname.length()) == '/');\n        }\n    }\n\n    interface HtmlParser {\n        List<String> getUrls(String str);\n    }\n\n\n    class Solution_CrawlerClass {\n        public List<String> crawl(String startUrl, HtmlParser htmlParser) {\n            String host = URI.create(startUrl).getHost();\n            Crawler crawler = new Crawler(startUrl, host, htmlParser);\n            crawler.res = new ArrayList<>();\n            crawler.start();\n            Crawler.joinThread(crawler);\n            return crawler.res;\n        }\n    }\n\n    static class Crawler extends Thread {\n        String startUrl;\n        String hostname;\n        HtmlParser htmlParser;\n        public volatile List<String> res = new ArrayList<>();\n\n        public Crawler(String startUrl, String hostname, HtmlParser htmlParser) {\n            this.startUrl = startUrl;\n            this.hostname = hostname;\n            this.htmlParser = htmlParser;\n        }\n\n        @Override\n        public void run() {\n            String host = URI.create(startUrl).getHost();\n            if (!host.equals(hostname) || res.contains(startUrl)) {\n                return;\n            }\n            res.add(startUrl);\n            List<Thread> threads = new ArrayList<>();\n            for (String s : htmlParser.getUrls(startUrl)) {\n                Crawler crawler = new Crawler(s, hostname, htmlParser);\n                crawler.start();\n                threads.add(crawler);\n            }\n            for (Thread t : threads) {\n                joinThread(t);\n            }\n        }\n\n        public static void joinThread(Thread thread) {\n            try {\n                thread.join();\n            } catch (InterruptedException e) {\n            }\n        }\n\n    }\n}"
    }
  },
  "1243": {
    "solution": {
      "array": ""
    }
  },
  "1244": {
    "solution": {
      "design": ""
    }
  },
  "1245": {
    "solution": {
      "tree": "import java.util.*;\n\nclass Solution {\n    private Map<Integer, Set<Integer>> adjacencyList = new HashMap<>();\n    private boolean[] visited;\n    private int maxDistance = 0;\n    private int farthestNode = 0;\n\n    public int treeDiameter(int[][] edges) {\n        for (int[] edge : edges) {\n            adjacencyList.computeIfAbsent(edge[0], k -> new HashSet<>()).add(edge[1]);\n            adjacencyList.computeIfAbsent(edge[1], k -> new HashSet<>()).add(edge[0]);\n        }\n\n        int n = edges.length + 1;\n        visited = new boolean[n];\n        farthestNode = edges[0][0];\n        dfs(farthestNode, 0);\n\n        visited = new boolean[n];\n        maxDistance = 0;\n        dfs(farthestNode, 0);\n\n        return maxDistance;\n    }\n\n    private void dfs(int currentNode, int distance) {\n        if (visited[currentNode]) return;\n        visited[currentNode] = true;\n\n        if (distance > maxDistance) {\n            maxDistance = distance;\n            farthestNode = currentNode;\n        }\n\n        for (int neighbor : adjacencyList.getOrDefault(currentNode, new HashSet<>())) {\n            dfs(neighbor, distance + 1);\n        }\n    }\n}"
    }
  },
  "1246": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int minimumMoves(int[] arr) {\n        int n = arr.length;\n        int[][] dp = new int[n][n];\n        \n        for (int i = 0; i < n; ++i) {\n            dp[i][i] = 1;\n        }\n        \n        for (int i = n - 2; i >= 0; --i) {\n            for (int j = i + 1; j < n; ++j) {\n                if (i + 1 == j) {\n                    dp[i][j] = arr[i] == arr[j] ? 1 : 2;\n                } else {\n                    int t = arr[i] == arr[j] ? dp[i + 1][j - 1] : Integer.MAX_VALUE;\n                    \n                    for (int k = i; k < j; ++k) {\n                        t = Math.min(t, dp[i][k] + dp[k + 1][j]);\n                    }\n                    \n                    dp[i][j] = t;\n                }\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n}"
    }
  },
  "1247": {
    "solution": {
      "greedy": ""
    }
  },
  "1248": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numberOfSubarrays(int[] nums, int k) {\n        return atMost(nums, k) - atMost(nums, k - 1);\n    }\n    \n    private int atMost(int[] nums, int k) {\n        int res = 0;\n        int left = 0;\n        int count = 0;\n        \n        for (int right = 0; right < nums.length; ++right) {\n            if (nums[right] % 2 == 1) {\n                --k;\n            }\n            \n            while (k < 0) {\n                if (nums[left] % 2 == 1) {\n                    ++k;\n                }\n                ++left;\n            }\n            \n            res += right - left + 1;\n        }\n        \n        return res;\n    }\n}"
    }
  },
  "1249": {
    "solution": {
      "stack": "class Solution {\n    public String minRemoveToMakeValid(String s) {\n        Stack<Integer> stack = new Stack<>();\n        char[] chars = s.toCharArray();\n        \n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == '(') {\n                stack.push(i); \n            } else if (chars[i] == ')') {\n                if (!stack.isEmpty()) {\n                    stack.pop();\n                } else {\n                    chars[i] = '*'; \n                }\n            }\n        }\n        \n        while (!stack.isEmpty()) {\n            chars[stack.pop()] = '*';\n        }\n        \n        StringBuilder result = new StringBuilder();\n        for (char c : chars) {\n            if (c != '*') {\n                result.append(c);\n            }\n        }\n        \n        return result.toString();\n    }\n}\n"
    }
  },
  "1250": {
    "solution": {
      "number-theory": "import java.util.*;\n\nclass Solution {\n    public boolean isGoodArray(int[] nums) {\n        int result = nums[0];\n        for (int i = 1; i < nums.length; ++i) {\n            result = gcd(result, nums[i]);\n            if (result == 1) {\n                return true;\n            }\n        }\n        return result == 1;\n    }\n\n    private int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n}"
    }
  },
  "1251": {
    "solution": {
      "database": ""
    }
  },
  "1252": {
    "solution": {
      "math": ""
    }
  },
  "1253": {
    "solution": {
      "matrix": ""
    }
  },
  "1254": {
    "solution": {
      "union-find": "",
      "matrix": "class Solution {\n    public int closedIsland(int[][] grid) {\n        int m = grid.length;\n        int n = grid[0].length;\n        int closedIslands = 0;\n\n        // Mark all `0`s connected to the boundary as `1`s\n        for (int i = 0; i < m; i++) {\n            if (grid[i][0] == 0) dfs(grid, i, 0);\n            if (grid[i][n - 1] == 0) dfs(grid, i, n - 1);\n        }\n        for (int j = 0; j < n; j++) {\n            if (grid[0][j] == 0) dfs(grid, 0, j);\n            if (grid[m - 1][j] == 0) dfs(grid, m - 1, j);\n        }\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid[i][j] == 0) {\n                    dfs(grid, i, j);\n                    closedIslands++;\n                }\n            }\n        }\n\n        return closedIslands;\n    }\n\n    private void dfs(int[][] grid, int i, int j) {\n        if (i < 0 || i >= grid.length || j < 0 || j >= grid[0].length || grid[i][j] == 1) {\n            return;\n        }\n\n        grid[i][j] = 1; \n        dfs(grid, i + 1, j);\n        dfs(grid, i - 1, j);\n        dfs(grid, i, j + 1);\n        dfs(grid, i, j - 1);\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid = {\n            {1, 1, 1, 1, 0, 1},\n            {1, 0, 1, 0, 1, 1},\n            {1, 0, 1, 0, 0, 1},\n            {1, 1, 1, 1, 1, 1}\n        };\n\n        int result = solution.closedIsland(grid);\n        System.out.println(\"Number of Closed Islands: \" + result); // Output: 1\n    }\n}\n"
    }
  },
  "1255": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1256": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1257": {
    "solution": {
      "tree": ""
    }
  },
  "1258": {
    "solution": {
      "union-find": ""
    }
  },
  "1259": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1260": {
    "solution": {
      "matrix": ""
    }
  },
  "1261": {
    "solution": {
      "tree": ""
    }
  },
  "1262": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1263": {
    "solution": {
      "matrix": ""
    }
  },
  "1264": {
    "solution": {
      "database": ""
    }
  },
  "1265": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1266": {
    "solution": {
      "geometry": "class Solution {\n    public int minTimeToVisitAllPoints(int[][] points) {\n        int time = 0;\n        for (int i = 1; i < points.length; i++) {\n            int dx = Math.abs(points[i][0] - points[i - 1][0]);\n            int dy = Math.abs(points[i][1] - points[i - 1][1]);\n            time += Math.max(dx, dy);\n        }\n        return time;\n    }\n}"
    }
  },
  "1267": {
    "solution": {
      "union-find": ""
    }
  },
  "1268": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1269": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int numWays(int steps, int arrLen) {\n        int MOD = 1_000_000_007;\n        int maxPos = Math.min(steps, arrLen - 1);\n        int[][] dp = new int[steps + 1][maxPos + 1];\n\n        dp[0][0] = 1;\n\n        for (int i = 1; i <= steps; i++) {\n            for (int j = 0; j <= maxPos; j++) {\n                dp[i][j] = dp[i - 1][j];\n                if (j > 0) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j - 1]) % MOD;\n                }\n                if (j < maxPos) {\n                    dp[i][j] = (dp[i][j] + dp[i - 1][j + 1]) % MOD;\n                }\n            }\n        }\n\n        return dp[steps][0];\n    }\n}"
    }
  },
  "1270": {
    "solution": {
      "database": ""
    }
  },
  "1271": {
    "solution": {
      "math": ""
    }
  },
  "1272": {
    "solution": {
      "array": ""
    }
  },
  "1273": {
    "solution": {
      "tree": ""
    }
  },
  "1274": {
    "solution": {
      "interactive": ""
    }
  },
  "1275": {
    "solution": {
      "matrix": "class Solution {\n    public String tictactoe(int[][] moves) {\n        int[][] board = new int[3][3];\n\n        for (int i = 0; i < moves.length; i++) {\n            int player = (i % 2 == 0) ? 1 : -1;\n            int row = moves[i][0];\n            int col = moves[i][1];\n            board[row][col] = player;\n        }\n\n        if (checkForWin(board, 1)) {\n            return \"A\";\n        } else if (checkForWin(board, -1)) {\n            return \"B\";\n        } else if (moves.length == 9) {\n            return \"Draw\";\n        } else {\n            return \"Pending\";\n        }\n    }\n\n    private boolean checkForWin(int[][] board, int player) {\n        for (int i = 0; i < 3; i++) {\n            if (board[i][0] == player && board[i][1] == player && board[i][2] == player) {\n                return true;\n            }\n            if (board[0][i] == player && board[1][i] == player && board[2][i] == player) {\n                return true;\n            }\n        }\n\n        if (board[0][0] == player && board[1][1] == player && board[2][2] == player) {\n            return true;\n        }\n        if (board[0][2] == player && board[1][1] == player && board[2][0] == player) {\n            return true;\n        }\n\n        return false;\n    }\n\n}"
    }
  },
  "1276": {
    "solution": {
      "math": "import java.util.*;\n\nclass Solution {\n    public List<Integer> numOfBurgers(int tomatoSlices, int cheeseSlices) {\n        if (tomatoSlices % 2 != 0 || tomatoSlices < 2 * cheeseSlices || tomatoSlices > 4 * cheeseSlices) {\n            return new ArrayList<>();\n        }\n\n        int jumbo = (tomatoSlices - 2 * cheeseSlices) / 2;\n        int small = cheeseSlices - jumbo;\n\n        return Arrays.asList(jumbo, small);\n    }\n}"
    }
  },
  "1277": {
    "solution": {
      "matrix": "class Solution {\n  public int countSquares(int[][] matrix) {\n    for (int i = 0; i < matrix.length; ++i)\n      for (int j = 0; j < matrix[0].length; ++j)\n        if (matrix[i][j] == 1 && i > 0 && j > 0)\n          matrix[i][j] +=\n              Math.min(matrix[i - 1][j - 1], Math.min(matrix[i - 1][j], matrix[i][j - 1]));\n    return Arrays.stream(matrix).flatMapToInt(Arrays::stream).sum();\n  }\n}"
    }
  },
  "1278": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1279": {
    "solution": {
      "concurrency": "class TrafficLight {\n  private int road = 1;\n\n  public TrafficLight() {\n  }\n\n  public synchronized void carArrived(\n      int carId, \n      int roadId,\n      int direction, \n      Runnable turnGreen, \n      Runnable crossCar \n  ) {\n      if (roadId != road) {\n          turnGreen.run();\n          road = roadId;\n      }\n      crossCar.run();\n  }\n}"
    }
  },
  "1280": {
    "solution": {
      "database": ""
    }
  },
  "1281": {
    "solution": {
      "math": "class Solution {\n    public int subtractProductAndSum(int n) {\n        int product = 1, sum = 0;\n\n        while (n > 0) {\n            int digit = n % 10;\n            product *= digit;\n            sum += digit;\n            n /= 10;\n        }\n\n        return product - sum;\n    }\n}"
    }
  },
  "1282": {
    "solution": {
      "hash-table": ""
    }
  },
  "1283": {
    "solution": {
      "array": ""
    }
  },
  "1284": {
    "solution": {
      "matrix": ""
    }
  },
  "1285": {
    "solution": {
      "database": ""
    }
  },
  "1286": {
    "solution": {
      "iterator": "class CombinationIterator {\n    private List<String> combinations;\n    private int currentIndex;\n\n    public CombinationIterator(String characters, int combinationLength) {\n        combinations = new ArrayList<>();\n        generateCombinations(characters, combinationLength, 0, new StringBuilder());\n        currentIndex = 0;\n    }\n\n    private void generateCombinations(String characters, int length, int start, StringBuilder sb) {\n        if (sb.length() == length) {\n            combinations.add(sb.toString());\n            return;\n        }\n\n        for (int i = start; i < characters.length(); i++) {\n            sb.append(characters.charAt(i));\n            generateCombinations(characters, length, i + 1, sb);\n            sb.deleteCharAt(sb.length() - 1);\n        }\n    }\n\n    public String next() {\n        return combinations.get(currentIndex++);\n    }\n\n    public boolean hasNext() {\n        return currentIndex < combinations.size();\n    }\n}\n\n/**\n * Your CombinationIterator object will be instantiated and called as such:\n * CombinationIterator obj = new CombinationIterator(characters,\n * combinationLength);\n * String param_1 = obj.next();\n * boolean param_2 = obj.hasNext();\n */"
    }
  },
  "1287": {
    "solution": {
      "array": ""
    }
  },
  "1288": {
    "solution": {
      "sorting": ""
    }
  },
  "1289": {
    "solution": {
      "matrix": ""
    }
  },
  "1290": {
    "solution": {
      "linked-list": ""
    }
  },
  "1291": {
    "solution": {
      "enumeration": ""
    }
  },
  "1292": {
    "solution": {
      "matrix": "public class Solution {\n    public int maxSideLength(int[][] grid, int threshold) {\n        int rows = grid.length, cols = grid[0].length;\n        int[][] prefix = new int[rows + 1][cols + 1];\n\n        for (int i = 1; i <= rows; i++) {\n            for (int j = 1; j <= cols; j++) {\n                prefix[i][j] = grid[i - 1][j - 1] \n                    + prefix[i - 1][j] \n                    + prefix[i][j - 1] \n                    - prefix[i - 1][j - 1];\n            }\n        }\n\n        int left = 0, right = Math.min(rows, cols);\n        int maxLen = 0;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            if (canFindSquareOfSize(prefix, mid, threshold)) {\n                maxLen = mid;  // mid is a valid side length\n                left = mid + 1;  // try to find a larger square\n            } else {\n                right = mid - 1;  // try to find a smaller square\n            }\n        }\n\n        return maxLen;\n    }\n\n    private boolean canFindSquareOfSize(int[][] prefix, int size, int threshold) {\n        for (int i = size; i < prefix.length; i++) {\n            for (int j = size; j < prefix[0].length; j++) {\n                int sum = prefix[i][j] \n                        - prefix[i - size][j] \n                        - prefix[i][j - size] \n                        + prefix[i - size][j - size];\n                if (sum <= threshold) {\n                    return true;\n                }\n            }\n        }\n        return false;\n    }\n}\n"
    }
  },
  "1293": {
    "solution": {
      "matrix": "import java.util.LinkedList;\nimport java.util.Queue;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int shortestPath(int[][] grid, int k) {\n        int rows = grid.length, cols = grid[0].length;\n        \n        if (rows == 1 && cols == 1) return 0;\n\n        // 3D visited array to track states with remaining eliminations\n        boolean[][][] visited = new boolean[rows][cols][k + 1];\n        \n        // Queue elements as {x, y, current_distance, remaining_k}\n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[]{0, 0, 0, k});\n        visited[0][0][k] = true;\n\n        while (!queue.isEmpty()) {\n            int[] curr = queue.poll();\n            int x = curr[0], y = curr[1], dist = curr[2], remainingK = curr[3];\n\n            for (int[] dir : DIRECTIONS) {\n                int newX = x + dir[0];\n                int newY = y + dir[1];\n\n                if (newX >= 0 && newY >= 0 && newX < rows && newY < cols) {\n                    // If we reached the destination\n                    if (newX == rows - 1 && newY == cols - 1) {\n                        return dist + 1;\n                    }\n\n                    int newK = remainingK - grid[newX][newY];\n\n                    // If this state has not been visited and the newK is valid\n                    if (newK >= 0 && !visited[newX][newY][newK]) {\n                        visited[newX][newY][newK] = true;\n                        queue.offer(new int[]{newX, newY, dist + 1, newK});\n                    }\n                }\n            }\n        }\n\n        return -1;\n    }\n}\n"
    }
  },
  "1294": {
    "solution": {
      "database": ""
    }
  },
  "1295": {
    "solution": {
      "array": "class Solution {\n    public int findNumbers(int[] nums) {\n        int count = 0;\n\n        for (int num : nums) {\n            int digitCount = 0;\n            int current = num;\n\n            while (current > 0) {\n                current /= 10;\n                ++digitCount;\n            }\n\n            if (digitCount % 2 == 0) {\n                ++count;\n            }\n        }\n\n        return count;\n    }\n}"
    }
  },
  "1296": {
    "solution": {
      "greedy": ""
    }
  },
  "1297": {
    "solution": {
      "sliding-window": "import java.util.HashMap;\nimport java.util.Map;\n\nclass Solution {\n    public int maxFreq(String s, int maxLetters, int minSize, int maxSize) {\n        int n = s.length();\n        int maxCount = 0;\n        Map<String, Integer> substringCount = new HashMap<>();\n        \n        for (int i = 0; i <= n - minSize; ++i) {\n            String sub = s.substring(i, i + minSize);\n            if (isValid(sub, maxLetters)) {\n                substringCount.put(sub, substringCount.getOrDefault(sub, 0) + 1);\n                maxCount = Math.max(maxCount, substringCount.get(sub));\n            }\n        }\n        \n        return maxCount;\n    }\n    \n    private boolean isValid(String sub, int maxLetters) {\n        int[] count = new int[26];\n        int uniqueLetters = 0;\n        for (char c : sub.toCharArray()) {\n            if (count[c - 'a'] == 0) {\n                uniqueLetters++;\n            }\n            count[c - 'a']++;\n        }\n        return uniqueLetters <= maxLetters;\n    }\n}\n"
    }
  },
  "1298": {
    "solution": {
      "graph": "import java.util.*;\n\nclass Solution {\n    public int maxCandies(int[] status, int[] candies, int[][] keys, int[][] containedBoxes, int[] initialBoxes) {\n        Queue<Integer> availableBoxes = new LinkedList<>();\n        Set<Integer> unopenedBoxes = new HashSet<>();\n        Set<Integer> collectedKeys = new HashSet<>();\n        int totalCandies = 0;\n\n        for (int box : initialBoxes) {\n            if (status[box] == 1) {\n                availableBoxes.offer(box);\n            } else {\n                unopenedBoxes.add(box);\n            }\n        }\n\n        while (!availableBoxes.isEmpty()) {\n            int currentBox = availableBoxes.poll();\n            totalCandies += candies[currentBox];\n\n            for (int key : keys[currentBox]) {\n                if (collectedKeys.add(key) && unopenedBoxes.remove(key)) {\n                    availableBoxes.offer(key);\n                }\n            }\n\n            for (int box : containedBoxes[currentBox]) {\n                if (status[box] == 1 || collectedKeys.contains(box)) {\n                    availableBoxes.offer(box);\n                } else {\n                    unopenedBoxes.add(box);\n                }\n            }\n        }\n\n        return totalCandies;\n    }\n}"
    }
  },
  "1299": {
    "solution": {
      "array": "class Solution {\n    public int[] replaceElements(int[] arr) {\n        int n = arr.length;\n        int maxRight = -1;\n\n        for (int i = n - 1; i >= 0; --i) {\n            int current = arr[i];\n            arr[i] = maxRight;\n            maxRight = Math.max(maxRight, current);\n        }\n\n        return arr;\n    }\n}"
    }
  },
  "1300": {
    "solution": {
      "sorting": ""
    }
  },
  "1301": {
    "solution": {
      "matrix": "import java.util.Arrays;\n\npublic class Solution {\n    public int[] pathsWithMaxScore(List<String> board) {\n        int n = board.size();\n        int MOD = 1_000_000_007;\n\n        /*\n          int MOD = 1_000_000_007; defines a modulus value commonly used in algorithmic problems to prevent overflow and keep numbers manageable while working with large values.\n          \n          Why 1_000_000_007? It's a large prime number commonly used in competitive programming to maintain modular arithmetic properties and avoid overflow.\n        */\n\n        int[][] dpScore = new int[n][n];\n        int[][] dpPaths = new int[n][n];\n\n        // Starting point 'E'\n        dpPaths[n - 1][n - 1] = 1;\n\n        for (int i = n - 1; i >= 0; i--) {\n            for (int j = n - 1; j >= 0; j--) {\n                char cell = board.get(i).charAt(j);\n\n                if (cell == 'X') continue;\n\n                // Extract numeric value if the cell is not 'S' or 'E'\n                int cellValue = (cell == 'E' || cell == 'S') ? 0 : cell - '0';\n\n                // Look at cells from which we can move to (i, j): right, down, diagonal\n                for (int[] direction : new int[][] {{1, 0}, {0, 1}, {1, 1}}) {\n                    int prevRow = i + direction[0];\n                    int prevCol = j + direction[1];\n\n                    if (prevRow < n && prevCol < n && dpPaths[prevRow][prevCol] > 0) {\n                        int scoreFromPrev = dpScore[prevRow][prevCol] + cellValue;\n\n                        if (scoreFromPrev > dpScore[i][j]) {\n                            dpScore[i][j] = scoreFromPrev;\n                            dpPaths[i][j] = dpPaths[prevRow][prevCol];\n                        } else if (scoreFromPrev == dpScore[i][j]) {\n                            dpPaths[i][j] = (dpPaths[i][j] + dpPaths[prevRow][prevCol]) % MOD;\n                        }\n                    }\n                }\n            }\n        }\n\n        // If no path exists to reach 'S', dpPaths[0][0] would be 0\n        return dpPaths[0][0] == 0 ? new int[] {0, 0} : new int[] {dpScore[0][0], dpPaths[0][0]};\n    }\n}\n"
    }
  },
  "1302": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private int maxDepth = 0;\n    private int sum = 0;\n\n    public int deepestLeavesSum(TreeNode root) {\n        dfs(root, 0);\n        return sum;\n    }\n\n    private void dfs(TreeNode node, int depth) {\n        if (node == null) return;\n\n        if (depth > maxDepth) {\n            maxDepth = depth;\n            sum = node.val;\n        } else if (depth == maxDepth) {\n            sum += node.val;\n        }\n\n        dfs(node.left, depth + 1);\n        dfs(node.right, depth + 1);\n    }\n}"
    }
  },
  "1303": {
    "solution": {
      "database": ""
    }
  },
  "1304": {
    "solution": {
      "math": "class Solution {\n    public int[] sumZero(int n) {\n        int[] result = new int[n];\n        int num = 1;\n        for (int i = 0; i < n - 1; i += 2) {\n            result[i] = num;\n            result[i + 1] = -num;\n            num++;\n        }\n        if (n % 2 != 0) {\n            result[n - 1] = 0;\n        }\n        return result;\n    }\n}"
    }
  },
  "1305": {
    "solution": {
      "binary-search-tree": ""
    }
  },
  "1306": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "1307": {
    "solution": {
      "backtracking": ""
    }
  },
  "1308": {
    "solution": {
      "database": ""
    }
  },
  "1309": {
    "solution": {
      "string": "class Solution {\n    public String freqAlphabets(String s) {\n        StringBuilder result = new StringBuilder();\n        int n = s.length();\n        for (int i = 0; i < n; i++) {\n            if (i + 2 < n && s.charAt(i + 2) == '#') {\n                int num = (s.charAt(i) - '0') * 10 + (s.charAt(i + 1) - '0');\n                result.append((char) ('a' + num - 1));\n                i += 2;\n            } else {\n                int num = s.charAt(i) - '0';\n                result.append((char) ('a' + num - 1));\n            }\n        }\n        return result.toString();\n    }\n}"
    }
  },
  "1310": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1311": {
    "solution": {
      "graph": ""
    }
  },
  "1312": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1313": {
    "solution": {
      "array": ""
    }
  },
  "1314": {
    "solution": {
      "matrix": "public class Solution {\n    public int[][] matrixBlockSum(int[][] mat, int K) {\n        int m = mat.length;\n        int n = mat[0].length;\n\n        int[][] prefixSum = new int[m + 1][n + 1];\n\n        for (int i = 1; i <= m; i++) {\n            for (int j = 1; j <= n; j++) {\n                prefixSum[i][j] = mat[i - 1][j - 1]\n                        + prefixSum[i - 1][j]\n                        + prefixSum[i][j - 1]\n                        - prefixSum[i - 1][j - 1];\n            }\n        }\n\n        int[][] result = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int r1 = Math.max(0, i - K);\n                int c1 = Math.max(0, j - K);\n                int r2 = Math.min(m - 1, i + K);\n                int c2 = Math.min(n - 1, j + K);\n                \n                result[i][j] = prefixSum[r2 + 1][c2 + 1]\n                             - prefixSum[r1][c2 + 1]\n                             - prefixSum[r2 + 1][c1]\n                             + prefixSum[r1][c1];\n            }\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] mat = {\n            {1, 2, 3},\n            {4, 5, 6},\n            {7, 8, 9}\n        };\n        int K = 1;\n        int[][] result = solution.matrixBlockSum(mat, K);\n        \n        // Print the result\n        for (int[] row : result) {\n            for (int num : row) {\n                System.out.print(num + \" \");\n            }\n            System.out.println();\n        }\n    }\n}\n"
    }
  },
  "1315": {
    "solution": {
      "tree": ""
    }
  },
  "1316": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "1317": {
    "solution": {
      "math": "class Solution {\n    public int[] getNoZeroIntegers(int n) {\n        for (int a = 1; a < n; a++) {\n            int b = n - a;\n            if (!containsZero(a) && !containsZero(b)) {\n                return new int[]{a, b};\n            }\n        }\n        return new int[0]; // Should never be reached\n    }\n\n    private boolean containsZero(int num) {\n        while (num > 0) {\n            if (num % 10 == 0) return true;\n            num /= 10;\n        }\n        return false;\n    }\n}"
    }
  },
  "1318": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1319": {
    "solution": {
      "union-find": ""
    }
  },
  "1320": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1321": {
    "solution": {
      "database": ""
    }
  },
  "1322": {
    "solution": {
      "database": ""
    }
  },
  "1323": {
    "solution": {
      "math": "class Solution {\n    public int maximum69Number(int num) {\n        char[] chars = String.valueOf(num).toCharArray();\n        for (int i = 0; i < chars.length; i++) {\n            if (chars[i] == '6') {\n                chars[i] = '9';\n                break;\n            }\n        }\n        return Integer.parseInt(new String(chars));\n    }\n}"
    }
  },
  "1324": {
    "solution": {
      "string": ""
    }
  },
  "1325": {
    "solution": {
      "depth-first-search": "class TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}\n\nclass Solution {\n    public TreeNode removeLeafNodes(TreeNode root, int target) {\n        if (root == null) return null;\n\n        root.left = removeLeafNodes(root.left, target);\n        root.right = removeLeafNodes(root.right, target);\n\n        if (root.left == null && root.right == null && root.val == target) {\n            return null;\n        }\n\n        return root;\n    }\n}"
    }
  },
  "1326": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1327": {
    "solution": {
      "database": ""
    }
  },
  "1328": {
    "solution": {
      "greedy": ""
    }
  },
  "1329": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public int[][] diagonalSort(int[][] mat) {\n        int m = mat.length, n = mat[0].length;\n        Map<Integer, PriorityQueue<Integer>> map = new HashMap<>();\n\n        // Collect elements along the same diagonal into a priority queue\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                map.computeIfAbsent(i - j, k -> new PriorityQueue<>()).add(mat[i][j]);\n            }\n        }\n\n        // Reconstruct the matrix with sorted diagonals\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                mat[i][j] = map.get(i - j).poll();\n            }\n        }\n\n        return mat;\n    }\n}"
    }
  },
  "1330": {
    "solution": {
      "greedy": ""
    }
  },
  "1331": {
    "solution": {
      "hash-table": "import java.util.*;\n\nclass Solution {\n    public int[] arrayRankTransform(int[] arr) {\n        int[] sortedArr = arr.clone();\n        Arrays.sort(sortedArr);\n        Map<Integer, Integer> rankMap = new HashMap<>();\n\n        int rank = 1;\n        for (int num : sortedArr) {\n            if (!rankMap.containsKey(num)) {\n                rankMap.put(num, rank++);\n            }\n        }\n\n        int[] result = new int[arr.length];\n        for (int i = 0; i < arr.length; i++) {\n            result[i] = rankMap.get(arr[i]);\n        }\n\n        return result;\n    }\n}"
    }
  },
  "1332": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1333": {
    "solution": {
      "sorting": ""
    }
  },
  "1334": {
    "solution": {
      "shortest-path": "import java.util.*;\n\nclass Solution {\n    public int findTheCity(int n, int[][] edges, int distanceThreshold) {\n        int[][] dist = new int[n][n];\n\n        for (int i = 0; i < n; i++) {\n            Arrays.fill(dist[i], Integer.MAX_VALUE / 2); // Prevent overflow\n            dist[i][i] = 0;\n        }\n\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1], weight = edge[2];\n            dist[u][v] = weight;\n            dist[v][u] = weight;\n        }\n\n        for (int k = 0; k < n; k++) {\n            for (int i = 0; i < n; i++) {\n                for (int j = 0; j < n; j++) {\n                    dist[i][j] = Math.min(dist[i][j], dist[i][k] + dist[k][j]);\n                }\n            }\n        }\n\n        int minNeighborCount = Integer.MAX_VALUE;\n        int resultCity = -1;\n\n        for (int i = 0; i < n; i++) {\n            int neighborCount = 0;\n            for (int j = 0; j < n; j++) {\n                if (i != j && dist[i][j] <= distanceThreshold) {\n                    neighborCount++;\n                }\n            }\n            if (neighborCount <= minNeighborCount) {\n                minNeighborCount = neighborCount;\n                resultCity = i;\n            }\n        }\n\n        return resultCity;\n    }\n}"
    }
  },
  "1335": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1336": {
    "solution": {
      "database": ""
    }
  },
  "1337": {
    "solution": {
      "matrix": "import java.util.*;\n\nclass Solution {\n    public int[] kWeakestRows(int[][] mat, int k) {\n        int m = mat.length;\n        int n = mat[0].length;\n        \n        PriorityQueue<int[]> pq = new PriorityQueue<>(\n            (a, b) -> a[1] == b[1] ? a[0] - b[0] : a[1] - b[1]\n        );\n        \n        for (int i = 0; i < m; i++) {\n            int soldiers = countSoldiers(mat[i]);\n            pq.offer(new int[]{i, soldiers});\n        }\n        \n        int[] result = new int[k];\n        for (int i = 0; i < k; i++) {\n            result[i] = pq.poll()[0];\n        }\n        \n        return result;\n    }\n    \n    private int countSoldiers(int[] row) {\n        int count = 0;\n        for (int num : row) {\n            if (num == 1) {\n                count++;\n            }\n        }\n        return count;\n    }\n}\n"
    }
  },
  "1338": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int minSetSize(int[] arr) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        for (int num : arr) {\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        List<Integer> counts = new ArrayList<>(freq.values());\n        counts.sort(Collections.reverseOrder());\n\n        int removed = 0, setSize = 0, target = arr.length / 2;\n        for (int count : counts) {\n            removed += count;\n            setSize++;\n            if (removed >= target) break;\n        }\n\n        return setSize;\n    }\n}"
    }
  },
  "1339": {
    "solution": {
      "tree": "import java.util.*;\n\nclass Solution {\n    private long totalSum = 0;\n    private long maxProd = 0;\n    private final int MOD = 1_000_000_007;\n\n    public int maxProduct(TreeNode root) {\n        totalSum = dfs(root);\n        dfs(root);\n        return (int)(maxProd % MOD);\n    }\n\n    private long dfs(TreeNode node) {\n        if (node == null) return 0;\n        long leftSum = dfs(node.left);\n        long rightSum = dfs(node.right);\n        long currSum = node.val + leftSum + rightSum;\n        maxProd = Math.max(maxProd, currSum * (totalSum - currSum));\n        return currSum;\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left, right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}"
    }
  },
  "1340": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int maxJumps(int[] arr, int d) {\n        int n = arr.length;\n        int[] dp = new int[n];\n        Arrays.fill(dp, -1);\n\n        int result = 0;\n        for (int i = 0; i < n; i++) {\n            result = Math.max(result, dfs(arr, d, i, dp));\n        }\n        return result;\n    }\n\n    private int dfs(int[] arr, int d, int i, int[] dp) {\n        if (dp[i] != -1) return dp[i];\n        int n = arr.length;\n        dp[i] = 1;\n\n        for (int j = i + 1; j <= i + d && j < n && arr[j] < arr[i]; j++) {\n            dp[i] = Math.max(dp[i], 1 + dfs(arr, d, j, dp));\n        }\n\n        for (int j = i - 1; j >= i - d && j >= 0 && arr[j] < arr[i]; j--) {\n            dp[i] = Math.max(dp[i], 1 + dfs(arr, d, j, dp));\n        }\n\n        return dp[i];\n    }\n}"
    }
  },
  "1341": {
    "solution": {
      "database": ""
    }
  },
  "1342": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1343": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numOfSubarrays(int[] arr, int k, int threshold) {\n        int count = 0;\n        int windowSum = 0;\n        int n = arr.length;\n        int targetSum = k * threshold;\n\n        for (int i = 0; i < k; i++) {\n            windowSum += arr[i];\n        }\n\n        if (windowSum >= targetSum) {\n            count++;\n        }\n\n        for (int i = k; i < n; i++) {\n            windowSum += arr[i] - arr[i - k];\n            if (windowSum >= targetSum) {\n                count++;\n            }\n        }\n\n        return count;\n    }\n}\n"
    }
  },
  "1344": {
    "solution": {
      "math": ""
    }
  },
  "1345": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "1346": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1347": {
    "solution": {
      "counting": ""
    }
  },
  "1348": {
    "solution": {
      "ordered-set": ""
    }
  },
  "1349": {
    "solution": {
      "matrix": ""
    }
  },
  "1350": {
    "solution": {
      "database": ""
    }
  },
  "1351": {
    "solution": {
      "matrix": "class Solution {\n    public int countNegatives(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int ans = 0;\n        for (int i = m - 1, j = 0; i >= 0 && j < n;) {\n            if (grid[i][j] < 0) {\n                ans += n - j;\n                --i;\n            } else {\n                ++j;\n            }\n        }\n        return ans;\n    }\n}"
    }
  },
  "1352": {
    "solution": {
      "queue": "class ProductOfNumbers {\n    public ProductOfNumbers() {\n        prefix = new ArrayList<>(Arrays.asList(1));\n    }\n\n    public void add(int num) {\n        if (num == 0)\n            prefix = new ArrayList<>(Arrays.asList(1));\n        else\n            prefix.add(prefix.get(prefix.size() - 1) * num);\n    }\n\n    public int getProduct(int k) {\n        return k >= prefix.size() ? 0\n                : prefix.get(prefix.size() - 1) / prefix.get(prefix.size() - k - 1);\n    }\n\n    private List<Integer> prefix = new ArrayList<>();\n}\n/**\n * Your ProductOfNumbers object will be instantiated and called as such:\n * ProductOfNumbers obj = new ProductOfNumbers();\n * obj.add(num);\n * int param_2 = obj.getProduct(k);\n */"
    }
  },
  "1353": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1354": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1355": {
    "solution": {
      "database": ""
    }
  },
  "1356": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1357": {
    "solution": {
      "design": ""
    }
  },
  "1358": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numberOfSubstrings(String s) {\n        int[] count = new int[3]; \n        int left = 0;\n        int result = 0;\n        \n        for (int right = 0; right < s.length(); right++) {\n            count[s.charAt(right) - 'a']++;\n            \n            while (count[0] > 0 && count[1] > 0 && count[2] > 0) {\n                result += s.length() - right; \n                count[s.charAt(left) - 'a']--;\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "1359": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1360": {
    "solution": {
      "math": ""
    }
  },
  "1361": {
    "solution": {
      "binary-tree": "class Solution {\n public:\n  bool validateBinaryTreeNodes(int n, vector<int>& leftChild,\n                               vector<int>& rightChild) {\n    vector<int> inDegrees(n);\n    int root = -1;\n\n    for (const int child : leftChild)\n      if (child != -1 && ++inDegrees[child] == 2)\n        return false;\n\n    for (const int child : rightChild)\n      if (child != -1 && ++inDegrees[child] == 2)\n        return false;\n\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        if (root == -1)\n          root = i;\n        else\n          return false;  \n\n    if (root == -1)\n      return false;\n\n    return countNodes(root, leftChild, rightChild) == n;\n  }\n\n private:\n  int countNodes(int root, const vector<int>& leftChild,\n                 const vector<int>& rightChild) {\n    if (root == -1)\n      return 0;\n    return 1 +  //\n           countNodes(leftChild[root], leftChild, rightChild) +\n           countNodes(rightChild[root], leftChild, rightChild);\n  }\n};"
    }
  },
  "1362": {
    "solution": {
      "math": ""
    }
  },
  "1363": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1364": {
    "solution": {
      "database": ""
    }
  },
  "1365": {
    "solution": {
      "counting": ""
    }
  },
  "1366": {
    "solution": {
      "counting": ""
    }
  },
  "1367": {
    "solution": {
      "binary-tree": "class Solution {\n    public boolean isSubPath(ListNode head, TreeNode root) {\n        if (root == null) return false;\n        return dfs(head, root) || isSubPath(head, root.left) || isSubPath(head, root.right);\n    }\n\n    private boolean dfs(ListNode head, TreeNode root) {\n        if (head == null) return true;\n        if (root == null) return false;\n        if (head.val != root.val) return false;\n        return dfs(head.next, root.left) || dfs(head.next, root.right);\n    }\n}\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}"
    }
  },
  "1368": {
    "solution": {
      "matrix": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int minCost(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        Deque<int[]> queue = new ArrayDeque<>();\n        queue.offer(new int[] {0, 0, 0});\n        \n        int[][] directions = { \n            {0, 0},   // Stay (no direction change)\n            {0, 1},   // Right\n            {0, -1},  // Left\n            {1, 0},   // Down\n            {-1, 0}   // Up\n        };\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1], cost = current[2];\n            \n            if (row == rows - 1 && col == cols - 1) {\n                return cost;\n            }\n            \n            if (visited[row][col]) {\n                continue;\n            }\n            visited[row][col] = true;\n            \n            for (int direction = 1; direction <= 4; ++direction) {\n                int newRow = row + directions[direction][0];\n                int newCol = col + directions[direction][1];\n                \n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols) {\n                    if (grid[row][col] == direction) {\n                        queue.offerFirst(new int[] {newRow, newCol, cost});\n                    } else {\n                        queue.offer(new int[] {newRow, newCol, cost + 1});\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n}\n"
    }
  },
  "1369": {
    "solution": {
      "database": ""
    }
  },
  "1370": {
    "solution": {
      "counting": ""
    }
  },
  "1371": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1372": {
    "solution": {
      "depth-first-search": "class Solution {\n    private int result = 0;\n\n    public int longestZigZag(TreeNode root) {\n        dfs(root, 0, true);\n        dfs(root, 0, false);\n        return result;\n    }\n\n    private void dfs(TreeNode node, int length, boolean isLeft) {\n        if (node == null) return;\n\n        result = Math.max(result, length);\n\n        if (isLeft) {\n            dfs(node.left, length + 1, false);\n            dfs(node.right, 1, true);\n        } else {\n            dfs(node.right, length + 1, true);\n            dfs(node.left, 1, false);\n        }\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode() {}\n    TreeNode(int val) { this.val = val; }\n    TreeNode(int val, TreeNode left, TreeNode right) {\n        this.val = val;\n        this.left = left;\n        this.right = right;\n    }\n}"
    }
  },
  "1373": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n * int val;\n * TreeNode left;\n * TreeNode right;\n * TreeNode() {}\n * TreeNode(int val) { this.val = val; }\n * TreeNode(int val, TreeNode left, TreeNode right) {\n * this.val = val;\n * this.left = left;\n * this.right = right;\n * }\n * }\n */\nclass Solution {\n    private int maxSum = 0;\n\n    public int maxSumBST(TreeNode root) {\n        dfs(root);\n        return maxSum;\n    }\n\n    private int[] dfs(TreeNode node) {\n        if (node == null) {\n            return new int[] { 1, Integer.MAX_VALUE, Integer.MIN_VALUE, 0 }; // isBST, min, max, sum\n        }\n\n        int[] left = dfs(node.left);\n        int[] right = dfs(node.right);\n\n        if (left[0] == 1 && right[0] == 1 && node.val > left[2] && node.val < right[1]) {\n            int sum = left[3] + right[3] + node.val;\n            maxSum = Math.max(maxSum, sum);\n            int min = Math.min(left[1], node.val);\n            int max = Math.max(right[2], node.val);\n            return new int[] { 1, min, max, sum };\n        } else {\n            return new int[] { 0, 0, 0, 0 }; // not a BST\n        }\n    }\n}\n"
    }
  },
  "1374": {
    "solution": {
      "string": ""
    }
  },
  "1375": {
    "solution": {
      "array": ""
    }
  },
  "1376": {
    "solution": {
      "tree": ""
    }
  },
  "1377": {
    "solution": {
      "graph": "class Solution {\n    public double frogPosition(int totalNodes, int[][] edges, int maxSeconds, int targetNode) {\n        List<List<Integer>> adjacencyList = new ArrayList<>();\n\n        // Build adjacency list for the graph\n        for (int i = 0; i <= totalNodes; i++) {\n            adjacencyList.add(new ArrayList<>());\n        }\n        for (int[] edge : edges) {\n            adjacencyList.get(edge[0]).add(edge[1]);\n            adjacencyList.get(edge[1]).add(edge[0]);\n        }\n\n        boolean[] visited = new boolean[totalNodes + 1];\n        Queue<int[]> nodeQueue = new LinkedList<>();\n        Queue<Double> probabilityQueue = new LinkedList<>();\n\n        nodeQueue.offer(new int[]{1, 0}); // Start from node 1 at time 0\n        probabilityQueue.offer(1.0); // Initial probability is 1\n        visited[1] = true;\n\n        while (!nodeQueue.isEmpty()) {\n            int[] current = nodeQueue.poll();\n            int currentNode = current[0];\n            int currentTime = current[1];\n            double currentProbability = probabilityQueue.poll();\n\n            // Count number of unvisited neighbors\n            int unvisitedChildren = 0;\n            for (int neighbor : adjacencyList.get(currentNode)) {\n                if (!visited[neighbor]) {\n                    unvisitedChildren++;\n                }\n            }\n\n            // If reached the target node\n            if (currentNode == targetNode) {\n                if (currentTime == maxSeconds || unvisitedChildren == 0) {\n                    return currentProbability;\n                } else {\n                    return 0.0;\n                }\n            }\n\n            // Continue to next level if time allows\n            if (currentTime < maxSeconds) {\n                for (int neighbor : adjacencyList.get(currentNode)) {\n                    if (!visited[neighbor]) {\n                        visited[neighbor] = true;\n                        nodeQueue.offer(new int[]{neighbor, currentTime + 1});\n                        probabilityQueue.offer(currentProbability / unvisitedChildren);\n                    }\n                }\n            }\n        }\n\n        return 0.0;\n    }\n}"
    }
  },
  "1378": {
    "solution": {
      "database": "SELECT\n  EmployeeUNI.unique_id,\n  Employees.name\nFROM Employees\nLEFT JOIN EmployeeUNI\n  USING (id);"
    }
  },
  "1379": {
    "solution": {
      "tree": ""
    }
  },
  "1380": {
    "solution": {
      "matrix": ""
    }
  },
  "1381": {
    "solution": {
      "design": "class CustomStack {\n    private int[] stack;\n    private int size;\n    private int maxSize;\n\n    public CustomStack(int maxSize) {\n        this.stack = new int[maxSize];\n        this.size = 0;\n        this.maxSize = maxSize;\n    }\n\n    public void push(int x) {\n        if (size < maxSize) {\n            stack[size++] = x;\n        }\n    }\n\n    public int pop() {\n        if (size == 0) return -1;\n        return stack[--size];\n    }\n\n    public void increment(int k, int val) {\n        int limit = Math.min(k, size);\n        for (int i = 0; i < limit; i++) {\n            stack[i] += val;\n        }\n    }\n}"
    }
  },
  "1382": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    public TreeNode balanceBST(TreeNode root) {\n        List<TreeNode> nodes = new ArrayList<>();\n        inorderTraversal(root, nodes);\n        return buildBalancedBST(nodes, 0, nodes.size() - 1);\n    }\n    \n    private void inorderTraversal(TreeNode root, List<TreeNode> nodes) {\n        if (root == null) {\n            return;\n        }\n        inorderTraversal(root.left, nodes);\n        nodes.add(root);\n        inorderTraversal(root.right, nodes);\n    }\n    \n    private TreeNode buildBalancedBST(List<TreeNode> nodes, int start, int end) {\n        if (start > end) {\n            return null;\n        }\n        int mid = (start + end) / 2;\n        TreeNode node = nodes.get(mid);\n        node.left = buildBalancedBST(nodes, start, mid - 1);\n        node.right = buildBalancedBST(nodes, mid + 1, end);\n        return node;\n    }\n}\n"
    }
  },
  "1383": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1384": {
    "solution": {
      "database": ""
    }
  },
  "1385": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1386": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1387": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1388": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1389": {
    "solution": {
      "array": ""
    }
  },
  "1390": {
    "solution": {
      "math": ""
    }
  },
  "1391": {
    "solution": {
      "matrix": "import java.util.*;\n\nclass Solution {\n    private static final int[][][] DIRECTIONS = {\n        {}, // Empty for 0-index placeholder\n        {{0, -1}, {0, 1}},      // Type 1: left <-> right\n        {{-1, 0}, {1, 0}},      // Type 2: up <-> down\n        {{0, -1}, {1, 0}},      // Type 3: left <-> down\n        {{0, 1}, {1, 0}},       // Type 4: right <-> down\n        {{0, -1}, {-1, 0}},     // Type 5: left <-> up\n        {{0, 1}, {-1, 0}}       // Type 6: right <-> up\n    };\n\n    public boolean hasValidPath(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        boolean[][] visited = new boolean[rows][cols];\n        \n        Queue<int[]> queue = new LinkedList<>();\n        queue.offer(new int[] {0, 0});\n        visited[0][0] = true;\n        \n        while (!queue.isEmpty()) {\n            int[] current = queue.poll();\n            int row = current[0], col = current[1];\n            \n            // If reached the bottom-right cell, return true\n            if (row == rows - 1 && col == cols - 1) {\n                return true;\n            }\n            \n            int streetType = grid[row][col];\n            \n            // Explore each possible direction from the current cell\n            for (int[] direction : DIRECTIONS[streetType]) {\n                int newRow = row + direction[0];\n                int newCol = col + direction[1];\n                \n                // Check if new cell is within bounds and not visited\n                if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols && !visited[newRow][newCol]) {\n                    int nextStreetType = grid[newRow][newCol];\n                    \n                    // Check if the new cell's type allows connecting back to the current cell\n                    if (canConnect(newRow, newCol, row, col, nextStreetType)) {\n                        visited[newRow][newCol] = true;\n                        queue.offer(new int[] {newRow, newCol});\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    // Check if the new cell's street type can connect back to the current cell\n    private boolean canConnect(int newRow, int newCol, int prevRow, int prevCol, int nextStreetType) {\n        for (int[] direction : DIRECTIONS[nextStreetType]) {\n            int expectedRow = newRow + direction[0];\n            int expectedCol = newCol + direction[1];\n            if (expectedRow == prevRow && expectedCol == prevCol) {\n                return true;\n            }\n        }\n        return false;\n    }\n}\n"
    }
  },
  "1392": {
    "solution": {
      "kmp": "class Solution {\n    public String longestPrefix(String s) {\n        int n = s.length();\n        int[] lps = new int[n];\n        int len = 0;\n\n        for (int i = 1; i < n; i++) {\n            while (len > 0 && s.charAt(i) != s.charAt(len)) {\n                len = lps[len - 1];\n            }\n\n            if (s.charAt(i) == s.charAt(len)) {\n                len++;\n            }\n\n            lps[i] = len;\n        }\n\n        return s.substring(0, lps[n - 1]);\n    }\n}"
    }
  },
  "1393": {
    "solution": {
      "database": ""
    }
  },
  "1394": {
    "solution": {
      "counting": ""
    }
  },
  "1395": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1396": {
    "solution": {
      "design": ""
    }
  },
  "1397": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1398": {
    "solution": {
      "database": ""
    }
  },
  "1399": {
    "solution": {
      "hash-table": "class Solution {\n    public int countLargestGroup(int n) {\n        Map<Integer, Integer> groupCount = new HashMap<>();\n\n        for (int i = 1; i <= n; i++) {\n            int sum = digitSum(i);\n            groupCount.put(sum, groupCount.getOrDefault(sum, 0) + 1);\n        }\n\n        int maxGroupSize = 0;\n        for (int size : groupCount.values()) {\n            maxGroupSize = Math.max(maxGroupSize, size);\n        }\n\n        int count = 0;\n        for (int size : groupCount.values()) {\n            if (size == maxGroupSize) count++;\n        }\n\n        return count;\n    }\n\n    private int digitSum(int num) {\n        int sum = 0;\n        while (num > 0) {\n            sum += num % 10;\n            num /= 10;\n        }\n        return sum;\n    }\n}"
    }
  },
  "1400": {
    "solution": {
      "counting": ""
    }
  },
  "1401": {
    "solution": {
      "geometry": "class Solution {\n    public boolean checkOverlap(int radius, int xCenter, int yCenter, int x1, int y1, int x2, int y2) {\n        int nearestX = clamp(xCenter, x1, x2);\n        int nearestY = clamp(yCenter, y1, y2);\n\n        int dx = nearestX - xCenter;\n        int dy = nearestY - yCenter;\n\n        return dx * dx + dy * dy <= radius * radius;\n    }\n\n    private int clamp(int value, int min, int max) {\n        return Math.max(min, Math.min(max, value));\n    }\n}"
    }
  },
  "1402": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1403": {
    "solution": {
      "greedy": ""
    }
  },
  "1404": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1405": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1406": {
    "solution": {
      "game-theory": "class Solution {\n    public String stoneGameIII(int[] stoneValue) {\n        int n = stoneValue.length;\n        int[] dp = new int[n + 1];\n        int[] suffixSum = new int[n + 1];\n\n        for (int i = n - 1; i >= 0; i--) {\n            suffixSum[i] = suffixSum[i + 1] + stoneValue[i];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            dp[i] = Integer.MIN_VALUE;\n            for (int k = 1; k <= 3 && i + k <= n; k++) {\n                int currentSum = suffixSum[i] - suffixSum[i + k];\n                dp[i] = Math.max(dp[i], currentSum - dp[i + k]);\n            }\n        }\n\n        if (dp[0] > 0) return \"Alice\";\n        else if (dp[0] < 0) return \"Bob\";\n        else return \"Tie\";\n    }\n}"
    }
  },
  "1407": {
    "solution": {
      "database": ""
    }
  },
  "1408": {
    "solution": {
      "string-matching": ""
    }
  },
  "1409": {
    "solution": {
      "binary-indexed-tree": "class FenwickTree {\n    public FenwickTree(int n) {\n        sums = new int[n + 1];\n    }\n\n    public void add(int i, int delta) {\n        while (i < sums.length) {\n            sums[i] += delta;\n            i += lowbit(i);\n        }\n    }\n\n    public int get(int i) {\n        int sum = 0;\n        while (i > 0) {\n            sum += sums[i];\n            i -= lowbit(i);\n        }\n        return sum;\n    }\n\n    private int[] sums;\n\n    private static int lowbit(int i) {\n        return i & -i;\n    }\n}\n\nclass Solution {\n    public int[] processQueries(int[] queries, int m) {\n        int[] ans = new int[queries.length];\n        FenwickTree tree = new FenwickTree(2 * m + 1);\n        Map<Integer, Integer> numToIndex = new HashMap<>();\n\n        for (int num = 1; num <= m; ++num) {\n            numToIndex.put(num, num + m);\n            tree.add(num + m, 1);\n        }\n\n        int nextEmptyIndex = m; // Map 0 to m.\n\n        for (int i = 0; i < queries.length; ++i) {\n            int query = queries[i];\n            int index = numToIndex.get(query);\n            ans[i] = tree.get(index - 1);\n            tree.add(index, -1);\n            tree.add(nextEmptyIndex, 1);\n            numToIndex.put(query, nextEmptyIndex--);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "1410": {
    "solution": {
      "hash-table": ""
    }
  },
  "1411": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1412": {
    "solution": {
      "database": "# Write your MySQL query statement below\nWITH\n    T AS (\n        SELECT\n            student_id,\n            RANK() OVER (\n                PARTITION BY exam_id\n                ORDER BY score\n            ) AS rk1,\n            RANK() OVER (\n                PARTITION BY exam_id\n                ORDER BY score DESC\n            ) AS rk2\n        FROM Exam\n    )\nSELECT student_id, student_name\nFROM\n    T\n    JOIN Student USING (student_id)\nGROUP BY 1\nHAVING SUM(rk1 = 1) = 0 AND SUM(rk2 = 1) = 0\nORDER BY 1;"
    }
  },
  "1413": {
    "solution": {
      "prefix-sum": "public class Solution {\n    public int minStartValue(int[] nums) {\n        int runningSum = 0;\n        int minPrefixSum = Integer.MAX_VALUE;\n        \n        for (int num : nums) {\n            runningSum += num;\n            minPrefixSum = Math.min(minPrefixSum, runningSum);\n        }\n        \n        return (minPrefixSum < 0) ? 1 - minPrefixSum : 1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] nums = {-3, 2, -3, 4, 2};\n        System.out.println(solution.minStartValue(nums)); // Output: 5\n    }\n}\n"
    }
  },
  "1414": {
    "solution": {
      "math": "class Solution {\n    public int findMinFibonacciNumbers(int k) {\n        List<Integer> fib = new ArrayList<>();\n        fib.add(1);\n        fib.add(2);\n        while (fib.get(fib.size() - 1) <= k) {\n            int next = fib.get(fib.size() - 1) + fib.get(fib.size() - 2);\n            fib.add(next);\n        }\n\n        int count = 0;\n        for (int i = fib.size() - 1; i >= 0 && k > 0; i--) {\n            if (fib.get(i) <= k) {\n                k -= fib.get(i);\n                count++;\n            }\n        }\n        return count;\n    }\n}"
    }
  },
  "1415": {
    "solution": {
      "backtracking": "class Solution {\n    public String getHappyString(int n, int k) {\n        Queue<String> queue = new LinkedList<>();\n        queue.offer(\"a\");\n        queue.offer(\"b\");\n        queue.offer(\"c\");\n\n        while (!queue.isEmpty()) {\n            String s = queue.poll();\n            if (s.length() == n) {\n                k--;\n                if (k == 0) return s;\n            } else {\n                for (char c : new char[]{'a', 'b', 'c'}) {\n                    if (s.charAt(s.length() - 1) != c) {\n                        queue.offer(s + c);\n                    }\n                }\n            }\n        }\n\n        return \"\";\n    }\n}"
    }
  },
  "1416": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1417": {
    "solution": {
      "string": ""
    }
  },
  "1418": {
    "solution": {
      "ordered-set": ""
    }
  },
  "1419": {
    "solution": {
      "counting": ""
    }
  },
  "1420": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1421": {
    "solution": {
      "database": ""
    }
  },
  "1422": {
    "solution": {
      "prefix-sum": "public class Solution {\n    public int maxScore(String s) {\n        int totalOnes = 0;\n\n        // Count total number of '1's in the string\n        for (char c : s.toCharArray()) {\n            if (c == '1') {\n                totalOnes++;\n            }\n        }\n\n        int maxScore = 0;\n        int leftZeros = 0; // Count of '0's in the left part\n        int onesSeen = 0;  // Count of '1's seen so far\n\n        for (int i = 0; i < s.length() - 1; i++) { // Exclude the last character\n            if (s.charAt(i) == '0') {\n                leftZeros++;\n            } else {\n                onesSeen++;\n            }\n\n            int rightOnes = totalOnes - onesSeen; // Remaining '1's in the right part\n            int score = leftZeros + rightOnes;\n\n            maxScore = Math.max(maxScore, score);\n        }\n\n        return maxScore;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        System.out.println(solution.maxScore(\"011101\")); // Output: 5\n    }\n}\n"
    }
  },
  "1423": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxScore(int[] cardPoints, int k) {\n        int n = cardPoints.length;\n        int totalPoints = 0;\n        for (int i = 0; i < k; i++) {\n            totalPoints += cardPoints[i];\n        }\n\n        int maxPoints = totalPoints;\n\n        for (int i = 0; i < k; i++) {\n            totalPoints = totalPoints - cardPoints[k - 1 - i] + cardPoints[n - 1 - i];\n            maxPoints = Math.max(maxPoints, totalPoints);\n        }\n\n        return maxPoints;\n    }\n}"
    }
  },
  "1424": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1425": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int constrainedSubsetSum(int[] nums, int k) {\n        int n = nums.length;\n        int[] dp = new int[n];\n        Deque<Integer> deque = new LinkedList<>();\n        int maxSum = nums[0];\n\n        for (int i = 0; i < n; i++) {\n            dp[i] = nums[i];\n            if (!deque.isEmpty()) {\n                dp[i] = Math.max(dp[i], nums[i] + dp[deque.peekFirst()]);\n            }\n            maxSum = Math.max(maxSum, dp[i]);\n\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {\n                deque.pollLast();\n            }\n\n            deque.addLast(i);\n            \n            if (i - deque.peekFirst() >= k) {\n                deque.pollFirst();\n            }\n        }\n\n        return maxSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {10, 2, -10, 5, 20};\n        int k = 2;\n        System.out.println(solution.constrainedSubsetSum(nums, k));  // Output: 37\n    }\n}\n"
    }
  },
  "1426": {
    "solution": {
      "hash-table": ""
    }
  },
  "1427": {
    "solution": {
      "math": ""
    }
  },
  "1428": {
    "solution": {
      "matrix": "class Solution {\n  public int leftMostColumnWithOne(BinaryMatrix binaryMatrix) {\n    List<Integer> dimensions = binaryMatrix.dimensions();\n    int m = dimensions.get(0);\n    int n = dimensions.get(1);\n    int ans = -1;\n    int l = 0;\n    int r = n - 1;\n\n    while (l <= r) {\n      int mid = (l + r) / 2;\n      if (existOne(binaryMatrix, m, mid)) {\n        ans = mid;\n        r = mid - 1;\n      } else {\n        l = mid + 1;\n      }\n    }\n\n    return ans;\n  }\n\n  private boolean existOne(BinaryMatrix binaryMatrix, int m, int col) {\n    for (int i = 0; i < m; ++i)\n      if (binaryMatrix.get(i, col) == 1)\n        return true;\n    return false;\n  }\n}"
    }
  },
  "1429": {
    "solution": {
      "queue": "class FirstUnique {\n    private Map<Integer, Integer> count = new HashMap<>();\n    private Set<Integer> unique = new LinkedHashSet<>();\n\n    public FirstUnique(int[] nums) {\n        for (int v : nums) {\n            count.put(v, count.getOrDefault(v, 0) + 1);\n        }\n        for (int v : nums) {\n            if (count.get(v) == 1) {\n                unique.add(v);\n            }\n        }\n    }\n\n    public int showFirstUnique() {\n        return unique.isEmpty() ? -1 : unique.iterator().next();\n    }\n\n    public void add(int value) {\n        count.put(value, count.getOrDefault(value, 0) + 1);\n        if (count.get(value) == 1) {\n            unique.add(value);\n        } else {\n            unique.remove(value);\n        }\n    }\n}\n\n/**\n * Your FirstUnique object will be instantiated and called as such:\n * FirstUnique obj = new FirstUnique(nums);\n * int param_1 = obj.showFirstUnique();\n * obj.add(value);\n */"
    }
  },
  "1430": {
    "solution": {
      "tree": ""
    }
  },
  "1431": {
    "solution": {
      "array": ""
    }
  },
  "1432": {
    "solution": {
      "greedy": ""
    }
  },
  "1433": {
    "solution": {
      "array": "import java.util.Arrays;\n\nclass Solution {\n    public boolean checkIfCanBreak(String s1, String s2) {\n        char[] arr1 = s1.toCharArray();\n        char[] arr2 = s2.toCharArray();\n        Arrays.sort(arr1);\n        Arrays.sort(arr2);\n\n        boolean s1Breaks = true;\n        boolean s2Breaks = true;\n\n        for (int i = 0; i < arr1.length; i++) {\n            if (arr1[i] < arr2[i]) {\n                s1Breaks = false;\n            }\n            if (arr2[i] < arr1[i]) {\n                s2Breaks = false;\n            }\n        }\n\n        return s1Breaks || s2Breaks;\n    }\n}"
    }
  },
  "1434": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1435": {
    "solution": {
      "database": ""
    }
  },
  "1436": {
    "solution": {
      "hash-table": ""
    }
  },
  "1437": {
    "solution": {
      "array": "class Solution {\n    public boolean kLengthApart(int[] nums, int k) {\n        int prevIndex = -1;\n\n        for (int i = 0; i < nums.length; i++) {\n            if (nums[i] == 1) {\n                if (prevIndex != -1 && i - prevIndex - 1 < k) {\n                    return false;\n                }\n                prevIndex = i;\n            }\n        }\n\n        return true;\n    }\n}"
    }
  },
  "1438": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int longestSubarray(int[] nums, int limit) {\n        int left = 0, right = 0;\n        int maxLength = 0;\n        Deque<Integer> maxDeque = new LinkedList<>();\n        Deque<Integer> minDeque = new LinkedList<>();\n\n        while (right < nums.length) {\n            while (!maxDeque.isEmpty() && maxDeque.peekLast() < nums[right]) {\n                maxDeque.pollLast();\n            }\n            maxDeque.addLast(nums[right]);\n\n            while (!minDeque.isEmpty() && minDeque.peekLast() > nums[right]) {\n                minDeque.pollLast();\n            }\n            minDeque.addLast(nums[right]);\n\n            while (maxDeque.peekFirst() - minDeque.peekFirst() > limit) {\n                if (maxDeque.peekFirst() == nums[left]) {\n                    maxDeque.pollFirst();\n                }\n                if (minDeque.peekFirst() == nums[left]) {\n                    minDeque.pollFirst();\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left + 1);\n            right++;\n        }\n\n        return maxLength;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {8, 2, 4, 7};\n        int limit = 4;\n        System.out.println(solution.longestSubarray(nums, limit));  // Output: 2\n    }\n}\n"
    }
  },
  "1439": {
    "solution": {
      "matrix": "class T {\n    public int i;\n    public int j;\n    public int sum; // nums1[i] + nums2[j]\n\n    public T(int i, int j, int sum) {\n        this.i = i;\n        this.j = j;\n        this.sum = sum;\n    }\n}\n\nclass Solution {\n    public int kthSmallest(int[][] mat, int k) {\n        int[] row = mat[0];\n\n        for (int i = 1; i < mat.length; ++i)\n            row = kSmallestPairSums(row, mat[i], k);\n\n        return row[k - 1];\n    }\n\n    private int[] kSmallestPairSums(int[] nums1, int[] nums2, int k) {\n        List<Integer> ans = new ArrayList<>();\n        Queue<T> minHeap = new PriorityQueue<>((a, b) -> a.sum - b.sum);\n\n        for (int i = 0; i < k && i < nums1.length; ++i)\n            minHeap.offer(new T(i, 0, nums1[i] + nums2[0]));\n\n        while (!minHeap.isEmpty() && ans.size() < k) {\n            int i = minHeap.peek().i;\n            int j = minHeap.poll().j;\n            ans.add(nums1[i] + nums2[j]);\n            if (j + 1 < nums2.length)\n                minHeap.offer(new T(i, j + 1, nums1[i] + nums2[j + 1]));\n        }\n\n        return ans.stream().mapToInt(Integer::intValue).toArray();\n    }\n}"
    }
  },
  "1440": {
    "solution": {
      "database": ""
    }
  },
  "1441": {
    "solution": {
      "stack": ""
    }
  },
  "1442": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int countTriplets(int[] arr) {\n        int ans = 0;\n        int n = arr.length;\n        \n        // Create a prefix XOR array\n        int[] xors = new int[n + 1];\n        xors[0] = 0;\n        \n        for (int i = 0; i < n; i++) {\n            xors[i + 1] = xors[i] ^ arr[i];\n        }\n        \n        // Iterate over all possible triplets\n        for (int j = 1; j < n; j++) {\n            for (int i = 0; i < j; i++) {\n                int xors_i = xors[j] ^ xors[i];\n                for (int k = j; k < n; k++) {\n                    int xors_k = xors[k + 1] ^ xors[j];\n                    if (xors_i == xors_k) {\n                        ans++;\n                    }\n                }\n            }\n        }\n        \n        return ans;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.countTriplets(new int[]{2, 3, 1, 6, 7})); // Output: 4\n        System.out.println(solution.countTriplets(new int[]{1, 1, 1, 1, 1})); // Output: 10\n        System.out.println(solution.countTriplets(new int[]{2, 3}));          // Output: 0\n    }\n}\n"
    }
  },
  "1443": {
    "solution": {
      "tree": ""
    }
  },
  "1444": {
    "solution": {
      "matrix": ""
    }
  },
  "1445": {
    "solution": {
      "database": ""
    }
  },
  "1446": {
    "solution": {
      "string": ""
    }
  },
  "1447": {
    "solution": {
      "number-theory": ""
    }
  },
  "1448": {
    "solution": {
      "tree": ""
    }
  },
  "1449": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1450": {
    "solution": {
      "array": "class Solution {\n    public int busyStudent(int[] startTime, int[] endTime, int queryTime) {\n        int count = 0;\n        for (int i = 0; i < startTime.length; i++) {\n            if (startTime[i] <= queryTime && queryTime <= endTime[i]) {\n                count++;\n            }\n        }\n        return count;\n    }\n}"
    }
  },
  "1451": {
    "solution": {
      "sorting": "import java.util.*;\n\nclass Solution {\n    public String arrangeWords(String text) {\n        String[] words = text.toLowerCase().split(\" \");\n\n        List<String> wordList = Arrays.asList(words);\n        wordList.sort(Comparator.comparingInt(String::length));\n\n        StringBuilder result = new StringBuilder();\n        for (String word : wordList) {\n            if (result.length() > 0) result.append(\" \");\n            result.append(word);\n        }\n\n        result.setCharAt(0, Character.toUpperCase(result.charAt(0)));\n        return result.toString();\n    }\n}"
    }
  },
  "1452": {
    "solution": {
      "hash-table": ""
    }
  },
  "1453": {
    "solution": {
      "geometry": ""
    }
  },
  "1454": {
    "solution": {
      "database": ""
    }
  },
  "1455": {
    "solution": {
      "string-matching": "class Solution {\n    public int isPrefixOfWord(String sentence, String searchWord) {\n        String[] words = sentence.split(\" \");\n        for (int i = 0; i < words.length; i++) {\n            if (words[i].startsWith(searchWord)) {\n                return i + 1; // 1-based index\n            }\n        }\n        return -1;\n    }\n}"
    }
  },
  "1456": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxVowels(String s, int k) {\n        int maxVowels = 0;\n        int currentVowels = 0;\n        int n = s.length();\n\n        for (int i = 0; i < k; i++) {\n            if (isVowel(s.charAt(i))) {\n                currentVowels++;\n            }\n        }\n\n        maxVowels = currentVowels;\n\n        for (int i = k; i < n; i++) {\n            if (isVowel(s.charAt(i))) {\n                currentVowels++;\n            }\n            if (isVowel(s.charAt(i - k))) {\n                currentVowels--;\n            }\n            maxVowels = Math.max(maxVowels, currentVowels);\n        }\n\n        return maxVowels;\n    }\n\n    private boolean isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n}\n"
    }
  },
  "1457": {
    "solution": {
      "tree": ""
    }
  },
  "1458": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1459": {
    "solution": {
      "database": ""
    }
  },
  "1460": {
    "solution": {
      "sorting": ""
    }
  },
  "1461": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "1462": {
    "solution": {
      "topological-sort": "import java.util.*;\n\nclass Solution {\n    public List<Boolean> checkIfPrerequisite(int numCourses, int[][] prerequisites, int[][] queries) {\n        List<List<Integer>> graph = new ArrayList<>();\n        for (int i = 0; i < numCourses; i++) {\n            graph.add(new ArrayList<>());\n        }\n        \n        int[] inDegree = new int[numCourses];\n        boolean[][] prerequisite = new boolean[numCourses][numCourses];\n\n        for (int[] edge : prerequisites) {\n            graph.get(edge[0]).add(edge[1]);\n            inDegree[edge[1]]++;\n        }\n\n        Queue<Integer> queue = new LinkedList<>();\n        for (int i = 0; i < numCourses; i++) {\n            if (inDegree[i] == 0) {\n                queue.offer(i);\n            }\n        }\n\n        while (!queue.isEmpty()) {\n            int current = queue.poll();\n            for (int neighbor : graph.get(current)) {\n                prerequisite[current][neighbor] = true;\n                \n                for (int i = 0; i < numCourses; i++) {\n                    if (prerequisite[i][current]) {\n                        prerequisite[i][neighbor] = true;\n                    }\n                }\n                \n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    queue.offer(neighbor);\n                }\n            }\n        }\n\n        List<Boolean> result = new ArrayList<>();\n        for (int[] query : queries) {\n            result.add(prerequisite[query[0]][query[1]]);\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "1463": {
    "solution": {
      "matrix": "class Solution {\n    public int cherryPickup(int[][] grid) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        Integer[][][] memo = new Integer[rows][cols][cols];\n        \n        return dfs(grid, 0, 0, cols - 1, memo);\n    }\n    \n    private int dfs(int[][] grid, int row, int col1, int col2, Integer[][][] memo) {\n        int rows = grid.length;\n        int cols = grid[0].length;\n        \n        if (col1 < 0 || col1 >= cols || col2 < 0 || col2 >= cols) {\n            return 0;\n        }\n        \n        if (memo[row][col1][col2] != null) {\n            return memo[row][col1][col2];\n        }\n        \n        int result = grid[row][col1];\n        if (col1 != col2) {\n            result += grid[row][col2];\n        }\n        \n        if (row < rows - 1) {\n            int maxCherries = 0;\n            for (int newCol1 = col1 - 1; newCol1 <= col1 + 1; newCol1++) {\n                for (int newCol2 = col2 - 1; newCol2 <= col2 + 1; newCol2++) {\n                    maxCherries = Math.max(maxCherries, dfs(grid, row + 1, newCol1, newCol2, memo));\n                }\n            }\n            result += maxCherries;\n        }\n        \n        memo[row][col1][col2] = result;\n        return result;\n    }\n}\n"
    }
  },
  "1464": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1465": {
    "solution": {
      "greedy": ""
    }
  },
  "1466": {
    "solution": {
      "graph": ""
    }
  },
  "1467": {
    "solution": {
      "probability-and-statistics": "enum BoxCase {\n    kEqualBalls, kEqualDistantBalls\n}\n\nclass Solution {\n    public double getProbability(int[] balls) {\n      int n = Arrays.stream(balls).sum() / 2;\n        return cases(balls, 0, 0, 0, 0, 0, n, BoxCase.kEqualDistantBalls) /\n                cases(balls, 0, 0, 0, 0, 0, n, BoxCase.kEqualBalls);\n    }\n\n    private int[] fact = { 1, 1, 2, 6, 24, 120, 720 };\n\n    double cases(int[] balls, int i, int ballsCountA, int ballsCountB, int colorsCountA,\n            int colorsCountB, int n, BoxCase boxCase) {\n        if (ballsCountA > n || ballsCountB > n)\n            return 0;\n        if (i == balls.length)\n            return boxCase == BoxCase.kEqualBalls ? 1 : (colorsCountA == colorsCountB ? 1 : 0);\n\n        double ans = 0;\n\n        for (int ballsTakenA = 0; ballsTakenA <= balls[i]; ++ballsTakenA) {\n          int ballsTakenB = balls[i] - ballsTakenA;\n          int newcolorsCountA = colorsCountA + (ballsTakenA > 0 ? 1 : 0);\n          int newcolorsCountB = colorsCountB + (ballsTakenB > 0 ? 1 : 0);\n            ans += cases(balls, i + 1, ballsCountA + ballsTakenA, ballsCountB + ballsTakenB,\n                    newcolorsCountA, newcolorsCountB, n, boxCase) /\n                    (fact[ballsTakenA] * fact[ballsTakenB]);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "1468": {
    "solution": {
      "database": ""
    }
  },
  "1469": {
    "solution": {
      "depth-first-search": "import java.util.*;\n\nclass Solution {\n    public List<Integer> getLonelyNodes(TreeNode root) {\n        List<Integer> result = new ArrayList<>();\n        dfs(root, result);\n        return result;\n    }\n\n    private void dfs(TreeNode node, List<Integer> result) {\n        if (node == null) return;\n        if (node.left == null && node.right != null) {\n            result.add(node.right.val);\n        } else if (node.right == null && node.left != null) {\n            result.add(node.left.val);\n        }\n        dfs(node.left, result);\n        dfs(node.right, result);\n    }\n}\n\nclass TreeNode {\n    int val;\n    TreeNode left;\n    TreeNode right;\n    TreeNode(int val) { this.val = val; }\n}"
    }
  },
  "1470": {
    "solution": {
      "array": "class Solution {\n    public int[] shuffle(int[] nums, int n) {\n        int[] result = new int[nums.length];\n        for (int i = 0; i < n; i++) {\n            result[2 * i] = nums[i];\n            result[2 * i + 1] = nums[i + n];\n        }\n        return result;\n    }\n}"
    }
  },
  "1471": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1472": {
    "solution": {
      "doubly-linked-list": "class BrowserHistory {\n    class Node {\n        String url;\n        Node prev, next;\n        \n        Node(String url) {\n            this.url = url;\n        }\n      }\n    \n    private Node current;\n\n    public BrowserHistory(String homepage) {\n        current = new Node(homepage);\n      }\n\n    public void visit(String url) {\n        Node newNode = new Node(url);\n        current.next = newNode;\n        newNode.prev = current;\n        current = newNode;\n      }\n\n    public String back(int steps) {\n        while (steps > 0 && current.prev != null) {\n            current = current.prev;\n            steps--;\n        }\n        return current.url;\n      }\n\n    public String forward(int steps) {\n        while (steps > 0 && current.next != null) {\n            current = current.next;\n            steps--;\n        }\n        return current.url;\n      }\n    }\n    /**\n * Your BrowserHistory object will be instantiated and called as such:\n * BrowserHistory obj = new BrowserHistory(homepage);\n * obj.visit(url);\n * String param_2 = obj.back(steps);\n * String param_3 = obj.forward(steps);\n */"
    }
  },
  "1473": {
    "solution": {
      "dynamic-programming": "class Solution {\n    public int minCost(int[] houses, int[][] cost, int m, int n, int target) {\n        final int INF = (int)1e9;\n        int[][][] dp = new int[m + 1][target + 1][n + 1];\n\n        for (int i = 0; i <= m; i++)\n            for (int j = 0; j <= target; j++)\n                Arrays.fill(dp[i][j], INF);\n\n        dp[0][0][0] = 0;\n\n        for (int i = 1; i <= m; i++) {\n            for (int k = 1; k <= target; k++) {\n                for (int c = 1; c <= n; c++) {\n                    if (houses[i - 1] != 0 && houses[i - 1] != c) continue;\n                    int currentCost = (houses[i - 1] == 0) ? cost[i - 1][c - 1] : 0;\n                    for (int prevColor = 0; prevColor <= n; prevColor++) {\n                        if (prevColor == c) {\n                            dp[i][k][c] = Math.min(dp[i][k][c], dp[i - 1][k][prevColor] + currentCost);\n                        } else {\n                            dp[i][k][c] = Math.min(dp[i][k][c], dp[i - 1][k - 1][prevColor] + currentCost);\n                        }\n                    }\n                }\n            }\n        }\n\n        int result = INF;\n        for (int c = 1; c <= n; c++) {\n            result = Math.min(result, dp[m][target][c]);\n        }\n        return result == INF ? -1 : result;\n    }\n}"
    }
  },
  "1474": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode deleteNodes(ListNode head, int m, int n) {\n        ListNode pre = head;\n        while (pre != null) {\n            for (int i = 0; i < m - 1 && pre != null; ++i) {\n                pre = pre.next;\n            }\n            if (pre == null) {\n                return head;\n            }\n            ListNode cur = pre;\n            for (int i = 0; i < n && cur != null; ++i) {\n                cur = cur.next;\n            }\n            pre.next = cur == null ? null : cur.next;\n            pre = pre.next;\n        }\n        return head;\n    }\n}"
    }
  },
  "1475": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1476": {
    "solution": {
      "matrix": ""
    }
  },
  "1477": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minSumOfLengths(int[] arr, int target) {\n        int n = arr.length;\n        int[] minLength = new int[n];\n        Arrays.fill(minLength, Integer.MAX_VALUE);\n        \n        int left = 0, currSum = 0, minLen = Integer.MAX_VALUE, result = Integer.MAX_VALUE;\n\n        for (int right = 0; right < n; ++right) {\n            currSum += arr[right];\n\n            while (currSum > target) {\n                currSum -= arr[left++];\n            }\n\n            if (currSum == target) {\n                int currLen = right - left + 1;\n                if (left > 0 && minLength[left - 1] != Integer.MAX_VALUE) {\n                    result = Math.min(result, currLen + minLength[left - 1]);\n                }\n                minLen = Math.min(minLen, currLen);\n            }\n\n            minLength[right] = minLen;\n        }\n\n        return result == Integer.MAX_VALUE ? -1 : result;\n    }\n}\n"
    }
  },
  "1478": {
    "solution": {
      "dynamic-programming": "import java.util.*;\n\nclass Solution {\n    public int minDistance(int[] houses, int k) {\n        int n = houses.length;\n        Arrays.sort(houses);\n\n        int[][] cost = new int[n][n];\n        for (int i = 0; i < n; ++i) {\n            for (int j = i; j < n; ++j) {\n                int median = houses[(i + j) / 2];\n                for (int l = i; l <= j; ++l) {\n                    cost[i][j] += Math.abs(houses[l] - median);\n                }\n            }\n        }\n\n        int[][] dp = new int[n + 1][k + 1];\n        for (int[] row : dp) {\n            Arrays.fill(row, Integer.MAX_VALUE);\n        }\n        dp[0][0] = 0;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j = 1; j <= k; ++j) {\n                for (int p = 0; p < i; ++p) {\n                    if (dp[p][j - 1] != Integer.MAX_VALUE) {\n                        dp[i][j] = Math.min(dp[i][j], dp[p][j - 1] + cost[p][i - 1]);\n                    }\n                }\n            }\n        }\n\n        return dp[n][k];\n    }\n}"
    }
  },
  "1479": {
    "solution": {
      "database": ""
    }
  },
  "1480": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int[] runningSum(int[] nums) {\n        int n = nums.length;\n        int[] runningSum = new int[n];\n        runningSum[0] = nums[0]; \n        \n        for (int i = 1; i < n; i++) {\n            runningSum[i] = runningSum[i - 1] + nums[i];\n        }\n        \n        return runningSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        int[] result1 = solution.runningSum(new int[]{1, 2, 3, 4});\n        System.out.println(java.util.Arrays.toString(result1)); // Output: [1, 3, 6, 10]\n\n        int[] result2 = solution.runningSum(new int[]{1, 1, 1, 1, 1});\n        System.out.println(java.util.Arrays.toString(result2)); // Output: [1, 2, 3, 4, 5]\n\n        int[] result3 = solution.runningSum(new int[]{3, 1, 2, 10, 1});\n        System.out.println(java.util.Arrays.toString(result3)); // Output: [3, 4, 6, 16, 17]\n    }\n}\n"
    }
  },
  "1481": {
    "solution": {
      "counting": ""
    }
  },
  "1482": {
    "solution": {
      "array": ""
    }
  },
  "1483": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1484": {
    "solution": {
      "database": ""
    }
  },
  "1485": {
    "solution": {
      "tree": ""
    }
  },
  "1486": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1487": {
    "solution": {
      "hash-table": ""
    }
  },
  "1488": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1489": {
    "solution": {
      "minimum-spanning-tree": "import java.util.*;\n\nclass UnionFind {\n    private int[] parent;\n    private int[] rank;\n\n    public UnionFind(int n) {\n        parent = new int[n];\n        rank = new int[n];\n        for (int i = 0; i < n; ++i)\n            parent[i] = i;\n    }\n\n    public void unionByRank(int u, int v) {\n        int i = find(u);\n        int j = find(v);\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            parent[i] = j;\n        } else if (rank[i] > rank[j]) {\n            parent[j] = i;\n        } else {\n            parent[i] = j;\n            ++rank[j];\n        }\n    }\n\n    public int find(int u) {\n        return parent[u] == u ? u : (parent[u] = find(parent[u]));\n    }\n}\n\nclass Solution {\n    public List<List<Integer>> findCriticalAndPseudoCriticalEdges(int n, int[][] edges) {\n        List<Integer> criticalEdges = new ArrayList<>();\n        List<Integer> pseudoCriticalEdges = new ArrayList<>();\n\n        for (int i = 0; i < edges.length; ++i)\n            edges[i] = new int[] {edges[i][0], edges[i][1], edges[i][2], i};\n\n        Arrays.sort(edges, (a, b) -> a[2] - b[2]);\n\n        final int mstWeight = getMSTWeight(n, edges, new int[] {}, -1);\n\n        for (int[] edge : edges) {\n            final int index = edge[3];\n            // Deleting the `edge` increases the MST's weight or makes the MST invalid.\n            if (getMSTWeight(n, edges, new int[] {}, index) > mstWeight)\n                criticalEdges.add(index);\n            // If an edge can be in any MST, we can always add `edge` to the edge set.\n            else if (getMSTWeight(n, edges, edge, -1) == mstWeight)\n                pseudoCriticalEdges.add(index);\n        }\n\n        return new ArrayList<>(Arrays.asList(criticalEdges, pseudoCriticalEdges));\n    }\n\n    private int getMSTWeight(int n, int[][] edges, int[] firstEdge, int deletedEdgeIndex) {\n        int mstWeight = 0;\n        UnionFind uf = new UnionFind(n);\n\n        if (firstEdge.length == 4) {\n            uf.unionByRank(firstEdge[0], firstEdge[1]);\n            mstWeight += firstEdge[2];\n        }\n\n        for (int[] edge : edges) {\n            final int u = edge[0];\n            final int v = edge[1];\n            final int weight = edge[2];\n            final int index = edge[3];\n            if (index == deletedEdgeIndex)\n                continue;\n            if (uf.find(u) == uf.find(v))\n                continue;\n            uf.unionByRank(u, v);\n            mstWeight += weight;\n        }\n\n        final int root = uf.find(0);\n        for (int i = 0; i < n; ++i)\n            if (uf.find(i) != root)\n                return Integer.MAX_VALUE;\n\n        return mstWeight;\n    }\n\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        int n = 14;\n        int[][] edges = {\n            {0, 1, 13}, {0, 2, 6}, {2, 3, 13}, {3, 4, 4}, {0, 5, 11}, {4, 6, 14}, {4, 7, 8}, \n            {2, 8, 6}, {4, 9, 6}, {7, 10, 4}, {5, 11, 3}, {6, 12, 7}, {12, 13, 9}, {7, 13, 2}, \n            {5, 13, 10}, {0, 6, 4}, {2, 7, 3}, {0, 7, 8}, {1, 12, 9}, {10, 12, 11}, {1, 2, 7}, \n            {1, 3, 10}, {3, 10, 6}, {6, 10, 4}, {4, 8, 5}, {1, 13, 4}, {11, 13, 8}, {2, 12, 10}, \n            {5, 8, 1}, {3, 7, 6}, {7, 12, 12}, {1, 7, 9}, {5, 9, 1}, {2, 13, 10}, {10, 11, 4}, \n            {3, 5, 10}, {6, 11, 14}, {5, 12, 3}, {0, 8, 13}, {8, 9, 1}, {3, 6, 8}, {0, 3, 4}, \n            {2, 9, 6}, {0, 11, 4}, {2, 5, 14}, {4, 11, 2}, {7, 11, 11}, {1, 11, 6}, {2, 10, 12}, \n            {0, 13, 4}, {3, 9, 9}, {4, 12, 3}, {6, 7, 10}, {6, 8, 13}, {9, 11, 3}, {1, 6, 2}, \n            {2, 4, 12}, {0, 10, 3}, {3, 12, 1}, {3, 8, 12}, {1, 8, 6}, {8, 13, 2}, {10, 13, 12}, \n            {9, 13, 11}, {2, 11, 14}, {5, 10, 9}, {5, 6, 10}, {2, 6, 9}, {8, 11, 3}\n        };\n        List<List<Integer>> result = sol.findCriticalAndPseudoCriticalEdges(n, edges);\n        System.out.println(result); \n    }\n}\n"
    }
  },
  "1490": {
    "solution": {
      "tree": ""
    }
  },
  "1491": {
    "solution": {
      "sorting": ""
    }
  },
  "1492": {
    "solution": {
      "number-theory": "import java.util.*;\n\nclass Solution {\n    public int kthFactor(int n, int k) {\n        List<Integer> factors = new ArrayList<>();\n\n        for (int i = 1; i <= Math.sqrt(n); ++i) {\n            if (n % i == 0) {\n                factors.add(i);\n                if (i != n / i) {\n                    factors.add(n / i);\n                }\n            }\n        }\n\n        Collections.sort(factors);\n\n        return k > factors.size() ? -1 : factors.get(k - 1);\n    }\n}"
    }
  },
  "1493": {
    "solution": {
      "sliding-window": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int left = 0;\n        int zeroCount = 0;\n        int maxLength = 0;\n\n        for (int right = 0; right < nums.length; right++) {\n            if (nums[right] == 0) {\n                zeroCount++;\n            }\n\n            while (zeroCount > 1) {\n                if (nums[left] == 0) {\n                    zeroCount--;\n                }\n                left++;\n            }\n\n            maxLength = Math.max(maxLength, right - left);\n        }\n\n        return maxLength;\n    }\n}\n"
    }
  },
  "1494": {
    "solution": {
      "graph": "import java.util.*;\n\nclass Solution {\n    public int minNumberOfSemesters(int n, int[][] relations, int k) {\n        int[] prerequisites = new int[n];\n        for (int[] rel : relations) {\n            prerequisites[rel[1] - 1] |= (1 << (rel[0] - 1));\n        }\n\n        int size = 1 << n;\n        int[] dp = new int[size];\n        Arrays.fill(dp, n);\n        dp[0] = 0;\n\n        for (int mask = 0; mask < size; mask++) {\n            int available = 0;\n            for (int i = 0; i < n; i++) {\n                if ((mask & (1 << i)) == 0 && (mask & prerequisites[i]) == prerequisites[i]) {\n                    available |= (1 << i);\n                }\n            }\n\n            for (int sub = available; sub > 0; sub = (sub - 1) & available) {\n                if (Integer.bitCount(sub) <= k) {\n                    dp[mask | sub] = Math.min(dp[mask | sub], dp[mask] + 1);\n                }\n            }\n        }\n\n        return dp[size - 1];\n    }\n}"
    }
  },
  "1495": {
    "solution": {
      "database": ""
    }
  },
  "1496": {
    "solution": {
      "hash-table": ""
    }
  },
  "1497": {
    "solution": {
      "counting": ""
    }
  },
  "1498": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1499": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int findMaxValueOfEquation(int[][] points, int k) {\n        Deque<int[]> deque = new LinkedList<>();\n        int maxValue = Integer.MIN_VALUE;\n\n        for (int[] point : points) {\n            int xj = point[0];\n            int yj = point[1];\n\n            while (!deque.isEmpty() && xj - deque.peekFirst()[0] > k) {\n                deque.pollFirst();\n            }\n\n            if (!deque.isEmpty()) {\n                maxValue = Math.max(maxValue, yj + xj + deque.peekFirst()[1]);\n            }\n\n            while (!deque.isEmpty() && yj - xj >= deque.peekLast()[1]) {\n                deque.pollLast();\n            }\n\n            deque.offerLast(new int[]{xj, yj - xj});\n        }\n\n        return maxValue;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points = {{1, 3}, {2, 0}, {3, 10}, {4, 10}, {5, 1}};\n        int k = 1;\n        System.out.println(solution.findMaxValueOfEquation(points, k));  // Output: 14\n    }\n}\n"
    }
  },
  "1500": {
    "solution": {
      "design": "class FileSharing {\n    private int chunks; // Total number of chunks\n    private int cur; // Current user ID counter\n    private TreeSet<Integer> reused; // Reusable user IDs\n    private TreeMap<Integer, Set<Integer>> userChunks; // Mapping of user IDs to the chunks they own\n\n    public FileSharing(int m) {\n        cur = 0;\n        chunks = m;\n        reused = new TreeSet<>();\n        userChunks = new TreeMap<>();\n    }\n\n    // Adds a new user and assigns them their owned chunks\n    public int join(List<Integer> ownedChunks) {\n        int userID;\n        if (reused.isEmpty()) {\n            ++cur;\n            userID = cur;\n        } else {\n            userID = reused.pollFirst(); // Use the smallest available reused ID\n        }\n        userChunks.put(userID, new HashSet<>(ownedChunks));\n        return userID;\n    }\n\n    // Removes a user and makes their ID available for reuse\n    public void leave(int userID) {\n        reused.add(userID);\n        userChunks.remove(userID);\n    }\n\n    // Handles a request for a specific chunk by a user\n    public List<Integer> request(int userID, int chunkID) {\n        if (chunkID < 1 || chunkID > chunks) {\n            return Collections.emptyList(); // Return empty if chunkID is out of bounds\n        }\n\n        List<Integer> res = new ArrayList<>();\n        for (Map.Entry<Integer, Set<Integer>> entry : userChunks.entrySet()) {\n            if (entry.getValue().contains(chunkID)) {\n                res.add(entry.getKey());\n            }\n        }\n\n        // If chunk is found, add it to the requester's owned chunks\n        if (!res.isEmpty()) {\n            userChunks.computeIfAbsent(userID, k -> new HashSet<>()).add(chunkID);\n        }\n\n        return res;\n    }\n}\n\n/**\n * Your FileSharing object will be instantiated and called as such:\n * FileSharing obj = new FileSharing(m);\n * int param_1 = obj.join(ownedChunks);\n * obj.leave(userID);\n * List<Integer> param_3 = obj.request(userID,chunkID);\n */"
    }
  },
  "1501": {
    "solution": {
      "database": ""
    }
  },
  "1502": {
    "solution": {
      "sorting": ""
    }
  },
  "1503": {
    "solution": {
      "brainteaser": ""
    }
  },
  "1504": {
    "solution": {
      "matrix": "class Solution {\n    public int numSubmat(int[][] mat) {\n        int m = mat.length;\n        int n = mat[0].length;\n        int ans = 0;\n        int[] hist = new int[n];\n\n        for (int[] row : mat) {\n            for (int i = 0; i < row.length; ++i)\n                hist[i] = row[i] == 0 ? 0 : hist[i] + 1;\n            ans += count(hist);\n        }\n\n        return ans;\n    }\n\n    private int count(int[] nums) {\n        int[] submatrices = new int[nums.length];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; ++i) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i])\n                stack.pop();\n            if (!stack.isEmpty()) {\n                int prevIndex = stack.peek();\n                submatrices[i] = submatrices[prevIndex] + nums[i] * (i - prevIndex);\n            } else {\n                submatrices[i] = nums[i] * (i + 1);\n            }\n            stack.push(i);\n        }\n\n        return Arrays.stream(submatrices).sum();\n    }\n}"
    }
  },
  "1505": {
    "solution": {
      "greedy": ""
    }
  },
  "1506": {
    "solution": {
      "tree": "import java.util.*;\n\nclass Node {\n    public int val;\n    public List<Node> children;\n\n    public Node() {}\n\n    public Node(int val) {\n        this.val = val;\n        this.children = new ArrayList<>();\n    }\n\n    public Node(int val, List<Node> children) {\n        this.val = val;\n        this.children = children;\n    }\n}\n\nclass Solution {\n    public Node findRoot(List<Node> tree) {\n        int x = 0;\n        for (Node node : tree) {\n            x ^= node.val;\n            for (Node child : node.children) {\n                x ^= child.val;\n            }\n        }\n        for (Node node : tree) {\n            if (node.val == x) {\n                return node;\n            }\n        }\n        return null; // Should never happen per problem constraints\n    }\n}"
    }
  },
  "1507": {
    "solution": {
      "string": ""
    }
  },
  "1508": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1509": {
    "solution": {
      "greedy": ""
    }
  },
  "1510": {
    "solution": {
      "game-theory": "class Solution {\n    public boolean winnerSquareGame(int n) {\n        boolean[] dp = new boolean[n + 1];\n\n        for (int i = 1; i <= n; ++i) {\n            for (int k = 1; k * k <= i; ++k) {\n                if (!dp[i - k * k]) {\n                    dp[i] = true;\n                    break;\n                }\n            }\n        }\n\n        return dp[n];\n    }\n}"
    }
  },
  "1511": {
    "solution": {
      "database": ""
    }
  },
  "1512": {
    "solution": {
      "counting": "import java.util.*;\n\nclass Solution {\n    public int numIdenticalPairs(int[] nums) {\n        Map<Integer, Integer> freq = new HashMap<>();\n        int count = 0;\n\n        for (int num : nums) {\n            count += freq.getOrDefault(num, 0);\n            freq.put(num, freq.getOrDefault(num, 0) + 1);\n        }\n\n        return count;\n    }\n}"
    }
  },
  "1513": {
    "solution": {
      "math": ""
    }
  },
  "1514": {
    "solution": {
      "shortest-path": "#include <vector>\n#include <queue>\n#include <unordered_map>\n#include <utility>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    double maxProbability(int n, vector<vector<int>>& edges, vector<double>& succProb, int start_node, int end_node) {\n        vector<vector<pair<int, double>>> graph(n);\n        for (int i = 0; i < edges.size(); ++i) {\n            int u = edges[i][0];\n            int v = edges[i][1];\n            double prob = succProb[i];\n            graph[u].emplace_back(v, prob);\n            graph[v].emplace_back(u, prob);\n        }\n\n        priority_queue<pair<double, int>> pq;\n        pq.push({1.0, start_node}); // Start with a probability of 1 at the start_node\n\n        vector<double> probabilities(n, 0.0);\n        probabilities[start_node] = 1.0;\n\n        while (!pq.empty()) {\n            auto [curr_prob, curr_node] = pq.top();\n            pq.pop();\n\n            // If we reach the end_node, return the probability\n            if (curr_node == end_node) {\n                return curr_prob;\n            }\n\n            // If the current probability is less than the recorded probability, skip processing\n            if (curr_prob < probabilities[curr_node]) {\n                continue;\n            }\n\n            // Explore neighbors\n            for (auto& [neighbor, edge_prob] : graph[curr_node]) {\n                double new_prob = curr_prob * edge_prob;\n                if (new_prob > probabilities[neighbor]) {\n                    probabilities[neighbor] = new_prob;\n                    pq.push({new_prob, neighbor});\n                }\n            }\n        }\n\n        // If the end_node is not reachable, return 0\n        return 0.0;\n    }\n};\n"
    }
  },
  "1515": {
    "solution": {
      "randomized": "class Solution {\n    public double getMinDistSum(int[][] positions) {\n        int n = positions.length;\n        double x = 0, y = 0;\n        for (int[] p : positions) {\n            x += p[0];\n            y += p[1];\n        }\n        x /= n;\n        y /= n;\n        double decay = 0.999;\n        double eps = 1e-6;\n        double alpha = 0.5;\n        while (true) {\n            double gradX = 0, gradY = 0;\n            double dist = 0;\n            for (int[] p : positions) {\n                double a = x - p[0], b = y - p[1];\n                double c = Math.sqrt(a * a + b * b);\n                gradX += a / (c + 1e-8);\n                gradY += b / (c + 1e-8);\n                dist += c;\n            }\n            double dx = gradX * alpha, dy = gradY * alpha;\n            if (Math.abs(dx) <= eps && Math.abs(dy) <= eps) {\n                return dist;\n            }\n            x -= dx;\n            y -= dy;\n            alpha *= decay;\n        }\n    }\n}"
    }
  },
  "1516": {
    "solution": {
      "tree": ""
    }
  },
  "1517": {
    "solution": {
      "database": ""
    }
  },
  "1518": {
    "solution": {
      "math": "class Solution {\npublic:\n    int numWaterBottles(int numBottles, int numExchange) {\n        int totalDrinks = numBottles; \n        int emptyBottles = numBottles; \n\n        while (emptyBottles >= numExchange) {\n            int newBottles = emptyBottles / numExchange;\n            totalDrinks += newBottles; \n            emptyBottles = emptyBottles % numExchange + newBottles; \n        }\n\n        return totalDrinks;\n    }\n};\n"
    }
  },
  "1519": {
    "solution": {
      "tree": ""
    }
  },
  "1520": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    vector<string> maxNumOfSubstrings(string s) {\n        const int n = s.length();\n        vector<string> ans;\n        // leftmost[i] := the leftmost index of ('a' + i)\n        vector<int> leftmost(26, n);\n        // rightmost[i] := the rightmost index of ('a' + i)\n        vector<int> rightmost(26, -1);\n\n        for (int i = 0; i < n; ++i) {\n            leftmost[s[i] - 'a'] = min(leftmost[s[i] - 'a'], i);\n            rightmost[s[i] - 'a'] = i;\n        }\n\n        auto getNewRight = [&](int i) {\n            int right = rightmost[s[i] - 'a'];\n            for (int j = i; j <= right; ++j) {\n                if (leftmost[s[j] - 'a'] <\n                    i) // Find a letter's leftmost index < i.\n                    return -1;\n                right = max(right, rightmost[s[j] - 'a']);\n            }\n            return right;\n        };\n\n        int right = -1; // the rightmost index of the last substring\n        for (int i = 0; i < n; ++i) {\n            if (i == leftmost[s[i] - 'a']) {\n                const int newRight = getNewRight(i);\n                if (newRight == -1)\n                    continue; // Find a letter's leftmost index < i.\n                if (i <= right && !ans.empty())\n                    ans.back() = s.substr(i, newRight - i + 1);\n                else\n                    ans.push_back(s.substr(i, newRight - i + 1));\n                right = newRight;\n            }\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "1521": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1522": {
    "solution": {
      "tree": "/*\n// Definition for a Node.\nclass Node {\npublic:\n    int val;\n    vector<Node*> children;\n\n    Node() {}\n\n    Node(int _val) {\n        val = _val;\n    }\n\n    Node(int _val, vector<Node*> _children) {\n        val = _val;\n        children = _children;\n    }\n};\n*/\n\nclass Solution {\npublic:\n    int ans;\n\n    int diameter(Node* root) {\n        ans = 0;\n        dfs(root);\n        return ans;\n    }\n\n    int dfs(Node* root) {\n        if (!root) return 0;\n        int m1 = 0, m2 = 0;\n        for (Node* child : root->children) {\n            int t = dfs(child);\n            if (t > m1) {\n                m2 = m1;\n                m1 = t;\n            } else if (t > m2)\n                m2 = t;\n        }\n        ans = max(ans, m1 + m2);\n        return 1 + m1;\n    }\n};"
    }
  },
  "1523": {
    "solution": {
      "math": "class Solution {\n public:\n  int countOdds(int low, int high) {\n    return (high + 1) / 2 - low / 2;\n  }\n};\n"
    }
  },
  "1524": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1525": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1526": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1527": {
    "solution": {
      "database": ""
    }
  },
  "1528": {
    "solution": {
      "string": ""
    }
  },
  "1529": {
    "solution": {
      "greedy": ""
    }
  },
  "1530": {
    "solution": {
      "tree": ""
    }
  },
  "1531": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1532": {
    "solution": {
      "database": ""
    }
  },
  "1533": {
    "solution": {
      "interactive": "/**\n * // This is the ArrayReader's API interface.\n * // You should not implement it, or speculate about its implementation\n * class ArrayReader {\n *   public:\n *     // Compares the sum of arr[l..r] with the sum of arr[x..y]\n *     // return 1 if sum(arr[l..r]) > sum(arr[x..y])\n *     // return 0 if sum(arr[l..r]) == sum(arr[x..y])\n *     // return -1 if sum(arr[l..r]) < sum(arr[x..y])\n *     int compareSub(int l, int r, int x, int y);\n *\n *     // Returns the length of the array\n *     int length();\n * };\n */\n\nclass Solution {\npublic:\n    int getIndex(ArrayReader& reader) {\n        int left = 0, right = reader.length() - 1;\n        while (left < right) {\n            int t1 = left, t2 = left + (right - left) / 3, t3 = left + (right - left) / 3 * 2 + 1;\n            int cmp = reader.compareSub(t1, t2, t2 + 1, t3);\n            if (cmp == 0) {\n                left = t3 + 1;\n            } else if (cmp == 1) {\n                right = t2;\n            } else {\n                left = t2 + 1;\n                right = t3;\n            }\n        }\n        return left;\n    }\n};"
    }
  },
  "1534": {
    "solution": {
      "enumeration": ""
    }
  },
  "1535": {
    "solution": {
      "array": ""
    }
  },
  "1536": {
    "solution": {
      "matrix": ""
    }
  },
  "1537": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1538": {
    "solution": {
      "interactive": ""
    }
  },
  "1539": {
    "solution": {
      "array": "",
      "binary-search": "class Solution {\npublic:\n  int findKthPositive(vector<int>& nums, int k) {\n    int left = 0;\n    int right = nums.size();\n\n    while (left < right) {\n      const int mid = (left + right) / 2;\n      if (nums[mid] - mid - 1 >= k)\n        right = mid;\n      else\n        left = mid + 1;\n    }\n\n    // The k-th missing positive number\n    // = nums[left - 1] + k - nMissing(left - 1)\n    // = nums[left - 1] + k - (nums[left - 1] - (left - 1) - 1)\n    // = nums[left - 1] + k - (nums[left - 1] - left)\n    // = left + k\n    return left + k;\n  }\n};\n"
    }
  },
  "1540": {
    "solution": {
      "hash-table": ""
    }
  },
  "1541": {
    "solution": {
      "stack": ""
    }
  },
  "1542": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1543": {
    "solution": {
      "database": ""
    }
  },
  "1544": {
    "solution": {
      "stack": ""
    }
  },
  "1545": {
    "solution": {
      "recursion": ""
    }
  },
  "1546": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1547": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1548": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1549": {
    "solution": {
      "database": ""
    }
  },
  "1550": {
    "solution": {
      "array": ""
    }
  },
  "1551": {
    "solution": {
      "math": "class Solution {\npublic:\n    int minOperations(int n) {\n        //     median := median of arr\n        //   diffs[i] := median - arr[i] where i <= i <= n / 2\n        //        ans := sum(diffs)\n        // e.g.\n        // n = 5, arr = [1, 3, 5, 7, 9], diffs = [4, 2]\n        //        ans = (4 + 2) * 2 / 2 = 6\n        // n = 6, arr = [1, 3, 5, 7, 9, 11], diffs = [5, 3, 1]\n        //        ans = (5 + 1) * 3 / 2 = 9\n        const int halfSize = n / 2;\n        const int median = (arr(n) + arr(1)) / 2;\n        const int firstDiff = median - arr(1);\n        const int lastDiff = median - arr(halfSize);\n        return (firstDiff + lastDiff) * halfSize / 2;\n    }\n\nprivate:\n    // Returns the i-th element of `arr`, where 1 <= i <= n.\n    int arr(int i) { return (i - 1) * 2 + 1; }\n};\n"
    }
  },
  "1552": {
    "solution": {
      "sorting": ""
    }
  },
  "1553": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1554": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "1555": {
    "solution": {
      "database": ""
    }
  },
  "1556": {
    "solution": {
      "string": ""
    }
  },
  "1557": {
    "solution": {
      "graph": ""
    }
  },
  "1558": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1559": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    bool containsCycle(vector<vector<char>>& grid) {\n        int m = grid.size();\n        int n = grid[0].size();\n        \n        // Directions for up, right, down, left\n        int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};\n        \n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        \n        function<bool(int, int, int, int)> dfs = [&](int i, int j, int prev_i, int prev_j) {\n            visited[i][j] = true;\n\n            for (auto& dir : dirs) {\n                int new_i = i + dir[0];\n                int new_j = j + dir[1];\n\n                if (new_i >= 0 && new_i < m && new_j >= 0 && new_j < n && grid[new_i][new_j] == grid[i][j]) {\n                    if (!visited[new_i][new_j]) {\n                        if (dfs(new_i, new_j, i, j)) {\n                            return true; // Cycle found\n                        }\n                    } else if (new_i != prev_i || new_j != prev_j) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (!visited[i][j]) {\n                    if (dfs(i, j, -1, -1)) {\n                        return true; \n                    }\n                }\n            }\n        }\n\n        return false;\n    }\n};\n"
    }
  },
  "1560": {
    "solution": {
      "array": ""
    }
  },
  "1561": {
    "solution": {
      "game-theory": ""
    }
  },
  "1562": {
    "solution": {
      "array": ""
    }
  },
  "1563": {
    "solution": {
      "game-theory": ""
    }
  },
  "1564": {
    "solution": {
      "greedy": ""
    }
  },
  "1565": {
    "solution": {
      "database": ""
    }
  },
  "1566": {
    "solution": {
      "enumeration": ""
    }
  },
  "1567": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1568": {
    "solution": {
      "strongly-connected-component": "class Solution {\n\n    private final int[][] dirs = { { 0, 1 }, { 1, 0 }, { 0, -1 }, { -1, 0 } };\n\n    public int minDays(int[][] grid) {\n        if (disconnected(grid))\n            return 0;\n\n        // Try to remove 1 land.\n        for (int i = 0; i < grid.length; ++i)\n            for (int j = 0; j < grid[0].length; ++j)\n                if (grid[i][j] == 1) {\n                    grid[i][j] = 0;\n                    if (disconnected(grid))\n                        return 1;\n                    grid[i][j] = 1;\n                }\n\n        // Remove 2 lands.\n        return 2;\n    }\n\n    private boolean disconnected(int[][] grid) {\n        int islandsCount = 0;\n        boolean[][] seen = new boolean[grid.length][grid[0].length];\n        for (int i = 0; i < grid.length; ++i)\n            for (int j = 0; j < grid[0].length; ++j) {\n                if (grid[i][j] == 0 || seen[i][j])\n                    continue;\n                if (++islandsCount > 1)\n                    return true;\n                dfs(grid, i, j, seen);\n            }\n\n        return islandsCount != 1;\n    }\n\n    private void dfs(int[][] grid, int i, int j, boolean[][] seen) {\n        seen[i][j] = true;\n        for (int[] dir : dirs) {\n            int x = i + dir[0];\n            int y = j + dir[1];\n            if (x < 0 || x == grid.length || y < 0 || y == grid[0].length)\n                continue;\n            if (grid[x][y] == 0 || seen[x][y])\n                continue;\n            dfs(grid, x, y, seen);\n        }\n    }\n}\n"
    }
  },
  "1569": {
    "solution": {
      "combinatorics": "#include <algorithm>\n#include <iostream>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    static constexpr int MOD = 1e9 + 7;\n\n    int numOfWays(vector<int>& nums) {\n        int n = nums.size();\n        comb.resize(n + 1, vector<int>(n + 1, 0));\n        precomputeCombinations(n);\n        return (dfs(nums) - 1 + MOD) %\n               MOD; // Subtract 1 because the original order is not counted\n    }\n\nprivate:\n    vector<vector<int>> comb;\n\n    // Precompute binomial coefficients (Pascal's Triangle)\n    void precomputeCombinations(int n) {\n        for (int i = 0; i <= n; ++i) {\n            comb[i][0] = comb[i][i] = 1;\n            for (int j = 1; j < i; ++j) {\n                comb[i][j] = (comb[i - 1][j - 1] + comb[i - 1][j]) % MOD;\n            }\n        }\n    }\n\n    int dfs(const vector<int>& nums) {\n        if (nums.size() <= 2)\n            return 1; // Base case: only 0 or 1 reorderings possible\n\n        vector<int> left, right;\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] < nums[0])\n                left.push_back(nums[i]);\n            else\n                right.push_back(nums[i]);\n        }\n\n        long long leftWays = dfs(left);\n        long long rightWays = dfs(right);\n        long long mergeWays = comb[nums.size() - 1][left.size()];\n        return leftWays * rightWays % MOD * mergeWays % MOD;\n    }\n};\n"
    }
  },
  "1570": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1571": {
    "solution": {
      "database": ""
    }
  },
  "1572": {
    "solution": {
      "matrix": ""
    }
  },
  "1573": {
    "solution": {
      "math": ""
    }
  },
  "1574": {
    "solution": {
      "two-pointers": "class Solution {\n    public int findLengthOfShortestSubarray(int[] arr) {\n        int n = arr.length;\n        int left = 0, right = n - 1;\n        \n        while (left < n - 1 && arr[left] <= arr[left + 1]) {\n            left++;\n        }\n        \n        if (left == n - 1) {\n            return 0;\n        }\n        \n        while (right > 0 && arr[right - 1] <= arr[right]) {\n            right--;\n        }\n        \n        int minRemove = Math.min(n - left - 1, right);        \n        int i = 0, j = right;\n        while (i <= left && j < n) {\n            if (arr[i] <= arr[j]) {\n                minRemove = Math.min(minRemove, j - i - 1);\n                i++;\n            } else {\n                j++;\n            }\n        }\n        \n        return minRemove;\n    }\n}\n"
    }
  },
  "1575": {
    "solution": {
      "memoization": "class Solution {\npublic:\n    int countRoutes(vector<int>& locations, int start, int finish, int fuel) {\n        int n = locations.size();\n        vector<vector<int>> dp(n,\n                               vector<int>(fuel + 1, -1)); // Memoization table\n        return helper(locations, start, finish, fuel, dp);\n    }\n\nprivate:\n    const int MOD = 1e9 + 7;\n\n    int helper(vector<int>& locations, int current, int finish, int fuel,\n               vector<vector<int>>& dp) {\n        if (fuel < 0)\n            return 0; // If fuel is exhausted, no routes possible\n\n        if (dp[current][fuel] != -1)\n            return dp[current][fuel]; // Return cached result\n\n        int routes =\n            (current == finish)\n                ? 1\n                : 0; // Include current as a valid route if it's the finish\n\n        for (int next = 0; next < locations.size(); ++next) {\n            if (next != current) {\n                int cost = abs(locations[current] -\n                               locations[next]); // Fuel cost to travel\n                if (fuel >= cost) {              // Travel if enough fuel\n                    routes = (routes + helper(locations, next, finish,\n                                              fuel - cost, dp)) %\n                             MOD;\n                }\n            }\n        }\n\n        return dp[current][fuel] = routes; // Cache and return the result\n    }\n};\n"
    }
  },
  "1576": {
    "solution": {
      "string": ""
    }
  },
  "1577": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1578": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minCost(string colors, vector<int>& neededTime) {\n        int totalCost = 0;\n        int maxTimeInGroup = 0;\n\n        for (int i = 0; i < colors.size(); ++i) {\n            // If the current balloon is different from the previous one\n            // or it's the first balloon, reset maxTimeInGroup.\n            if (i > 0 && colors[i] != colors[i - 1]) {\n                maxTimeInGroup = 0;\n            }\n\n            totalCost += min(maxTimeInGroup, neededTime[i]);\n\n            maxTimeInGroup = max(maxTimeInGroup, neededTime[i]);\n        }\n\n        return totalCost;\n    }\n};\n"
    }
  },
  "1579": {
    "solution": {
      "union-find": ""
    }
  },
  "1580": {
    "solution": {
      "greedy": ""
    }
  },
  "1581": {
    "solution": {
      "database": ""
    }
  },
  "1582": {
    "solution": {
      "matrix": ""
    }
  },
  "1583": {
    "solution": {
      "array": ""
    }
  },
  "1584": {
    "solution": {
      "minimum-spanning-tree": "import java.util.*;\n\nclass Solution {\n    class Edge {\n        int u, v, cost;\n        Edge(int u, int v, int cost) {\n            this.u = u;\n            this.v = v;\n            this.cost = cost;\n        }\n    }\n\n    class UnionFind {\n        int[] parent, rank;\n\n        UnionFind(int n) {\n            parent = new int[n];\n            rank = new int[n];\n            for (int i = 0; i < n; i++) {\n                parent[i] = i;\n                rank[i] = 0;\n            }\n        }\n\n        int find(int x) {\n            if (parent[x] != x) {\n                parent[x] = find(parent[x]);\n            }\n            return parent[x];\n        }\n\n        boolean union(int x, int y) {\n            int rootX = find(x);\n            int rootY = find(y);\n            if (rootX != rootY) {\n                if (rank[rootX] > rank[rootY]) {\n                    parent[rootY] = rootX;\n                } else if (rank[rootX] < rank[rootY]) {\n                    parent[rootX] = rootY;\n                } else {\n                    parent[rootY] = rootX;\n                    rank[rootX]++;\n                }\n                return true;\n            }\n            return false;\n        }\n    }\n\n    public int minCostConnectPoints(int[][] points) {\n        int n = points.length;\n        List<Edge> edges = new ArrayList<>();\n\n        // Create all possible edges with their costs\n        for (int i = 0; i < n; i++) {\n            for (int j = i + 1; j < n; j++) {\n                int cost = Math.abs(points[i][0] - points[j][0]) + Math.abs(points[i][1] - points[j][1]);\n                edges.add(new Edge(i, j, cost));\n            }\n        }\n\n        // Sort edges by cost\n        edges.sort(Comparator.comparingInt(e -> e.cost));\n\n        // Kruskal's algorithm to find the MST\n        UnionFind uf = new UnionFind(n);\n        int minCost = 0, edgesUsed = 0;\n\n        for (Edge edge : edges) {\n            if (uf.union(edge.u, edge.v)) {\n                minCost += edge.cost;\n                edgesUsed++;\n                if (edgesUsed == n - 1) {\n                    break;\n                }\n            }\n        }\n\n        return minCost;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] points = { {0, 0}, {2, 2}, {3, 10}, {5, 2}, {7, 0} };\n        System.out.println(\"Minimum cost to connect all points: \" + solution.minCostConnectPoints(points));\n    }\n}\n"
    }
  },
  "1585": {
    "solution": {
      "greedy": ""
    }
  },
  "1586": {
    "solution": {
      "iterator": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass BSTIterator {\n    private List<Integer> nums = new ArrayList<>();\n    private int i = -1;\n\n    public BSTIterator(TreeNode root) {\n        dfs(root);\n    }\n\n    public boolean hasNext() {\n        return i < nums.size() - 1;\n    }\n\n    public int next() {\n        return nums.get(++i);\n    }\n\n    public boolean hasPrev() {\n        return i > 0;\n    }\n\n    public int prev() {\n        return nums.get(--i);\n    }\n\n    private void dfs(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        dfs(root.left);\n        nums.add(root.val);\n        dfs(root.right);\n    }\n}\n\n/**\n * Your BSTIterator object will be instantiated and called as such:\n * BSTIterator obj = new BSTIterator(root);\n * boolean param_1 = obj.hasNext();\n * int param_2 = obj.next();\n * boolean param_3 = obj.hasPrev();\n * int param_4 = obj.prev();\n */"
    }
  },
  "1587": {
    "solution": {
      "database": ""
    }
  },
  "1588": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int sumOddLengthSubarrays(int[] arr) {\n        int n = arr.length;\n        int[] prefixSum = new int[n + 1];\n        int totalSum = 0;\n        \n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + arr[i];\n        }\n        \n        for (int start = 0; start < n; start++) {\n            for (int end = start; end < n; end++) {\n                int length = end - start + 1;\n                if (length % 2 == 1) {\n                    totalSum += prefixSum[end + 1] - prefixSum[start];\n                }\n            }\n        }\n        \n        return totalSum;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        // Test cases\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{1, 4, 2, 5, 3})); // Output: 58\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{1, 2}));          // Output: 3\n        System.out.println(solution.sumOddLengthSubarrays(new int[]{10, 11, 12}));    // Output: 66\n    }\n}\n"
    }
  },
  "1589": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1590": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1591": {
    "solution": {
      "matrix": ""
    }
  },
  "1592": {
    "solution": {
      "string": ""
    }
  },
  "1593": {
    "solution": {
      "backtracking": ""
    }
  },
  "1594": {
    "solution": {
      "matrix": ""
    }
  },
  "1595": {
    "solution": {
      "matrix": ""
    }
  },
  "1596": {
    "solution": {
      "database": ""
    }
  },
  "1597": {
    "solution": {
      "stack": ""
    }
  },
  "1598": {
    "solution": {
      "stack": ""
    }
  },
  "1599": {
    "solution": {
      "array": ""
    }
  },
  "1600": {
    "solution": {
      "tree": ""
    }
  },
  "1601": {
    "solution": {
      "backtracking": ""
    }
  },
  "1602": {
    "solution": {
      "tree": ""
    }
  },
  "1603": {
    "solution": {
      "design": "class ParkingSystem {\nprivate:\n    int bigSlots;    // Number of available big parking slots\n    int mediumSlots; // Number of available medium parking slots\n    int smallSlots;  // Number of available small parking slots\n\npublic:\n    // Constructor to initialize the number of slots for each type\n    ParkingSystem(int big, int medium, int small) \n        : bigSlots(big), mediumSlots(medium), smallSlots(small) {}\n\n    // Method to add a car to the parking system\n    bool addCar(int carType) {\n        switch (carType) {\n            case 1: // Big car\n                if (bigSlots > 0) {\n                    bigSlots--;\n                    return true;\n                }\n                break;\n            case 2: // Medium car\n                if (mediumSlots > 0) {\n                    mediumSlots--;\n                    return true;\n                }\n                break;\n            case 3: // Small car\n                if (smallSlots > 0) {\n                    smallSlots--;\n                    return true;\n                }\n                break;\n            default:\n                return false; // Invalid car type\n        }\n        return false; // No available slot for the car type\n    }\n};\n\n/**\n * Your ParkingSystem object will be instantiated and called as such:\n * ParkingSystem* obj = new ParkingSystem(big, medium, small);\n * bool param_1 = obj->addCar(carType);\n */"
    }
  },
  "1604": {
    "solution": {
      "sorting": ""
    }
  },
  "1605": {
    "solution": {
      "matrix": "import java.util.Arrays;\n\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public int[][] restoreMatrix(int[] rowSum, int[] colSum) {\n        int rows = rowSum.length;\n        int cols = colSum.length;\n        int[][] matrix = new int[rows][cols];\n        boolean[][] visited = new boolean[rows][cols];\n        \n        dfs(matrix, rowSum, colSum, visited, 0, 0, rows, cols);\n        return matrix;\n    }\n\n    private boolean dfs(int[][] matrix, int[] rowSum, int[] colSum, boolean[][] visited, int i, int j, int rows, int cols) {\n        if (i >= rows || j >= cols || visited[i][j]) return true;\n\n        visited[i][j] = true;\n\n        int fillValue = Math.min(rowSum[i], colSum[j]);\n        matrix[i][j] = fillValue;\n        rowSum[i] -= fillValue;\n        colSum[j] -= fillValue;\n\n        for (int[] direction : DIRECTIONS) {\n            int ni = i + direction[0];\n            int nj = j + direction[1];\n\n            if (ni >= 0 && nj >= 0 && ni < rows && nj < cols && !visited[ni][nj]) {\n                if (!dfs(matrix, rowSum, colSum, visited, ni, nj, rows, cols)) {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solver = new Solution();\n        int[] rowSum = {3, 8};\n        int[] colSum = {4, 7};\n        \n        int[][] result = solver.restoreMatrix(rowSum, colSum);\n        for (int[] row : result) {\n            System.out.println(Arrays.toString(row));\n        }\n    }\n}\n"
    }
  },
  "1606": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1607": {
    "solution": {
      "database": ""
    }
  },
  "1608": {
    "solution": {
      "sorting": ""
    }
  },
  "1609": {
    "solution": {
      "breadth-first-search": "class Solution {\npublic:\n    bool isEvenOddTree(TreeNode* root) {\n        if (!root) return true;\n        \n        queue<TreeNode*> q;\n        q.push(root);\n        int level = 0; \n        \n        while (!q.empty()) {\n            int size = q.size();\n            int prevVal = (level % 2 == 0) ? INT_MIN : INT_MAX; // Initial value based on level\n            \n            for (int i = 0; i < size; ++i) {\n                TreeNode* node = q.front();\n                q.pop();\n                \n                int val = node->val;\n                \n                if (level % 2 == 0) {\n                    if (val % 2 == 0 || val <= prevVal) return false; // Odd values, strictly increasing\n                } \n                else {\n                    if (val % 2 != 0 || val >= prevVal) return false; // Even values, strictly decreasing\n                }\n                \n                prevVal = val; \n\n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            \n            level++;\n        }\n        \n        return true;\n    }\n};\n"
    }
  },
  "1610": {
    "solution": {
      "sliding-window": "import java.util.*;\n\nclass Solution {\n    public int visiblePoints(List<List<Integer>> points, int angle, List<Integer> location) {\n        int sameLocationCount = 0;\n        List<Double> angles = new ArrayList<>();\n\n        int x0 = location.get(0);\n        int y0 = location.get(1);\n\n        for (List<Integer> point : points) {\n            int x = point.get(0);\n            int y = point.get(1);\n\n            if (x == x0 && y == y0) {\n                sameLocationCount++;\n            } else {\n                double theta = Math.atan2(y - y0, x - x0) * (180 / Math.PI);\n                angles.add(theta);\n            }\n        }\n\n        Collections.sort(angles);\n\n        int m = angles.size();\n        for (int i = 0; i < m; i++) {\n            angles.add(angles.get(i) + 360);\n        }\n\n        int maxVisible = 0;\n        int left = 0;\n\n        for (int right = 0; right < angles.size(); right++) {\n            while (angles.get(right) - angles.get(left) > angle) {\n                left++;\n            }\n            maxVisible = Math.max(maxVisible, right - left + 1);\n        }\n\n        return maxVisible + sameLocationCount;\n    }\n}\n"
    }
  },
  "1611": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    int minimumOneBitOperations(int n) {\n        if (n == 0)\n            return 0;\n        int x = 1;\n        while (x * 2 <= n)\n            x <<= 1;\n        return minimumOneBitOperations(n ^ (x | x >> 1)) + 1 + x - 1;\n    }\n};"
    }
  },
  "1612": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct Node {\n *     char val;\n *     Node *left;\n *     Node *right;\n *     Node() : val(' '), left(nullptr), right(nullptr) {}\n *     Node(char x) : val(x), left(nullptr), right(nullptr) {}\n *     Node(char x, Node *left, Node *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkEquivalence(Node* root1, Node* root2) {\n        int count[26]{};\n        function<void(Node*, int)> dfs = [&](Node* root, int v) {\n            if (!root) {\n                return;\n            }\n            if (root->val != '+') {\n                count[root->val - 'a'] += v;\n            }\n            dfs(root->left, v);\n            dfs(root->right, v);\n        };\n        dfs(root1, 1);\n        dfs(root2, -1);\n        for (int& x : count) {\n            if (x) {\n                return false;\n            }\n        }\n        return true;\n    }\n};"
    }
  },
  "1613": {
    "solution": {
      "database": ""
    }
  },
  "1614": {
    "solution": {
      "string": "class Solution {\npublic:\n    int maxDepth(string s) {\n        int currentDepth = 0;\n        int maxDepth = 0;\n\n        for (char c : s) {\n            if (c == '(') {\n                currentDepth++;\n                maxDepth = max(maxDepth, currentDepth);\n            } else if (c == ')') {\n                currentDepth--;\n            }\n        }\n\n        return maxDepth;\n    }\n};\n"
    }
  },
  "1615": {
    "solution": {
      "graph": ""
    }
  },
  "1616": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1617": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1618": {
    "solution": {
      "interactive": ""
    }
  },
  "1619": {
    "solution": {
      "sorting": "class Solution {\npublic:\n    double trimMean(vector<int>& arr) {\n        int n = arr.size();\n        int removeCount = n / 20;  \n        \n        sort(arr.begin(), arr.end());\n        \n        double sum = 0;\n        for (int i = removeCount; i < n - removeCount; ++i) {\n            sum += arr[i];\n        }\n        \n        return sum / (n - 2 * removeCount);\n    }\n};\n"
    }
  },
  "1620": {
    "solution": {
      "enumeration": ""
    }
  },
  "1621": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1622": {
    "solution": {
      "design": ""
    }
  },
  "1623": {
    "solution": {
      "database": ""
    }
  },
  "1624": {
    "solution": {
      "hash-table": ""
    }
  },
  "1625": {
    "solution": {
      "enumeration": ""
    }
  },
  "1626": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1627": {
    "solution": {
      "union-find": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n\npublic:\n    vector<bool> areConnected(int n, int threshold,\n                              vector<vector<int>>& queries) {\n        parent.resize(n + 1);\n        for (int i = 1; i <= n; ++i) {\n            parent[i] = i;\n        }\n\n        for (int i = threshold + 1; i <= n; ++i) {\n            for (int j = 2 * i; j <= n; j += i) {\n                unionSets(i, j);\n            }\n        }\n\n        vector<bool> result;\n        for (const auto& query : queries) {\n            int u = query[0];\n            int v = query[1];\n            result.push_back(find(u) == find(v));\n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "1628": {
    "solution": {
      "design": "/**\n * This is the interface for the expression tree Node.\n * You should not remove it, and you can define some classes to implement it.\n */\n\nclass Node {\npublic:\n    virtual ~Node() {}\n    virtual int evaluate() const = 0;\n\nprotected:\n    string val;      // Node value (operator or operand)\n    Node* left;      // Left child node\n    Node* right;     // Right child node\n};\n\nclass MyNode : public Node {\npublic:\n    // Constructor for operand nodes\n    MyNode(const string& val) {\n        this->val = val;\n        this->left = nullptr;\n        this->right = nullptr;\n    }\n\n    // Constructor for operator nodes\n    MyNode(const string& val, Node* left, Node* right) {\n        this->val = val;\n        this->left = left;\n        this->right = right;\n    }\n\n    // Evaluate the expression tree rooted at this node\n    int evaluate() const override {\n        // If the node is an operand, return its integer value\n        if (!(val == \"+\" || val == \"-\" || val == \"*\" || val == \"/\")) {\n            return stoi(val);\n        }\n\n        // Recursively evaluate left and right subtrees\n        int leftVal = left->evaluate();\n        int rightVal = right->evaluate();\n\n        // Perform the corresponding operation\n        if (val == \"+\") return leftVal + rightVal;\n        if (val == \"-\") return leftVal - rightVal;\n        if (val == \"*\") return leftVal * rightVal;\n        if (val == \"/\") return leftVal / rightVal;\n\n        return 0; // Default case (should not reach here)\n    }\n};\n\n/**\n * This is the TreeBuilder class.\n * You can treat it as the driver code that takes the postfix input\n * and returns the expression tree representing it as a Node.\n */\n\nclass TreeBuilder {\npublic:\n    Node* buildTree(vector<string>& postfix) {\n        stack<MyNode*> stk;\n\n        for (const string& s : postfix) {\n            MyNode* node;\n\n            if (s == \"+\" || s == \"-\" || s == \"*\" || s == \"/\") {\n                // If the token is an operator, create a node with two children\n                Node* right = stk.top(); stk.pop();\n                Node* left = stk.top(); stk.pop();\n                node = new MyNode(s, left, right);\n            } else {\n                // If the token is an operand, create a leaf node\n                node = new MyNode(s);\n            }\n\n            stk.push(node);\n        }\n\n        return stk.top(); // The root of the expression tree\n    }\n};\n\n/**\n * Your TreeBuilder object will be instantiated and called as such:\n * TreeBuilder* obj = new TreeBuilder();\n * Node* expTree = obj->buildTree(postfix);\n * int ans = expTree->evaluate();\n */"
    }
  },
  "1629": {
    "solution": {
      "string": ""
    }
  },
  "1630": {
    "solution": {
      "sorting": ""
    }
  },
  "1631": {
    "solution": {
      "breadth-first-search": "class Solution {\npublic:\n    bool bfs(vector<vector<int>>& heights, int maxEffort) {\n        int m = heights.size(), n = heights[0].size();\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\n        queue<pair<int, int>> q;\n        q.push({0, 0});\n        visited[0][0] = true;\n        \n        vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n        \n        while (!q.empty()) {\n            auto [x, y] = q.front();\n            q.pop();\n            \n            if (x == m - 1 && y == n - 1) return true;\n            \n            for (auto [dx, dy] : directions) {\n                int nx = x + dx, ny = y + dy;\n                if (nx >= 0 && nx < m && ny >= 0 && ny < n && !visited[nx][ny]) {\n                    if (abs(heights[x][y] - heights[nx][ny]) <= maxEffort) {\n                        visited[nx][ny] = true;\n                        q.push({nx, ny});\n                    }\n                }\n            }\n        }\n        \n        return false;\n    }\n    \n    int minimumEffortPath(vector<vector<int>>& heights) {\n        int left = 0, right = INT_MAX;\n        int m = heights.size(), n = heights[0].size();\n        \n        while (left < right) {\n            int mid = left + (right - left) / 2;\n            if (bfs(heights, mid)) {\n                right = mid; \n            } else {\n                left = mid + 1;\n            }\n        }\n        \n        return left;\n    }\n};\n"
    }
  },
  "1632": {
    "solution": {
      "matrix": "class Solution {\n    class Node {\n        int id, val, rank;\n        List<Integer> neighbors;\n        public Node(int id, int val) {\n            this.id = id;\n            this.val = val;\n            this.neighbors = new ArrayList<>();\n        }\n    }\n    \n    class DSU {\n        int[] parent, rank;\n        int size;\n        public DSU(int n) {\n            this.parent = new int[n];\n            for (int i = 0; i < n; i++) parent[i] = i;\n            this.rank = new int[n];\n            this.size = n;\n        }\n\n        public boolean union(int[] a, int[] b) {\n            return union(encode(a[0], a[1]), encode(b[0], b[1]));\n        }\n\n        public boolean union(int a, int b) {\n            int p = find(a), q = find(b);\n            if (p == q) return false;\n            if (rank[p] > rank[q]) {\n                parent[q] = p;\n            } else if (rank[p] < rank[q]) {\n                parent[p] = q;\n            } else {\n                parent[p] = q;\n                rank[q]++;\n            }\n            size--;\n            return true;\n        }\n\n        public int find(int r, int c) {\n            return find(encode(r, c));\n        }\n\n        public int find(int a) {\n            int root = a;\n            while (root != parent[root]) {\n                root = parent[root];\n            }\n            while (root != a) {\n                int p = parent[a];\n                parent[a] = root;\n                a = p;\n            }\n            return root;\n        }\n\n        private int encode(int r, int c) {\n            return r * cols + c;\n        }\n    }\n\n    private int rows, cols;\n    public int[][] matrixRankTransform(int[][] matrix) {\n        this.rows = matrix.length;\n        this.cols = matrix[0].length;\n        DSU dsu = new DSU(rows * cols);\n        \n        connectCellWithEqualRank(dsu, matrix);\n        \n        Map<Integer, Node> graph = new HashMap<>();\n        Node[] nodes = new Node[dsu.size];\n        int[] in = new int[nodes.length];\n        \n        buildGraph(dsu, matrix, graph, nodes, in);\n\n        assignRankThroughTopologicalSort(nodes, in);\n        \n        int[][] ranks = new int[rows][cols];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                ranks[i][j] = graph.get(dsu.find(i, j)).rank;\n            }\n        }\n        return ranks;\n    }\n\n    private void assignRankThroughTopologicalSort(Node[] nodes, int[] in) {\n        Queue<Integer> queue = new LinkedList<>();\n        int rank = 1;\n        for (int i = 0; i < in.length; i++) {\n            if (in[i] == 0) queue.offer(i);\n        }\n        while (!queue.isEmpty()) {\n            int size = queue.size();\n            while (size-- > 0) {\n                int cur = queue.poll();\n                nodes[cur].rank = rank;\n                for (int neighbor: nodes[cur].neighbors) {\n                    if (--in[neighbor] != 0) continue;\n                    queue.offer(neighbor);\n                }\n            }\n            rank++;\n        }\n    }\n\n    private void buildGraph(DSU dsu, int[][] matrix, Map<Integer, Node> graph, Node[] nodes, int[] in) {\n        int id = 0;\n        // add nodes\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                int parent = dsu.find(i, j);\n                if (graph.containsKey(parent)) continue;\n                nodes[id] = new Node(id, matrix[i][j]);\n                graph.put(parent, nodes[id]);\n                id++;\n            }\n        }\n        // add edges\n        // 1. row by row\n        for (int i = 0; i < rows; i++) {\n            List<Node> curRow = new ArrayList<>();\n            Set<Integer> seen = new HashSet<>();\n            for (int j = 0; j < cols; j++) {\n                int parent = dsu.find(i, j);\n                if (seen.add(parent)) curRow.add(graph.get(parent));\n            }\n            curRow.sort(Comparator.comparingInt(a -> a.val));\n            for (int m = 0; m < curRow.size() - 1; m++) {\n                int neighborId = curRow.get(m + 1).id;\n                curRow.get(m).neighbors.add(neighborId);\n                in[neighborId]++;\n            }\n        }\n        // 2. col by col\n        for (int j = 0; j < cols; j++) {\n            List<Node> curCol = new ArrayList<>();\n            Set<Integer> seen = new HashSet<>();\n            for (int i = 0; i < rows; i++) {\n                int parent = dsu.find(i, j);\n                if (seen.add(parent)) curCol.add(graph.get(parent));\n            }\n            curCol.sort(Comparator.comparingInt(a -> a.val));\n            for (int m = 0; m < curCol.size() - 1; m++) {\n                int neighborId = curCol.get(m + 1).id;\n                curCol.get(m).neighbors.add(curCol.get(m + 1).id);\n                in[neighborId]++;\n            }\n        }\n    }\n\n    private void connectCellWithEqualRank(DSU dsu, int[][] matrix) {\n        Map<Integer, Map<Integer, List<int[]>>> map = new HashMap<>();\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                map.putIfAbsent(matrix[i][j], new HashMap<>());\n                map.get(matrix[i][j]).computeIfAbsent(i + 1, a -> new ArrayList<>()).add(new int[]{i, j});\n                map.get(matrix[i][j]).computeIfAbsent(-j - 1, a -> new ArrayList<>()).add(new int[]{i, j});\n            }\n        }\n        for (Map<Integer, List<int[]>> nodesMap: map.values()) {\n            for (List<int[]> nodes : nodesMap.values()) {\n                for (int i = 0; i < nodes.size() - 1; i++) {\n                    dsu.union(nodes.get(i), nodes.get(i + 1));\n                }\n            }\n        }\n    }\n}"
    }
  },
  "1633": {
    "solution": {
      "database": ""
    }
  },
  "1634": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1635": {
    "solution": {
      "database": ""
    }
  },
  "1636": {
    "solution": {
      "sorting": ""
    }
  },
  "1637": {
    "solution": {
      "sorting": ""
    }
  },
  "1638": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1639": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1640": {
    "solution": {
      "hash-table": ""
    }
  },
  "1641": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1642": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1643": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1644": {
    "solution": {
      "tree": ""
    }
  },
  "1645": {
    "solution": {
      "database": ""
    }
  },
  "1646": {
    "solution": {
      "array": ""
    }
  },
  "1647": {
    "solution": {
      "greedy": ""
    }
  },
  "1648": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1649": {
    "solution": {
      "merge-sort": "class Solution {\n    private static final int MOD = 1000000007;\n\n    public int createSortedArray(int[] instructions) {\n        FenwickTree tree = new FenwickTree(100001);\n        long cost = 0;\n\n        for (int i = 0; i < instructions.length; i++) {\n            int num = instructions[i];\n            int countSmaller = tree.query(num - 1); // Number of elements less than num\n            int countGreater = i - tree.query(num); // Number of elements greater than num\n            cost = (cost + Math.min(countSmaller, countGreater)) % MOD;\n            tree.update(num, 1);\n        }\n\n        return (int) cost;\n    }\n}\n\nclass FenwickTree {\n    private int[] tree;\n\n    public FenwickTree(int size) {\n        this.tree = new int[size + 1];\n    }\n\n    public void update(int index, int delta) {\n        while (index < tree.length) {\n            tree[index] += delta;\n            index += index & -index;\n        }\n    }\n\n    public int query(int index) {\n        int sum = 0;\n        while (index > 0) {\n            sum += tree[index];\n            index -= index & -index;\n        }\n        return sum;\n    }\n}\n"
    }
  },
  "1650": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1651": {
    "solution": {
      "database": ""
    }
  },
  "1652": {
    "solution": {
      "sliding-window": "class Solution {\n    public int[] decrypt(int[] code, int k) {\n        int n = code.length;\n        int[] result = new int[n];\n        \n        if (k == 0) {\n            return result;\n        }\n        \n        for (int i = 0; i < n; i++) {\n            if (k > 0) {\n                for (int j = 1; j <= k; j++) {\n                    result[i] += code[(i + j) % n];\n                }\n            } else {\n                for (int j = -1; j >= k; j--) {\n                    result[i] += code[(i + j + n) % n];\n                }\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "1653": {
    "solution": {
      "stack": ""
    }
  },
  "1654": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1655": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1656": {
    "solution": {
      "data-stream": ""
    }
  },
  "1657": {
    "solution": {
      "counting": ""
    }
  },
  "1658": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minOperations(int[] nums, int x) {\n        x = -x;\n        for (int v : nums) {\n            x += v;\n        }\n        Map<Integer, Integer> vis = new HashMap<>();\n        vis.put(0, -1);\n        int n = nums.length;\n        int ans = 1 << 30;\n        for (int i = 0, s = 0; i < n; ++i) {\n            s += nums[i];\n            vis.putIfAbsent(s, i);\n            if (vis.containsKey(s - x)) {\n                int j = vis.get(s - x);\n                ans = Math.min(ans, n - (i - j));\n            }\n        }\n        return ans == 1 << 30 ? -1 : ans;\n    }\n}"
    }
  },
  "1659": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1660": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    TreeNode* correctBinaryTree(TreeNode* root) {\n        unordered_set<TreeNode*> vis;\n        function<TreeNode*(TreeNode*)> dfs = [&](TreeNode* root) -> TreeNode* {\n            if (!root || vis.count(root->right)) {\n                return nullptr;\n            }\n            vis.insert(root);\n            root->right = dfs(root->right);\n            root->left = dfs(root->left);\n            return root;\n        };\n        return dfs(root);\n    }\n};"
    }
  },
  "1661": {
    "solution": {
      "database": ""
    }
  },
  "1662": {
    "solution": {
      "array": "#include <vector>\n#include <string>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool arrayStringsAreEqual(vector<string>& word1, vector<string>& word2) {\n        string s1 = ",
      "; \n        string s2 = ": ";\n\n        for (const string& w : word1) {\n            s1 += w;\n        }\n        \n        for (const string& w : word2) {\n            s2 += w;\n        }\n        \n        return s1 == s2;\n    }\n};\n"
    }
  },
  "1663": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    string getSmallestString(int n, int k) {\n        string result(n, 'a'); // Start with all 'a's, which is the smallest lexicographically\n        k -= n; // Subtract 1 for each 'a'\n\n        for (int i = n - 1; i >= 0 && k > 0; --i) {\n            int addValue = min(k, 25); // Add as much as possible, but not more than 25\n            result[i] += addValue;\n            k -= addValue;\n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "1664": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1665": {
    "solution": {
      "greedy": ""
    }
  },
  "1666": {
    "solution": {
      "binary-tree": "/*\n // Definition for a Node->\n class Node {\n public:\n     int val;\n     Node* left;\n     Node* right;\n     Node* parent;\n };\n*/\n\nclass Solution {\npublic:\n    Node* flipBinaryTree(Node* root, Node* targetLeaf) {\n        Node* currentNode = targetLeaf;\n        Node* parentNode = currentNode->parent;\n        while (currentNode != root) {\n            Node* grandParentNode = parentNode->parent;\n            if (currentNode->left) {\n                currentNode->right = currentNode->left;\n            }\n            currentNode->left = parentNode;\n            parentNode->parent = currentNode;\n            if (parentNode->left == currentNode) {\n                parentNode->left = nullptr;\n            } else if (parentNode->right == currentNode) {\n                parentNode->right = nullptr;\n            }\n            currentNode = parentNode;\n            parentNode = grandParentNode;\n        }\n        targetLeaf->parent = nullptr;\n        return targetLeaf;\n    }\n};"
    }
  },
  "1667": {
    "solution": {
      "database": ""
    }
  },
  "1668": {
    "solution": {
      "string-matching": "class Solution {\n public:\n  int maxRepeating(string sequence, string word) {\n    int ans = 1;\n    string repeating = word;\n    while (sequence.find(repeating) != string::npos) {\n      ++ans;\n      repeating += word;\n    }\n    return ans - 1;\n  }\n};"
    }
  },
  "1669": {
    "solution": {
      "linked-list": ""
    }
  },
  "1670": {
    "solution": {
      "design": "class FrontMiddleBackQueue {\n    deque<int> fq; // front-half\n    deque<int> bq; // back-half\n\n    void rebalance() {\n        // If back-half is larger, move the front element from back-half to front-half\n        if (bq.size() > fq.size()) {\n            fq.push_back(bq.front());\n            bq.pop_front();\n        } else if (fq.size() > bq.size() + 1) {\n            // If front-half is larger, move the back element from front-half to back-half\n            bq.push_front(fq.back());\n            fq.pop_back();\n        }\n    }\n\npublic:\n    void pushFront(int val) {\n        fq.push_front(val);\n        rebalance();\n    }\n\n    void pushMiddle(int val) {\n        if (fq.size() == bq.size()) { // total size is even\n            fq.push_back(val);\n        } else { // total size is odd\n            bq.push_front(fq.back());\n            fq.pop_back();\n            fq.push_back(val);\n        }\n        rebalance();\n    }\n\n    void pushBack(int val) {\n        bq.push_back(val);\n        rebalance();\n    }\n\n    int popFront() {\n        if (empty())\n            return -1;\n        int val = fq.front();\n        fq.pop_front();\n        rebalance();\n        return val;\n    }\n\n    int popMiddle() {\n        if (empty())\n            return -1;\n\n        int val;\n        if (fq.size() > bq.size()) {\n            // If front-half is larger, pop from front-half\n            val = fq.back();\n            fq.pop_back();\n        } else {\n            // If both halves are equal, pop from middle\n            val = fq.back();\n            fq.pop_back();\n        }\n        rebalance();\n        return val;\n    }\n\n    int popBack() {\n        if (empty())\n            return -1;\n        int val = bq.back();\n        bq.pop_back();\n        rebalance();\n        return val;\n    }\n\n    bool empty() { return fq.empty() && bq.empty(); }\n};\n\n/**\n * Your FrontMiddleBackQueue object will be instantiated and called as such:\n * FrontMiddleBackQueue* obj = new FrontMiddleBackQueue();\n * obj->pushFront(val);\n * obj->pushMiddle(val);\n * obj->pushBack(val);\n * int param_4 = obj->popFront();\n * int param_5 = obj->popMiddle();\n * int param_6 = obj->popBack();\n */"
    }
  },
  "1671": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1672": {
    "solution": {
      "matrix": ""
    }
  },
  "1673": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1674": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1675": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1676": {
    "solution": {
      "tree": ""
    }
  },
  "1677": {
    "solution": {
      "database": ""
    }
  },
  "1678": {
    "solution": {
      "string": ""
    }
  },
  "1679": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1680": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1681": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1682": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    int longestPalindromeSubseq(string s) {\n        int n = s.size();\n        \n        vector<vector<vector<int>>> dp(n, vector<vector<int>>(n, vector<int>(27, 0)));\n        \n        for (int len = 1; len <= n; ++len) {\n            for (int i = 0; i + len - 1 < n; ++i) {\n                int j = i + len - 1;\n                for (int x = 0; x < 27; ++x) {\n                    if (i >= j) {\n                        dp[i][j][x] = 0;\n                    } else if (s[i] == s[j] && s[i] - 'a' != x) {\n                        dp[i][j][x] = dp[i + 1][j - 1][s[i] - 'a'] + 2;\n                    } else {\n                        dp[i][j][x] = max(dp[i + 1][j][x], dp[i][j - 1][x]);\n                    }\n                }\n            }\n        }\n        \n        return dp[0][n - 1][26]; // Return the result for the full string\n    }\n};"
    }
  },
  "1683": {
    "solution": {
      "database": ""
    }
  },
  "1684": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1685": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1686": {
    "solution": {
      "breadth-first-search": "class Solution {\npublic:\n    int stoneGameVI(vector<int>& aliceValues, vector<int>& bobValues) {\n        int n = aliceValues.size();\n        vector<tuple<int, int, int>> stones;\n\n        // Create a combined array of (a[i] + b[i], a[i], b[i])\n        for (int i = 0; i < n; ++i) {\n            stones.emplace_back(aliceValues[i] + bobValues[i], aliceValues[i],\n                                bobValues[i]);\n        }\n\n        // Sort stones by combined value in descending order\n        sort(stones.rbegin(), stones.rend());\n\n        int aliceScore = 0, bobScore = 0;\n\n        // Alternate picking stones\n        for (int i = 0; i < n; ++i) {\n            if (i % 2 == 0) { // Alice's turn\n                aliceScore += get<1>(stones[i]);\n            } else { // Bob's turn\n                bobScore += get<2>(stones[i]);\n            }\n        }\n\n        // Compare scores to determine the result\n        if (aliceScore > bobScore) {\n            return 1; // Alice wins\n        } else if (bobScore > aliceScore) {\n            return -1; // Bob wins\n        } else {\n            return 0; // Tie\n        }\n    }\n};\n"
    }
  },
  "1687": {
    "solution": {
      "monotonic-queue": "class Solution {\n    public int boxDelivering(int[][] boxes, int portsCount, int maxBoxes, int maxWeight) {\n        int length = boxes.length;\n        int[] ports = new int[length + 1];\n        int[] weights = new int[length + 1];\n        int[] differences = new int[length + 1];\n        long[] prefixWeights = new long[length + 1];\n        for (int i = 1; i <= length; i++) {\n            ports[i] = boxes[i - 1][0];\n            weights[i] = boxes[i - 1][1];\n            if (i > 1)\n                differences[i] = differences[i - 1] + (ports[i - 1] != ports[i] ? 1 : 0);\n            prefixWeights[i] = prefixWeights[i - 1] + weights[i];\n        }\n        Deque<Integer> deque = new LinkedList<Integer>();\n        deque.offerLast(0);\n        int[] dp = new int[length + 1];\n        int[] remain = new int[length + 1];\n        for (int i = 1; i <= length; i++) {\n            while (!deque.isEmpty() && (i - deque.peekFirst() > maxBoxes || prefixWeights[i] - prefixWeights[deque.peekFirst()] > maxWeight))\n                deque.pollFirst();\n            dp[i] = remain[deque.peekFirst()] + differences[i] + 2;\n            if (i != length) {\n                remain[i] = dp[i] - differences[i + 1];\n                while (!deque.isEmpty() && remain[i] <= remain[deque.peekLast()])\n                    deque.pollLast();\n                deque.offerLast(i);\n            }\n        }\n        return dp[length];\n    }\n}"
    }
  },
  "1688": {
    "solution": {
      "math": ""
    }
  },
  "1689": {
    "solution": {
      "greedy": ""
    }
  },
  "1690": {
    "solution": {
      "game-theory": "class Solution {\npublic:\n    int stoneGameVII(vector<int>& stones) {\n        int n = stones.size();\n        vector<vector<int>> dp(n, vector<int>(n, 0));\n        vector<int> prefixSum(n + 1, 0);\n        \n        // Compute prefix sums\n        for (int i = 0; i < n; ++i) {\n            prefixSum[i + 1] = prefixSum[i] + stones[i];\n        }\n        \n        // Fill DP table\n        for (int len = 2; len <= n; ++len) { // Length of the subarray\n            for (int i = 0; i <= n - len; ++i) {\n                int j = i + len - 1;\n                int sum = prefixSum[j + 1] - prefixSum[i];\n                dp[i][j] = max(sum - stones[i] - dp[i + 1][j], sum - stones[j] - dp[i][j - 1]);\n            }\n        }\n        \n        return dp[0][n - 1];\n    }\n};\n"
    }
  },
  "1691": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1692": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1693": {
    "solution": {
      "database": ""
    }
  },
  "1694": {
    "solution": {
      "string": ""
    }
  },
  "1695": {
    "solution": {
      "sliding-window": "import java.util.*;\n\nclass Solution {\n    public int maximumUniqueSubarray(int[] nums) {\n        int n = nums.length;\n        Set<Integer> set = new HashSet<>();\n        int left = 0, right = 0;\n        int maxSum = 0, currentSum = 0;\n        \n        while (right < n) {\n            if (!set.contains(nums[right])) {\n                set.add(nums[right]);\n                currentSum += nums[right];\n                maxSum = Math.max(maxSum, currentSum);\n                right++;\n            } else {\n                set.remove(nums[left]);\n                currentSum -= nums[left];\n                left++;\n            }\n        }\n        \n        return maxSum;\n    }\n}\n"
    }
  },
  "1696": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\npublic class Solution {\n    public int maxResult(int[] nums, int k) {\n        int n = nums.length;\n        Deque<Integer> deque = new LinkedList<>();\n        // The dp array stores the maximum score to reach each index.\n        int[] dp = new int[n];\n        dp[0] = nums[0];\n        deque.offerLast(0);\n        // a monotonic decreasing queue.\n\n        for (int i = 1; i < n; i++) {\n            while (!deque.isEmpty() && deque.peekFirst() < i - k) {\n                deque.pollFirst();\n            }\n            \n            dp[i] = nums[i] + dp[deque.peekFirst()];\n\n            while (!deque.isEmpty() && dp[i] >= dp[deque.peekLast()]) {\n                deque.pollLast();\n            }\n            \n            deque.offerLast(i);\n        }\n        \n        return dp[n - 1];\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums = {1, -1, -2, 4, -7, 3};\n        int k = 2;\n        System.out.println(solution.maxResult(nums, k));  // Output: 7\n    }\n}"
    }
  },
  "1697": {
    "solution": {
      "union-find": ""
    }
  },
  "1698": {
    "solution": {
      "suffix-array": "import java.util.Arrays;\n\npublic class Solution {\n\n    public int countDistinct(String s) {\n        int n = s.length();\n        int[] suffixArray = buildSuffixArray(s);\n        int[] lcpArray = buildLCPArray(s, suffixArray);\n\n        int count = 0;\n        for (int i = 0; i < n; i++) {\n            int suffixLength = n - suffixArray[i];\n            count += suffixLength - (i > 0 ? lcpArray[i] : 0);\n        }\n\n        return count;\n    }\n\n    private int[] buildSuffixArray(String s) {\n        int n = s.length();\n        Suffix[] suffixes = new Suffix[n];\n\n        for (int i = 0; i < n; i++) {\n            suffixes[i] = new Suffix(i, s.substring(i));\n        }\n\n        Arrays.sort(suffixes);\n\n        int[] suffixArray = new int[n];\n        for (int i = 0; i < n; i++) {\n            suffixArray[i] = suffixes[i].index;\n        }\n\n        return suffixArray;\n    }\n\n    private int[] buildLCPArray(String s, int[] suffixArray) {\n        int n = s.length();\n        int[] rank = new int[n];\n        int[] lcpArray = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            rank[suffixArray[i]] = i;\n        }\n\n        int h = 0;\n        for (int i = 0; i < n; i++) {\n            if (rank[i] > 0) {\n                int j = suffixArray[rank[i] - 1];\n                while (i + h < n && j + h < n && s.charAt(i + h) == s.charAt(j + h)) {\n                    h++;\n                }\n                lcpArray[rank[i]] = h;\n                if (h > 0) {\n                    h--;\n                }\n            }\n        }\n\n        return lcpArray;\n    }\n\n    class Suffix implements Comparable<Suffix> {\n        int index;\n        String suffix;\n\n        Suffix(int index, String suffix) {\n            this.index = index;\n            this.suffix = suffix;\n        }\n\n        @Override\n        public int compareTo(Suffix other) {\n            return this.suffix.compareTo(other.suffix);\n        }\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        String s = \"aabbaba\";\n        int distinctSubstrings = solution.countDistinct(s);\n        System.out.println(\"Number of distinct substrings: \" + distinctSubstrings); // Output: 21\n    }\n}\n"
    }
  },
  "1699": {
    "solution": {
      "database": ""
    }
  },
  "1700": {
    "solution": {
      "queue": ""
    }
  },
  "1701": {
    "solution": {
      "array": ""
    }
  },
  "1702": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    string maximumBinaryString(string binary) {\n        int n = binary.size();\n        int zeroCount = 0, firstZeroIndex = -1;\n\n        // Count the number of '0's and find the index of the first '0'\n        for (int i = 0; i < n; ++i) {\n            if (binary[i] == '0') {\n                if (firstZeroIndex == -1) {\n                    firstZeroIndex = i;\n                }\n                zeroCount++;\n            }\n        }\n\n        // If there are no '0's or just one, the binary string is already maximal\n        if (zeroCount <= 1) {\n            return binary;\n        }\n\n        // Construct the result string\n        string result(n, '1'); // Start with all '1's\n        result[firstZeroIndex + zeroCount - 1] = '0'; // Place a single '0'\n\n        return result;\n    }\n};\n"
    }
  },
  "1703": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minMoves(int[] nums, int k) {\n        List<Integer> ones = new ArrayList<>();\n\n        for (int i = 0; i < nums.length; ++i)\n            if (nums[i] == 1)\n                ones.add(i);\n\n      int median = ones.get(getMedIndex(0, k));\n        int moves = 0;\n        for (int i = 0; i < k; ++i)\n            moves += Math.abs(ones.get(i) - median);\n\n        int ans = moves;\n\n        for (int i = 1; i <= ones.size() - k; ++i) {\n          int oldMedianIndex = ones.get(getMedIndex(i - 1, k));\n          int newMedianIndex = ones.get(getMedIndex(i, k));\n            if (k % 2 == 1)\n                moves += newMedianIndex - oldMedianIndex;\n            moves -= newMedianIndex - ones.get(i - 1);\n            moves += ones.get(i + k - 1) - newMedianIndex;\n            ans = Math.min(ans, moves);\n        }\n\n        return ans - nThSum((k - 1) / 2) - nThSum(k / 2);\n    }\n\n    private int getMedIndex(int i, int k) {\n        return (i + (i + k - 1)) / 2;\n    }\n\n    private int nThSum(int n) {\n        return n * (n + 1) / 2;\n    }\n}"
    }
  },
  "1704": {
    "solution": {
      "counting": ""
    }
  },
  "1705": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1706": {
    "solution": {
      "matrix": ""
    }
  },
  "1707": {
    "solution": {
      "trie": ""
    }
  },
  "1708": {
    "solution": {
      "greedy": ""
    }
  },
  "1709": {
    "solution": {
      "database": ""
    }
  },
  "1710": {
    "solution": {
      "sorting": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumUnits(vector<vector<int>>& boxTypes, int truckSize) {\n        // Step 1: Sort boxTypes by units per box in descending order\n        sort(boxTypes.begin(), boxTypes.end(), [](const vector<int>& a, const vector<int>& b) {\n            return a[1] > b[1];\n        });\n\n        int maxUnits = 0;\n        for (const auto& box : boxTypes) {\n            int boxCount = box[0];\n            int unitsPerBox = box[1];\n            \n            // Step 2: Take as many boxes as possible from the current type\n            int boxesToTake = min(boxCount, truckSize);\n            maxUnits += boxesToTake * unitsPerBox;\n            truckSize -= boxesToTake;\n\n            // Step 3: Stop if the truck is full\n            if (truckSize == 0) {\n                break;\n            }\n        }\n\n        return maxUnits;\n    }\n};\n"
    }
  },
  "1711": {
    "solution": {
      "hash-table": ""
    }
  },
  "1712": {
    "solution": {
      "two-pointers": "class Solution {\n    public int waysToSplit(int[] nums) {\n        int kMod = 1_000_000_007;\n        int n = nums.length;\n        int ans = 0;\n        int[] prefix = nums.clone();\n\n        for (int i = 1; i < n; ++i)\n            prefix[i] += prefix[i - 1];\n\n        for (int i = 0; i < n - 2; ++i) {\n            int j = firstGreaterEqual(prefix, i);\n            if (j == n - 1)\n                break;\n            int mid = prefix[j] - prefix[i];\n            int right = prefix[prefix.length - 1] - prefix[j];\n            if (mid > right)\n                continue;\n            int k = firstGreater(prefix, i);\n            ans = (ans + k - j) % kMod;\n        }\n\n        return ans;\n    }\n\n    private int firstGreaterEqual(int[] prefix, int i) {\n        int left = i + 1;\n        int right = prefix.length - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (prefix[mid] - prefix[i] >= prefix[i])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    };\n\n    private int firstGreater(int[] prefix, int i) {\n        int left = i + 1;\n        int right = prefix.length - 1;\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (prefix[mid] - prefix[i] > prefix[prefix.length - 1] - prefix[mid])\n                right = mid;\n            else\n                left = mid + 1;\n        }\n        return left;\n    };\n}"
    }
  },
  "1713": {
    "solution": {
      "greedy": ""
    }
  },
  "1714": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1715": {
    "solution": {
      "database": ""
    }
  },
  "1716": {
    "solution": {
      "math": "class Solution {\npublic:\n    int totalMoney(int n) {\n        const int weeks = n / 7;\n        const int firstWeek = trapezoid(1, 7);\n        const int lastFullWeek = trapezoid(1 + weeks - 1, 7 + weeks - 1);\n        const int remainingDays = trapezoid(1 + weeks, n % 7 + weeks);\n        return (firstWeek + lastFullWeek) * weeks / 2 + remainingDays;\n    }\n\n    // Returns sum(a..b).\n    int trapezoid(int a, int b) { return (a + b) * (b - a + 1) / 2; }\n};\n"
    }
  },
  "1717": {
    "solution": {
      "stack": ""
    }
  },
  "1718": {
    "solution": {
      "backtracking": ""
    }
  },
  "1719": {
    "solution": {
      "tree": "class Solution {\npublic:\n    int checkWays(vector<vector<int>>& pairs) {\n        constexpr int kMax = 501;\n        unordered_map<int, vector<int>> graph;\n        vector<int> degrees(kMax);\n        vector<vector<bool>> connected(kMax, vector<bool>(kMax));\n\n        for (const vector<int>& pair : pairs) {\n            const int u = pair[0];\n            const int v = pair[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n            ++degrees[u];\n            ++degrees[v];\n            connected[u][v] = true;\n            connected[v][u] = true;\n        }\n\n        for (auto& [_, children] : graph)\n            ranges::sort(children, ranges::greater{},\n                         [&degrees](int child) { return degrees[child]; });\n\n        const int root = getRoot(degrees, graph.size());\n        if (root == -1)\n            return 0;\n        if (!dfs(graph, root, degrees, connected, {}, vector<bool>(kMax)))\n            return 0;\n        return hasMoreThanOneWay ? 2 : 1;\n    }\n\nprivate:\n    bool hasMoreThanOneWay = false;\n\n    // Returns the root by finding the node with a degree that equals to n - 1.\n    int getRoot(const vector<int>& degrees, int n) {\n        for (int i = 1; i < degrees.size(); ++i)\n            if (degrees[i] == n - 1)\n                return i;\n        return -1;\n    }\n\n    bool dfs(const unordered_map<int, vector<int>>& graph, int u,\n             vector<int>& degrees, vector<vector<bool>>& connected,\n             vector<int>&& ancestors, vector<bool>&& seen) {\n        seen[u] = true;\n\n        for (const int ancestor : ancestors)\n            if (!connected[u][ancestor])\n                return false;\n\n        ancestors.push_back(u);\n\n        for (const int v : graph.at(u)) {\n            if (seen[v])\n                continue;\n            if (degrees[v] == degrees[u])\n                hasMoreThanOneWay = true;\n            if (!dfs(graph, v, degrees, connected, std::move(ancestors),\n                     std::move(seen)))\n                return false;\n        }\n\n        ancestors.pop_back();\n        return true;\n    }\n};"
    }
  },
  "1720": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1721": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1722": {
    "solution": {
      "union-find": ""
    }
  },
  "1723": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1724": {
    "solution": {
      "minimum-spanning-tree": "class UnionFind {\n public:\n  UnionFind() {}\n  UnionFind(int n) {\n    id.resize(n);\n\n    for (int i = 0; i < n; ++i)\n      id[i][0] = i;\n  }\n\n  void union_(int u, int v, int limit) {\n    const int i = find(u, limit);\n    const int j = find(v, limit);\n    if (i == j)\n      return;\n    id[i][limit] = j;\n  }\n\n  int find(int u, int limit) {\n    const auto it = id[u].upper_bound(limit);\n    const int i = prev(it)->second;\n    if (i == u)\n      return u;\n    const int j = find(i, limit);\n    id[u][limit] = j;\n    return j;\n  }\n\n private:\n  // id[i]'s (key, value) := (limit, id of node i <= limit)\n  vector<map<int, int>> id;\n};\n\nclass DistanceLimitedPathsExist {\n public:\n  DistanceLimitedPathsExist(int n, vector<vector<int>>& edgeList) {\n    uf = UnionFind(n);\n\n    ranges::sort(edgeList, ranges::less{},\n                 [](const vector<int>& edge) { return edge[2]; });\n\n    for (const vector<int>& edge : edgeList) {\n      const int u = edge[0];\n      const int v = edge[1];\n      const int d = edge[2];\n      uf.union_(u, v, d);\n    }\n  }\n\n  bool query(int p, int q, int limit) {\n    return uf.find(p, limit - 1) == uf.find(q, limit - 1);\n  }\n\n private:\n  UnionFind uf;\n};"
    }
  },
  "1725": {
    "solution": {
      "array": ""
    }
  },
  "1726": {
    "solution": {
      "counting": "class Solution {\npublic:\n    int tupleSameProduct(vector<int>& nums) {\n        unordered_map<int, int> productFreq;\n        int result = 0;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            for (int j = i + 1; j < nums.size(); ++j) {\n                int product = nums[i] * nums[j]; \n                result += productFreq[product] * 8;\n                ++productFreq[product]; \n            }\n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "1727": {
    "solution": {
      "matrix": ""
    }
  },
  "1728": {
    "solution": {
      "matrix": "import java.util.*;\n\nclass Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int rows, cols;\n    private int foodX, foodY;\n    private Map<String, Boolean> memo;\n    \n    public boolean canMouseWin(String[] grid, int catJump, int mouseJump) {\n        rows = grid.length;\n        cols = grid[0].length();\n        memo = new HashMap<>();\n        \n        int mouseX = 0, mouseY = 0, catX = 0, catY = 0;\n        \n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                if (grid[i].charAt(j) == 'M') {\n                    mouseX = i;\n                    mouseY = j;\n                } else if (grid[i].charAt(j) == 'C') {\n                    catX = i;\n                    catY = j;\n                } else if (grid[i].charAt(j) == 'F') {\n                    foodX = i;\n                    foodY = j;\n                }\n            }\n        }\n        \n        return dfs(grid, mouseX, mouseY, catX, catY, 0, catJump, mouseJump);\n    }\n    \n    private boolean dfs(String[] grid, int mouseX, int mouseY, int catX, int catY, int turns, int catJump, int mouseJump) {\n        if (turns >= 2 * rows * cols) return false; // Draw due to too many moves\n        String state = mouseX + \",\" + mouseY + \",\" + catX + \",\" + catY + \",\" + turns;\n        if (memo.containsKey(state)) return memo.get(state);\n        \n        // Check win/lose conditions\n        if (mouseX == foodX && mouseY == foodY) return true; // Mouse wins\n        if (catX == foodX && catY == foodY) return false; // Cat wins\n        if (mouseX == catX && mouseY == catY) return false; // Cat catches mouse\n        \n        boolean mouseTurn = (turns % 2 == 0);\n        if (mouseTurn) {\n            // Mouse's turn: try all possible moves\n            for (int[] direction : DIRECTIONS) {\n                for (int jump = 0; jump <= mouseJump; jump++) {\n                    int newX = mouseX + jump * direction[0];\n                    int newY = mouseY + jump * direction[1];\n                    \n                    if (!isValid(grid, newX, newY)) break; // Stop if out of bounds or wall\n                    \n                    if (dfs(grid, newX, newY, catX, catY, turns + 1, catJump, mouseJump)) {\n                        memo.put(state, true);\n                        return true; // Mouse wins\n                    }\n                }\n            }\n        } else {\n            // Cat's turn: try all possible moves\n            for (int[] direction : DIRECTIONS) {\n                for (int jump = 0; jump <= catJump; jump++) {\n                    int newX = catX + jump * direction[0];\n                    int newY = catY + jump * direction[1];\n                    \n                    if (!isValid(grid, newX, newY)) break; \n                    \n                    if (!dfs(grid, mouseX, mouseY, newX, newY, turns + 1, catJump, mouseJump)) {\n                        memo.put(state, false);\n                        return false; // Cat wins\n                    }\n                }\n            }\n        }\n        \n        memo.put(state, !mouseTurn);\n        return !mouseTurn;\n    }\n    \n    private boolean isValid(String[] grid, int x, int y) {\n        return x >= 0 && y >= 0 && x < rows && y < cols && grid[x].charAt(y) != '#';\n    }\n}\n"
    }
  },
  "1729": {
    "solution": {
      "database": ""
    }
  },
  "1730": {
    "solution": {
      "matrix": ""
    }
  },
  "1731": {
    "solution": {
      "database": ""
    }
  },
  "1732": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int largestAltitude(int[] gain) {\n        int n = gain.length;\n        int maxAltitude = 0;\n        int currentAltitude = 0;\n\n        for (int i = 0; i < n; i++) {\n            currentAltitude += gain[i]; // Compute prefix sum as current altitude\n            maxAltitude = Math.max(maxAltitude, currentAltitude); // Update max altitude\n        }\n\n        return maxAltitude;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        \n        System.out.println(solution.largestAltitude(new int[]{-5, 1, 5, 0, -7})); // Output: 1\n        System.out.println(solution.largestAltitude(new int[]{-4, -3, -2, -1, 4, 3, 2})); // Output: 0\n        System.out.println(solution.largestAltitude(new int[]{1, 2, 3, -2, -1})); // Output: 6\n    }\n}\n"
    }
  },
  "1733": {
    "solution": {
      "greedy": ""
    }
  },
  "1734": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1735": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1736": {
    "solution": {
      "greedy": ""
    }
  },
  "1737": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1738": {
    "solution": {
      "quickselect": "import java.util.*;\n\npublic class Solution {\n    public int kthLargestValue(int[][] matrix, int k) {\n        int m = matrix.length;\n        int n = matrix[0].length;\n        \n        int[][] xorMatrix = new int[m][n];\n        List<Integer> xorValues = new ArrayList<>();\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                int xor = matrix[i][j];\n                if (i > 0) xor ^= xorMatrix[i - 1][j];\n                if (j > 0) xor ^= xorMatrix[i][j - 1];\n                if (i > 0 && j > 0) xor ^= xorMatrix[i - 1][j - 1];\n                xorMatrix[i][j] = xor;\n                xorValues.add(xor);\n            }\n        }\n        \n        int[] xorArray = xorValues.stream().mapToInt(Integer::intValue).toArray();\n        int kthLargestXOR = quickselect(xorArray, 0, xorArray.length - 1, xorArray.length - k);\n        \n        return kthLargestXOR;\n    }\n    \n    private int quickselect(int[] nums, int left, int right, int k) {\n        while (left < right) {\n            int pivotIndex = partition(nums, left, right);\n            if (pivotIndex == k) {\n                return nums[k];\n            } else if (pivotIndex < k) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n        return nums[left];\n    }\n    \n    private int partition(int[] nums, int left, int right) {\n        int pivot = nums[right];\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (nums[j] < pivot) {\n                swap(nums, i++, j);\n            }\n        }\n        swap(nums, i, right);\n        return i;\n    }\n    \n    private void swap(int[] nums, int i, int j) {\n        int temp = nums[i];\n        nums[i] = nums[j];\n        nums[j] = temp;\n    }\n}\n"
    }
  },
  "1739": {
    "solution": {
      "greedy": ""
    }
  },
  "1740": {
    "solution": {
      "binary-tree": "// Time: O(N)\n// Space: O(H)\nclass Solution {\n    bool dfs(TreeNode *root, int target, vector<TreeNode*> &path) {\n        if (!root) return false;\n        path.push_back(root);\n        if (root->val == target || dfs(root->left, target, path) || dfs(root->right, target, path)) return true;\n        path.pop_back();\n        return false;\n    }\npublic:\n    int findDistance(TreeNode* root, int p, int q) {\n        if (p == q) return 0;\n        vector<TreeNode*> a, b;\n        dfs(root, p, a);\n        dfs(root, q, b);\n        int i = 0;\n        while (i < a.size() && i < b.size() && a[i] == b[i]) ++i;\n        return a.size() + b.size() - 2 * i;\n    }\n};"
    }
  },
  "1741": {
    "solution": {
      "database": ""
    }
  },
  "1742": {
    "solution": {
      "counting": ""
    }
  },
  "1743": {
    "solution": {
      "hash-table": ""
    }
  },
  "1744": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1745": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1746": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1747": {
    "solution": {
      "database": ""
    }
  },
  "1748": {
    "solution": {
      "counting": "class Solution {\npublic:\n    int sumOfUnique(vector<int>& nums) {\n        unordered_map<int, int> freq;\n        int sum = 0;\n\n        for (int num : nums) {\n            ++freq[num];\n        }\n\n        for (const auto& [num, count] : freq) {\n            if (count == 1) { \n                sum += num;\n            }\n        }\n\n        return sum;\n    }\n};\n"
    }
  },
  "1749": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    int maxAbsoluteSum(vector<int>& nums) {\n        int maxSum = 0, minSum = 0, currentMax = 0, currentMin = 0;\n\n        for (int num : nums) {\n            currentMax = max(currentMax + num, num);\n            currentMin = min(currentMin + num, num);\n            maxSum = max(maxSum, currentMax);\n            minSum = min(minSum, currentMin);\n        }\n\n        return max(abs(maxSum), abs(minSum));\n    }\n};"
    }
  },
  "1750": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1751": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1752": {
    "solution": {
      "array": ""
    }
  },
  "1753": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1754": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1755": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1756": {
    "solution": {
      "design": "class BinaryIndexedTree {\npublic:\n    BinaryIndexedTree(int _n)\n        : n(_n)\n        , c(_n + 1) {}\n\n    void update(int x, int delta) {\n        while (x <= n) {\n            c[x] += delta;\n            x += x & -x;\n        }\n    }\n\n    int query(int x) {\n        int s = 0;\n        while (x) {\n            s += c[x];\n            x -= x & -x;\n        }\n        return s;\n    }\n\nprivate:\n    int n;\n    vector<int> c;\n};\n\nclass MRUQueue {\npublic:\n    MRUQueue(int n) {\n        q.resize(n + 1);\n        iota(q.begin() + 1, q.end(), 1);\n        tree = new BinaryIndexedTree(n + 2010);\n    }\n\n    int fetch(int k) {\n        int l = 1, r = q.size() - 1;\n        while (l < r) {\n            int mid = (l + r) >> 1;\n            if (mid - tree->query(mid) >= k) {\n                r = mid;\n            } else {\n                l = mid + 1;\n            }\n        }\n        int x = q[l];\n        q.push_back(x);\n        tree->update(l, 1);\n        return x;\n    }\n\nprivate:\n    vector<int> q;\n    BinaryIndexedTree* tree;\n};\n\n/**\n * Your MRUQueue object will be instantiated and called as such:\n * MRUQueue* obj = new MRUQueue(n);\n * int param_1 = obj->fetch(k);\n */"
    }
  },
  "1757": {
    "solution": {
      "database": ""
    }
  },
  "1758": {
    "solution": {
      "string": ""
    }
  },
  "1759": {
    "solution": {
      "math": ""
    }
  },
  "1760": {
    "solution": {
      "array": ""
    }
  },
  "1761": {
    "solution": {
      "graph": "#include <vector>\n#include <unordered_set>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minTrioDegree(int n, vector<vector<int>>& edges) {\n        vector<unordered_set<int>> graph(n + 1);\n        vector<int> degree(n + 1, 0);\n\n        for (const auto& edge : edges) {\n            graph[edge[0]].insert(edge[1]);\n            graph[edge[1]].insert(edge[0]);\n            degree[edge[0]]++;\n            degree[edge[1]]++;\n        }\n\n        int minDegree = INT_MAX;\n\n        for (int i = 1; i <= n; ++i) {\n            for (int j : graph[i]) {\n                if (j > i) { \n                    for (int k : graph[j]) {\n                        if (k > j && graph[i].count(k)) {\n                            int currentDegree = degree[i] + degree[j] + degree[k] - 6;\n                            minDegree = min(minDegree, currentDegree);\n                        }\n                    }\n                }\n            }\n        }\n\n        return minDegree == INT_MAX ? -1 : minDegree;\n    }\n};"
    }
  },
  "1762": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1763": {
    "solution": {
      "sliding-window": "class Solution {\n    public String longestNiceSubstring(String s) {\n        int n = s.length();\n        int k = -1;\n        int max = 0;\n        for (int i = 0; i < n; ++i) {\n            Set<Character> set = new HashSet<>();\n            for (int j = i; j < n; ++j) {\n                set.add(s.charAt(j));\n                boolean check = true;\n                for (char a : set) {\n                    char b = (char) (a ^ 32);\n                    if (!(set.contains(a) && set.contains(b))) {\n                        check = false;\n                        break;\n                    }\n                }\n                if (check && max < j - i + 1) {\n                    max = j - i + 1;\n                    k = i;\n                }\n            }\n        }\n        return k == -1 ? \"\" : s.substring(k, k + max);\n    }\n}"
    }
  },
  "1764": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1765": {
    "solution": {
      "matrix": ""
    }
  },
  "1766": {
    "solution": {
      "tree": ""
    }
  },
  "1767": {
    "solution": {
      "database": ""
    }
  },
  "1768": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1769": {
    "solution": {
      "string": ""
    }
  },
  "1770": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1771": {
    "solution": {
      "dynamic-programming": "class Solution { public: int longestPalindrome(string word1, string word2) { const string& s = word1 + word2; const int n = s.length(); int ans = 0; vector<vector<int>> dp(n, vector<int>(n)); for (int i = 0; i < n; ++i) dp[i][i] = 1; for (int d = 1; d < n; ++d) for (int i = 0; i + d < n; ++i) { const int j = i + d; if (s[i] == s[j]) { dp[i][j] = 2 + dp[i + 1][j - 1]; if (i < word1.length() && j >= word1.length()) ans = max(ans, dp[i][j]); } else { dp[i][j] = max(dp[i + 1][j], dp[i][j - 1]); } } return ans; } };"
    }
  },
  "1772": {
    "solution": {
      "sorting": ""
    }
  },
  "1773": {
    "solution": {
      "string": ""
    }
  },
  "1774": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1775": {
    "solution": {
      "counting": ""
    }
  },
  "1776": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1777": {
    "solution": {
      "database": ""
    }
  },
  "1778": {
    "solution": {
      "interactive": ""
    }
  },
  "1779": {
    "solution": {
      "array": ""
    }
  },
  "1780": {
    "solution": {
      "math": "class Solution {\npublic:\n    bool checkPowersOfThree(int n) {\n        while (n > 0) {\n            int remainder = n % 3;\n            if (remainder > 1) {\n                return false; \n            }\n            n /= 3; \n        }\n        return true;\n    }\n};\n"
    }
  },
  "1781": {
    "solution": {
      "counting": ""
    }
  },
  "1782": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1783": {
    "solution": {
      "database": ""
    }
  },
  "1784": {
    "solution": {
      "string": ""
    }
  },
  "1785": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minElements(vector<int>& nums, int limit, int goal) {\n        long long currentSum = accumulate(nums.begin(), nums.end(), 0LL); // Calculate the current sum\n        long long diff = abs(goal - currentSum); // Absolute difference between goal and current sum\n\n        // Calculate the minimum number of elements needed\n        return (diff + limit - 1) / limit;\n    }\n};"
    }
  },
  "1786": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1787": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1788": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1789": {
    "solution": {
      "database": ""
    }
  },
  "1790": {
    "solution": {
      "counting": "class Solution {\npublic:\n    bool areAlmostEqual(string s1, string s2) {\n        vector<int> diffIndices; \n        \n        for (int i = 0; i < s1.size(); ++i) {\n            if (s1[i] != s2[i]) {\n                diffIndices.push_back(i);\n            }\n        }\n\n        // If there are no mismatches, strings are already equal\n        if (diffIndices.empty()) {\n            return true;\n        }\n\n        // If there are exactly two mismatches, check if swapping fixes the issue\n        if (diffIndices.size() == 2) {\n            int i = diffIndices[0], j = diffIndices[1];\n            return s1[i] == s2[j] && s1[j] == s2[i];\n        }\n\n        // If there are more than two mismatches, we cannot fix with one swap\n        return false;\n    }\n};\n"
    }
  },
  "1791": {
    "solution": {
      "graph": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findCenter(vector<vector<int>>& edges) {\n        if (edges[0][0] == edges[1][0] || edges[0][0] == edges[1][1]) {\n            return edges[0][0];\n        }\n        return edges[0][1];\n    }\n};"
    }
  },
  "1792": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1793": {
    "solution": {
      "two-pointers": "class Solution {\n    public int maximumScore(int[] nums, int k) {\n        int ans = 0;\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i <= nums.length; ++i) {\n            while (!stack.isEmpty() && (i == nums.length || nums[stack.peek()] > nums[i])) {\n                int h = nums[stack.pop()];\n                int w = stack.isEmpty() ? i : i - stack.peek() - 1;\n                if ((stack.isEmpty() || stack.peek() + 1 <= k) && i - 1 >= k)\n                    ans = Math.max(ans, h * w);\n            }\n            stack.push(i);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "1794": {
    "solution": {
      "greedy": ""
    }
  },
  "1795": {
    "solution": {
      "database": ""
    }
  },
  "1796": {
    "solution": {
      "hash-table": ""
    }
  },
  "1797": {
    "solution": {
      "linked-list": ""
    }
  },
  "1798": {
    "solution": {
      "greedy": ""
    }
  },
  "1799": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1800": {
    "solution": {
      "array": ""
    }
  },
  "1801": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1802": {
    "solution": {
      "greedy": ""
    }
  },
  "1803": {
    "solution": {
      "trie": ""
    }
  },
  "1804": {
    "solution": {
      "design": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  int prefixCount = 0;\n  int wordCount = 0;\n  TrieNode() : children(26, nullptr) {}\n};\n\nclass Trie {\n public:\n  void insert(string word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        node->children[i] = make_shared<TrieNode>();\n      node = node->children[i];\n      ++node->prefixCount;\n    }\n    ++node->wordCount;\n  }\n\n  int countWordsEqualTo(string word) {\n    shared_ptr<TrieNode> node = find(word);\n    return node ? node->wordCount : 0;\n  }\n\n  int countWordsStartingWith(string prefix) {\n    shared_ptr<TrieNode> node = find(prefix);\n    return node ? node->prefixCount : 0;\n  }\n\n  void erase(string word) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : word) {\n      const int i = c - 'a';\n      node = node->children[i];\n      --node->prefixCount;\n    }\n    --node->wordCount;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  shared_ptr<TrieNode> find(const string& s) {\n    shared_ptr<TrieNode> node = root;\n    for (const char c : s) {\n      const int i = c - 'a';\n      if (node->children[i] == nullptr)\n        return nullptr;\n      node = node->children[i];\n    }\n    return node;\n  }\n};"
    }
  },
  "1805": {
    "solution": {
      "hash-table": ""
    }
  },
  "1806": {
    "solution": {
      "math": ""
    }
  },
  "1807": {
    "solution": {
      "hash-table": ""
    }
  },
  "1808": {
    "solution": {
      "recursion": ""
    }
  },
  "1809": {
    "solution": {
      "database": ""
    }
  },
  "1810": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1811": {
    "solution": {
      "database": ""
    }
  },
  "1812": {
    "solution": {
      "math": ""
    }
  },
  "1813": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1814": {
    "solution": {
      "counting": ""
    }
  },
  "1815": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1816": {
    "solution": {
      "string": ""
    }
  },
  "1817": {
    "solution": {
      "hash-table": ""
    }
  },
  "1818": {
    "solution": {
      "ordered-set": ""
    }
  },
  "1819": {
    "solution": {
      "number-theory": ""
    }
  },
  "1820": {
    "solution": {
      "matrix": ""
    }
  },
  "1821": {
    "solution": {
      "database": ""
    }
  },
  "1822": {
    "solution": {
      "math": "class Solution {\npublic:\n    int arraySign(vector<int>& nums) {\n        int sign = 1; \n        \n        for (int num : nums) {\n            if (num == 0) {\n                return 0; // If any number is 0, the product is 0\n            }\n            if (num < 0) {\n                sign *= -1; // Flip the sign for negative numbers\n            }\n        }\n        \n        return sign;\n    }\n};\n"
    }
  },
  "1823": {
    "solution": {
      "queue": "class Solution {\n    public int findTheWinner(int n, int k) {\n        List<Integer> players = new ArrayList<>();\n        for (int i = 1; i <= n; i++) {\n            players.add(i);\n        }\n        \n        int index = 0;\n        while (players.size() > 1) {\n            index = (index + k - 1) % players.size();\n            players.remove(index);\n        }\n        \n        return players.get(0);\n    }\n}\n"
    }
  },
  "1824": {
    "solution": {
      "dynamic-programming": "class Solution { public: int minSideJumps(vector<int>& obstacles) { constexpr int kInf = 1e6; vector<int> dp{kInf, 1, 0, 1}; for (const int obstacle : obstacles) { if (obstacle > 0) dp[obstacle] = kInf; for (int i = 1; i <= 3; ++i) if (i != obstacle) for (int j = 1; j <= 3; ++j) dp[i] = min({dp[i], dp[j] + (i == j ? 0 : 1)}); } return ranges::min(dp); } };"
    }
  },
  "1825": {
    "solution": {
      "queue": ""
    }
  },
  "1826": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1827": {
    "solution": {
      "greedy": ""
    }
  },
  "1828": {
    "solution": {
      "geometry": ""
    }
  },
  "1829": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1830": {
    "solution": {
      "combinatorics": ""
    }
  },
  "1831": {
    "solution": {
      "database": ""
    }
  },
  "1832": {
    "solution": {
      "hash-table": ""
    }
  },
  "1833": {
    "solution": {
      "greedy": ""
    }
  },
  "1834": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1835": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "1836": {
    "solution": {
      "linked-list": ""
    }
  },
  "1837": {
    "solution": {
      "math": ""
    }
  },
  "1838": {
    "solution": {
      "sliding-window": "import java.util.Arrays;\n\npublic class Solution {\n    public int maxFrequency(int[] nums, int k) {\n        Arrays.sort(nums); \n        int left = 0;\n        long sum = 0; \n        int maxFreq = 0; \n        \n        for (int right = 0; right < nums.length; right++) {\n            sum += nums[right];\n            while ((right - left + 1) * (long) nums[right] - sum > k) {\n                sum -= nums[left]; \n                left++;\n            }            \n            int windowSize = right - left + 1;\n            maxFreq = Math.max(maxFreq, windowSize);\n        }\n        \n        return maxFreq;\n    }\n    \n    public static void main(String[] args) {\n        Solution solution = new Solution();        \n        int[] nums = {1, 2, 4};\n        int k = 5;\n        System.out.println(solution.maxFrequency(nums, k)); // Output: 3\n    }\n}\n"
    }
  },
  "1839": {
    "solution": {
      "sliding-window": "class Solution {\n  public int longestBeautifulSubstring(String word) {\n    int ans = 0;\n    int count = 1;\n\n    for (int left = 0, right = 1; right < word.length(); ++right) {\n    char curr = word.charAt(right);\n    char prev = word.charAt(right - 1);\n      if (curr >= prev) {\n        if (curr > prev)\n          ++count;\n        if (count == 5)\n          ans = Math.max(ans, right - left + 1);\n      } else {\n        count = 1;\n        left = right;\n      }\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "1840": {
    "solution": {
      "sorting": ""
    }
  },
  "1841": {
    "solution": {
      "database": ""
    }
  },
  "1842": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1843": {
    "solution": {
      "database": ""
    }
  },
  "1844": {
    "solution": {
      "string": ""
    }
  },
  "1845": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1846": {
    "solution": {
      "greedy": ""
    }
  },
  "1847": {
    "solution": {
      "sorting": ""
    }
  },
  "1848": {
    "solution": {
      "array": "#include <vector>\n#include <cmath>\n#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    int getMinDistance(vector<int>& nums, int target, int start) {\n        int minDistance = INT_MAX; \n        \n        for (int i = 0; i < nums.size(); ++i) {\n            if (nums[i] == target) { \n                minDistance = min(minDistance, abs(i - start)); \n            }\n        }\n        \n        return minDistance;\n    }\n};\n"
    }
  },
  "1849": {
    "solution": {
      "backtracking": ""
    }
  },
  "1850": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1851": {
    "solution": {
      "line-sweep": "class T {\n  public int size;\n  public int right;\n  public T(int size, int right) {\n    this.size = size;\n    this.right = right;\n  }\n}\n\nclass Solution {\n  public int[] minInterval(int[][] intervals, int[] queries) {\n    int[] ans = new int[queries.length];\n    Arrays.fill(ans, -1);\n    \n    // Use a minHeap to store intervals sorted by size\n    PriorityQueue<T> minHeap = new PriorityQueue<>((a, b) -> a.size - b.size);\n    \n    // Store the indices of queries\n    Integer[] indices = new Integer[queries.length];\n    for (int i = 0; i < queries.length; ++i)\n      indices[i] = i;\n    \n    // Sort intervals by start time and queries by value\n    Arrays.sort(intervals, (a, b) -> a[0] - b[0]);\n    Arrays.sort(indices, (a, b) -> queries[a] - queries[b]);\n\n    int i = 0; // intervals' index\n    for (final int index : indices) {\n      // Add intervals to the minHeap that start before or at the current query\n      while (i < intervals.length && intervals[i][0] <= queries[index]) {\n        minHeap.offer(new T(intervals[i][1] - intervals[i][0] + 1, intervals[i][1]));\n        ++i;\n      }\n      \n      // Remove intervals from minHeap that end before the current query\n      while (!minHeap.isEmpty() && minHeap.peek().right < queries[index])\n        minHeap.poll();\n      \n      // Assign the size of the smallest interval in minHeap to the current query\n      if (!minHeap.isEmpty())\n        ans[index] = minHeap.peek().size;\n    }\n\n    return ans;\n  }\n}\n"
    }
  },
  "1852": {
    "solution": {
      "sliding-window": "class Solution {\n    public int[] distinctNumbers(int[] nums, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < k; ++i) {\n            count.merge(nums[i], 1, Integer::sum);\n        }\n        int n = nums.length;\n        int[] ans = new int[n - k + 1];\n        ans[0] = count.size();\n        for (int i = k; i < n; ++i) {\n            count.merge(nums[i], 1, Integer::sum);\n            if (count.merge(nums[i - k], -1, Integer::sum) == 0) {\n                count.remove(nums[i - k]);\n            }\n            ans[i - k + 1] = count.size();\n        }\n        return ans;\n    }\n}"
    }
  },
  "1853": {
    "solution": {
      "database": ""
    }
  },
  "1854": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1855": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1856": {
    "solution": {
      "monotonic-stack": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int maxSumMinProduct(int[] nums) {\n        int n = nums.length;\n        long[] prefixSum = new long[n + 1];\n        for (int i = 0; i < n; i++) {\n            prefixSum[i + 1] = prefixSum[i] + nums[i];\n        }\n        \n        int[] left = new int[n];\n        int[] right = new int[n];\n        \n        Deque<Integer> stack = new ArrayDeque<>();\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            left[i] = stack.isEmpty() ? 0 : stack.peek() + 1;\n            stack.push(i);\n        }\n        \n        stack.clear();\n        for (int i = n - 1; i >= 0; i--) {\n            while (!stack.isEmpty() && nums[stack.peek()] >= nums[i]) {\n                stack.pop();\n            }\n            right[i] = stack.isEmpty() ? n : stack.peek();\n            stack.push(i);\n        }\n        \n        long maxMinProduct = 0;\n        for (int i = 0; i < n; i++) {\n            long minProduct = (prefixSum[right[i]] - prefixSum[left[i]]) * nums[i];\n            maxMinProduct = Math.max(maxMinProduct, minProduct);\n        }\n        \n        return (int) (maxMinProduct % 1000000007);\n    }\n}\n"
    }
  },
  "1857": {
    "solution": {
      "topological-sort": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int largestPathValue(string colors, vector<vector<int>>& edges) {\n        int n = colors.size();\n        vector<vector<int>> graph(n);\n        vector<int> inDegree(n, 0);\n        \n        for (auto& edge : edges) {\n            graph[edge[0]].push_back(edge[1]);\n            inDegree[edge[1]]++;\n        }\n        \n        vector<vector<int>> count(n, vector<int>(26, 0));\n        \n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n        \n        int processedNodes = 0, maxColorValue = 0;\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            processedNodes++;\n            \n            count[node][colors[node] - 'a']++;\n            maxColorValue = max(maxColorValue, count[node][colors[node] - 'a']);\n            \n            for (int neighbor : graph[node]) {\n                for (int c = 0; c < 26; c++) {\n                    count[neighbor][c] = max(count[neighbor][c], count[node][c]);\n                }\n                \n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n        \n        if (processedNodes < n) {\n            return -1;\n        }\n        \n        return maxColorValue;\n    }\n};\n"
    }
  },
  "1858": {
    "solution": {
      "trie": "struct TrieNode {\n    TrieNode *next[26] = {};\n    bool word = false;\n};\nclass Solution {\n    void addWord(TrieNode *node, string &s) {\n        for (char c : s) {\n            if (!node->next[c - 'a']) node->next[c - 'a'] = new TrieNode();\n            node = node->next[c - 'a'];\n        }\n        node->word = true;\n    }\n    string ans, path;\n    void dfs(TrieNode *node) {\n        for (int i = 0; i < 26; ++i) {\n            if (!node->next[i] || !node->next[i]->word) continue;\n            path += 'a' + i;\n            if (path.size() > ans.size()) ans = path;\n            dfs(node->next[i]);\n            path.pop_back();\n        }\n    }\npublic:\n    string longestWord(vector<string>& A) {\n        TrieNode root;\n        for (auto &s : A) addWord(&root, s);\n        dfs(&root);\n        return ans;\n    }\n};"
    }
  },
  "1859": {
    "solution": {
      "sorting": ""
    }
  },
  "1860": {
    "solution": {
      "math": ""
    }
  },
  "1861": {
    "solution": {
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    \n    public char[][] rotateTheBox(char[][] box) {\n        int rows = box.length;\n        int cols = box[0].length;\n        \n        // Simulate gravity for each row\n        for (int i = 0; i < rows; i++) {\n            applyGravity(box, i, cols);\n        }\n        \n        // Rotate the box 90 degrees clockwise\n        char[][] rotatedBox = new char[cols][rows];\n        for (int i = 0; i < rows; i++) {\n            for (int j = 0; j < cols; j++) {\n                rotatedBox[j][rows - 1 - i] = box[i][j];\n            }\n        }\n        \n        return rotatedBox;\n    }\n    \n    private void applyGravity(char[][] box, int row, int cols) {\n        // Start from the rightmost column and process stones\n        int emptySpace = cols - 1; // Pointer to the last empty space\n        for (int col = cols - 1; col >= 0; col--) {\n            if (box[row][col] == '#') {\n                // Place stone at the empty space\n                box[row][col] = '.';\n                box[row][emptySpace] = '#';\n                emptySpace--;\n            } else if (box[row][col] == '*') {\n                // Reset empty space pointer due to obstacle\n                emptySpace = col - 1;\n            }\n        }\n    }\n}\n"
    }
  },
  "1862": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1863": {
    "solution": {
      "combinatorics": ""
    }
  },
  "1864": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minSwaps(string s) {\n        const int ones = ranges::count(s, '1');\n        const int zeros = s.length() - ones;\n        if (abs(ones - zeros) > 1)\n            return -1;\n        if (ones > zeros)\n            return countSwaps(s, '1');\n        if (zeros > ones)\n            return countSwaps(s, '0');\n        return min(countSwaps(s, '1'), countSwaps(s, '0'));\n    }\n\nprivate:\n    int countSwaps(const string& s, char curr) {\n        int swaps = 0;\n        for (const char c : s) {\n            if (c != curr)\n                ++swaps;\n            curr ^= 1;\n        }\n        return swaps / 2;\n    }\n};"
    }
  },
  "1865": {
    "solution": {
      "design": ""
    }
  },
  "1866": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1867": {
    "solution": {
      "database": ""
    }
  },
  "1868": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1869": {
    "solution": {
      "string": ""
    }
  },
  "1870": {
    "solution": {
      "array": ""
    }
  },
  "1871": {
    "solution": {
      "sliding-window": "class Solution {\n  public boolean canReach(String s, int minJump, int maxJump) {\n    int count = 0;\n    boolean dp[] = new boolean[s.length()];\n    dp[0] = true;\n\n    for (int i = minJump; i < s.length(); ++i) {\n      count += dp[i - minJump] ? 1 : 0;\n      if (i - maxJump > 0)\n        count -= dp[i - maxJump - 1] ? 1 : 0;\n      dp[i] = count > 0 && s.charAt(i) == '0';\n    }\n\n    return dp[dp.length - 1];\n  }\n}"
    }
  },
  "1872": {
    "solution": {
      "breadth-first-search": "class Solution {\n public:\n  int stoneGameVIII(vector<int>& stones) {\n    const int n = stones.size();\n    vector<int> prefix(n);\n    // dp[i] := the maximum score difference the current player can get when the\n    // game starts at i, i.e. stones[0..i] are merged into the value prefix[i]\n    vector<int> dp(n, INT_MIN);\n\n    partial_sum(stones.begin(), stones.end(), prefix.begin());\n\n    // Must take all when there're only two stones left.\n    dp[n - 2] = prefix.back();\n\n    for (int i = n - 3; i >= 0; --i)\n      dp[i] = max(dp[i + 1], prefix[i + 1] - dp[i + 1]);\n\n    return dp[0];\n  }\n};"
    }
  },
  "1873": {
    "solution": {
      "database": ""
    }
  },
  "1874": {
    "solution": {
      "greedy": ""
    }
  },
  "1875": {
    "solution": {
      "database": ""
    }
  },
  "1876": {
    "solution": {
      "sliding-window": "class Solution {\n    public int countGoodSubstrings(String s) {\n        int count = 0;\n        int n = s.length();\n        \n        for (int i = 0; i <= n - 3; i++) {\n            if (s.charAt(i) != s.charAt(i + 1) && \n                s.charAt(i) != s.charAt(i + 2) &&\n                s.charAt(i + 1) != s.charAt(i + 2)) {\n                count++;\n            }\n        }\n        \n        return count;\n    }\n}\n"
    }
  },
  "1877": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1878": {
    "solution": {
      "matrix": ""
    }
  },
  "1879": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1880": {
    "solution": {
      "string": ""
    }
  },
  "1881": {
    "solution": {
      "greedy": ""
    }
  },
  "1882": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1883": {
    "solution": {
      "dynamic-programming": "class Solution {\n public:\n  int minSkips(vector<int>& dist, int speed, int hoursBefore) {\n    constexpr double kInf = 1e7;\n    constexpr double kEps = 1e-9;\n    const int n = dist.size();\n    // dp[i][j] := the minimum time, where i is the number of roads we traversed\n    // so far and j is the number of skips we did\n    vector<vector<double>> dp(n + 1, vector<double>(n + 1, kInf));\n    dp[0][0] = 0;\n\n    for (int i = 1; i <= n; ++i) {\n      const double d = dist[i - 1];\n      dp[i][0] = ceil(dp[i - 1][0] + d / speed - kEps);\n      for (int j = 1; j <= i; ++j)\n        dp[i][j] = min(dp[i - 1][j - 1] + d / speed,\n                       ceil(dp[i - 1][j] + d / speed - kEps));\n    }\n\n    for (int j = 0; j <= n; ++j)\n      if (dp[n][j] <= hoursBefore)\n        return j;\n\n    return -1;\n  }\n};"
    }
  },
  "1884": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    int twoEggDrop(int n) {\n        // The minimum number of drops required\n        int drops = 0;\n        \n        // The strategy is to drop the first egg from a floor and continue from higher floors.\n        // The second egg will be used to check between the floors once the first egg breaks.\n        \n        // As we want to minimize the number of drops, we will increase the floor number\n        // progressively from the 1st egg drop, decreasing the number of possible floors \n        // left to drop on the second egg after each drop.\n        \n        // The idea is to drop the first egg from increasing floors, \n        // then use the second egg to check between the last drop and the previous one.\n        \n        // We start from the floor `x` and increase the next drop by 1 step.\n        while ((drops * (drops + 1)) / 2 < n) {\n            drops++;\n        }\n        \n        return drops;\n    }\n};"
    }
  },
  "1885": {
    "solution": {
      "two-pointers": "class Solution {\n    public long countPairs(int[] nums1, int[] nums2) {\n        long count = 0;\n        int n = nums1.length;\n        int[] differences = new int[n];\n        for (int i = 0; i < n; i++)\n            differences[i] = nums1[i] - nums2[i];\n        Arrays.sort(differences);\n        for (int i = 0; i < n - 1; i++) {\n            int target = -differences[i] + 1;\n            int index = binarySearch(differences, n, target, i + 1);\n            count += n - index;\n        }\n        return count;\n    }\n\n    public int binarySearch(int[] differences, int n, int target, int startIndex) {\n        int low = startIndex, high = n - 1;\n        if (differences[high] < target)\n            return n;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            if (differences[mid] < target)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n}"
    }
  },
  "1886": {
    "solution": {
      "matrix": ""
    }
  },
  "1887": {
    "solution": {
      "sorting": ""
    }
  },
  "1888": {
    "solution": {
      "sliding-window": "class Solution {\n  public int minFlips(String s) {\n  int n = s.length();\n    int[][] count = new int[2][2];\n\n    for (int i = 0; i < n; ++i)\n      ++count[s.charAt(i) - '0'][i % 2];\n\n    int ans = Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]);\n\n    for (int i = 0; i < n; ++i) {\n      --count[s.charAt(i) - '0'][i % 2];\n      ++count[s.charAt(i) - '0'][(n + i) % 2];\n      ans = Math.min(ans, Math.min(count[1][0] + count[0][1], count[0][0] + count[1][1]));\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "1889": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1890": {
    "solution": {
      "database": ""
    }
  },
  "1891": {
    "solution": {
      "array": ""
    }
  },
  "1892": {
    "solution": {
      "database": ""
    }
  },
  "1893": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1894": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1895": {
    "solution": {
      "matrix": "class Solution {\n    public int largestMagicSquare(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[][] rowSum = new int[m][n + 1]; // Prefix sums for rows\n        int[][] colSum = new int[m + 1][n]; // Prefix sums for columns\n\n        // Calculate prefix sums for rows\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                rowSum[i][j + 1] = rowSum[i][j] + grid[i][j];\n            }\n        }\n\n        // Calculate prefix sums for columns\n        for (int j = 0; j < n; j++) {\n            for (int i = 0; i < m; i++) {\n                colSum[i + 1][j] = colSum[i][j] + grid[i][j];\n            }\n        }\n\n        for (int size = Math.min(m, n); size > 1; size--) {\n            for (int i = 0; i + size <= m; i++) {\n                for (int j = 0; j + size <= n; j++) {\n                    if (isMagic(grid, rowSum, colSum, i, j, size)) {\n                        return size;\n                    }\n                }\n            }\n        }\n\n        return 1; // The smallest magic square is always size 1\n    }\n\n    private boolean isMagic(int[][] grid, int[][] rowSum, int[][] colSum, int x, int y, int size) {\n        int target = 0;\n\n        // Calculate the target sum using the first row\n        for (int j = 0; j < size; j++) {\n            target += grid[x][y + j];\n        }\n\n        // Check rows\n        for (int i = 0; i < size; i++) {\n            int rowSumValue = rowSum[x + i][y + size] - rowSum[x + i][y];\n            if (rowSumValue != target) return false;\n        }\n\n        // Check columns\n        for (int j = 0; j < size; j++) {\n            int colSumValue = colSum[x + size][y + j] - colSum[x][y + j];\n            if (colSumValue != target) return false;\n        }\n\n        // Check main diagonal\n        int diag1 = 0;\n        for (int i = 0; i < size; i++) {\n            diag1 += grid[x + i][y + i];\n        }\n        if (diag1 != target) return false;\n\n        // Check secondary diagonal\n        int diag2 = 0;\n        for (int i = 0; i < size; i++) {\n            diag2 += grid[x + i][y + size - 1 - i];\n        }\n        if (diag2 != target) return false;\n\n        return true;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        int[][] grid1 = {\n            {7, 1, 4, 5, 6},\n            {2, 5, 1, 6, 4},\n            {1, 5, 4, 3, 2},\n            {1, 2, 7, 3, 4}\n        };\n        System.out.println(solution.largestMagicSquare(grid1)); // Output: 3\n\n        int[][] grid2 = {\n            {5, 1, 3, 1},\n            {9, 3, 3, 1},\n            {1, 3, 3, 8}\n        };\n        System.out.println(solution.largestMagicSquare(grid2)); // Output: 2\n    }\n}\n"
    }
  },
  "1896": {
    "solution": {
      "stack": ""
    }
  },
  "1897": {
    "solution": {
      "counting": ""
    }
  },
  "1898": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1899": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    bool mergeTriplets(vector<vector<int>>& triplets, vector<int>& target) {\n        vector<int> maxTriplet(3, 0);  // Holds the max value for each position across all triplets\n        \n        for (auto& triplet : triplets) {\n            if (triplet[0] <= target[0] && triplet[1] <= target[1] && triplet[2] <= target[2]) {\n                maxTriplet[0] = max(maxTriplet[0], triplet[0]);\n                maxTriplet[1] = max(maxTriplet[1], triplet[1]);\n                maxTriplet[2] = max(maxTriplet[2], triplet[2]);\n            }\n        }\n        \n        // If max triplet matches target triplet, return true\n        return maxTriplet == target;\n    }\n};"
    }
  },
  "1900": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1901": {
    "solution": {
      "matrix": "",
      "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> findPeakGrid(vector<vector<int>>& mat) {\n        int rows = mat.size();\n        int cols = mat[0].size();\n\n        int left = 0, right = cols - 1;\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n\n            int maxRow = 0;\n            for (int i = 1; i < rows; ++i) {\n                if (mat[i][mid] > mat[maxRow][mid]) {\n                    maxRow = i;\n                }\n            }\n\n            if ((mid == 0 || mat[maxRow][mid] > mat[maxRow][mid - 1]) &&\n                (mid == cols - 1 || mat[maxRow][mid] > mat[maxRow][mid + 1])) {\n                return {maxRow, mid};\n            }\n            else if (mid > 0 && mat[maxRow][mid - 1] > mat[maxRow][mid]) {\n                right = mid - 1;\n            }\n            else {\n                left = mid + 1;\n            }\n        }\n\n        return {};\n    }\n};\n"
    }
  },
  "1902": {
    "solution": {
      "binary-search-tree": "class Solution {\n    public int maxDepthBST(int[] order) {\n        TreeMap<Integer, Integer> map = new TreeMap<>();\n        map.put(0, 0);\n        map.put(Integer.MAX_VALUE, 0);\n        map.put(order[0], 1);\n        int ans = 1;\n        for (int i = 1; i < order.length; ++i) {\n            int v = order[i];\n            Map.Entry<Integer, Integer> lower = map.lowerEntry(v);\n            Map.Entry<Integer, Integer> higher = map.higherEntry(v);\n            int depth = 1 + Math.max(lower.getValue(), higher.getValue());\n            ans = Math.max(ans, depth);\n            map.put(v, depth);\n        }\n        return ans;\n    }\n}"
    }
  },
  "1903": {
    "solution": {
      "math": "class Solution {\npublic:\n    string largestOddNumber(string num) {\n        for (int i = num.size() - 1; i >= 0; --i) {\n            if ((num[i] - '0') % 2 != 0) { \n                return num.substr(0, i + 1); \n            }\n        }\n        return \"\";\n    }\n};\n"
    }
  },
  "1904": {
    "solution": {
      "math": ""
    }
  },
  "1905": {
    "solution": {
      "union-find": "",
      "matrix": "class Solution {\n    public int countSubIslands(int[][] grid1, int[][] grid2) {\n        int m = grid1.length;\n        int n = grid1[0].length;\n        int count = 0;\n\n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                if (grid2[i][j] == 1) {\n                    if (isSubIsland(grid1, grid2, i, j)) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private boolean isSubIsland(int[][] grid1, int[][] grid2, int i, int j) {\n        boolean isSubIsland = true;\n        isSubIsland = dfs(grid1, grid2, i, j, isSubIsland);\n        return isSubIsland;\n    }\n\n    private boolean dfs(int[][] grid1, int[][] grid2, int i, int j, boolean isSubIsland) {\n        if (i < 0 || i >= grid1.length || j < 0 || j >= grid1[0].length || grid2[i][j] == 0) {\n            return isSubIsland;\n        }\n        if (grid1[i][j] != 1) {\n            isSubIsland = false;\n        }\n        grid2[i][j] = 0;\n        isSubIsland = dfs(grid1, grid2, i + 1, j, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i - 1, j, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i, j + 1, isSubIsland);\n        isSubIsland = dfs(grid1, grid2, i, j - 1, isSubIsland);\n        return isSubIsland;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[][] grid1 = {\n            {1, 1, 0, 0, 0},\n            {1, 1, 0, 0, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 1, 1}\n        };\n        int[][] grid2 = {\n            {1, 1, 0, 0, 0},\n            {0, 1, 0, 0, 0},\n            {0, 0, 1, 0, 0},\n            {0, 0, 0, 1, 0}\n        };\n\n        int result = solution.countSubIslands(grid1, grid2);\n        System.out.println(\"Number of Sub-Islands: \" + result); // Output will depend on grid1 and grid2\n    }\n}\n"
    }
  },
  "1906": {
    "solution": {
      "hash-table": ""
    }
  },
  "1907": {
    "solution": {
      "database": ""
    }
  },
  "1908": {
    "solution": {
      "brainteaser": "class Solution {\n    public boolean nimGame(int[] piles) {\n        int xor = 0;\n        for (int pile : piles)\n            xor ^= pile;\n        return xor != 0;\n    }\n}"
    }
  },
  "1909": {
    "solution": {
      "array": ""
    }
  },
  "1910": {
    "solution": {
      "string": ""
    }
  },
  "1911": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1912": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1913": {
    "solution": {
      "sorting": "class Solution {\npublic:\n    int maxProductDifference(vector<int>& nums) {\n        int largest1 = INT_MIN, largest2 = INT_MIN;\n        int smallest1 = INT_MAX, smallest2 = INT_MAX;\n\n        // Find the two largest and two smallest numbers\n        for (int num : nums) {\n            if (num > largest1) {\n                largest2 = largest1;\n                largest1 = num;\n            } else if (num > largest2) {\n                largest2 = num;\n            }\n\n            if (num < smallest1) {\n                smallest2 = smallest1;\n                smallest1 = num;\n            } else if (num < smallest2) {\n                smallest2 = num;\n            }\n        }\n\n        // Compute the product difference\n        return (largest1 * largest2) - (smallest1 * smallest2);\n    }\n};\n"
    }
  },
  "1914": {
    "solution": {
      "matrix": ""
    }
  },
  "1915": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1916": {
    "solution": {
      "topological-sort": ""
    }
  },
  "1917": {
    "solution": {
      "database": ""
    }
  },
  "1918": {
    "solution": {
      "sliding-window": "class Solution {\n    public int kthSmallestSubarraySum(int[] nums, int k) {\n        int min = Integer.MAX_VALUE, sum = 0;\n        for (int num : nums) {\n            min = Math.min(min, num);\n            sum += num;\n        }\n        int low = min, high = sum;\n        while (low < high) {\n            int mid = (high - low) / 2 + low;\n            int count = countSubarrays(nums, mid);\n            if (count < k)\n                low = mid + 1;\n            else\n                high = mid;\n        }\n        return low;\n    }\n\n    public int countSubarrays(int[] nums, int threshold) {\n        int count = 0;\n        int sum = 0;\n        int length = nums.length;\n        int left = 0, right = 0;\n        while (right < length) {\n            sum += nums[right];\n            while (sum > threshold) {\n                sum -= nums[left];\n                left++;\n            }\n            count += right - left + 1;\n            right++;\n        }\n        return count;\n    }\n}"
    }
  },
  "1919": {
    "solution": {
      "database": ""
    }
  },
  "1920": {
    "solution": {
      "array": ""
    }
  },
  "1921": {
    "solution": {
      "greedy": ""
    }
  },
  "1922": {
    "solution": {
      "recursion": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int countGoodNumbers(long long n) {\n        long long evenCount = (n + 1) / 2;\n        long long oddCount = n / 2;\n\n        long long evenPower = modExp(5, evenCount, MOD);\n        long long oddPower = modExp(4, oddCount, MOD);\n\n        return (evenPower * oddPower) % MOD;\n    }\n\nprivate:\n    long long modExp(long long base, long long exp, int mod) {\n        if (exp == 0)\n            return 1;\n        long long half = modExp(base, exp / 2, mod);\n        half = (half * half) % mod;\n        if (exp % 2 != 0) {\n            half = (half * base) % mod;\n        }\n        return half;\n    }\n};\n"
    }
  },
  "1923": {
    "solution": {
      "suffix-array": "class Solution {\n    public int longestCommonSubpath(int n, int[][] paths) {\n        int left = 0;\n        int right = paths[0].length;\n\n        while (left < right) {\n          int m = left + (right - left + 1) / 2;\n            if (checkCommonSubpath(paths, m))\n                left = m;\n            else\n                right = m - 1;\n        }\n\n        return left;\n    }\n\n    private static final long kMod = 8_417_508_174_513L;\n    private static final long kBase = 165_131L;\n\n    private boolean checkCommonSubpath(int[][] paths, int m) {\n        Set<Long>[] hashSets = new Set[paths.length];\n\n        for (int i = 0; i < paths.length; ++i)\n            hashSets[i] = rabinKarp(paths[i], m);\n\n        for (final long subpathHash : hashSets[0])\n            if (Arrays.stream(hashSets).allMatch(hashSet -> hashSet.contains(subpathHash)))\n                return true;\n\n        return false;\n    }\n\n    private Set<Long> rabinKarp(int[] path, int m) {\n        Set<Long> hashes = new HashSet<>();\n        long maxPower = 1;\n        long hash = 0;\n        for (int i = 0; i < path.length; ++i) {\n            hash = (hash * kBase + path[i]) % kMod;\n            if (i >= m)\n                hash = (hash - path[i - m] * maxPower % kMod + kMod) % kMod;\n            else\n                maxPower = maxPower * kBase % kMod;\n            if (i >= m - 1)\n                hashes.add(hash);\n        }\n        return hashes;\n    }\n}"
    }
  },
  "1924": {
    "solution": {
      "geometry": ""
    }
  },
  "1925": {
    "solution": {
      "math": "#include <cmath> \n\nclass Solution {\npublic:\n    int countTriples(int n) {\n        int count = 0;\n        \n        for (int c = 1; c <= n; ++c) {\n            for (int a = 1; a < c; ++a) {\n                int b2 = c * c - a * a; \n                int b = sqrt(b2); \n                \n                if (b * b == b2 && b < c) { \n                    ++count;\n                }\n            }\n        }\n        \n        return count;\n    }\n};\n"
    }
  },
  "1926": {
    "solution": {
      "matrix": ""
    }
  },
  "1927": {
    "solution": {
      "game-theory": ""
    }
  },
  "1928": {
    "solution": {
      "graph": "class Solution {\n public:\n  int minCost(int maxTime, vector<vector<int>>& edges,\n              vector<int>& passingFees) {\n    const int numCities = passingFees.size();\n    vector<vector<pair<int, int>>> cityGraph(numCities);\n\n    for (const vector<int>& edge : edges) {\n      const int city1 = edge[0];\n      const int city2 = edge[1];\n      const int travelTime = edge[2];\n      cityGraph[city1].emplace_back(city2, travelTime);\n      cityGraph[city2].emplace_back(city1, travelTime);\n    }\n\n    return findMinCost(cityGraph, 0, numCities - 1, maxTime, passingFees);\n  }\n\n private:\n  int findMinCost(const vector<vector<pair<int, int>>>& cityGraph, int startCity, int endCity,\n               int maxTime, const vector<int>& passingFees) {\n    // minCost[i] := the minimum cost to reach the i-th city\n    vector<int> minCost(cityGraph.size(), INT_MAX);\n    // minTime[i] := the minimum time to reach the i-th city\n    vector<int> minTime(cityGraph.size(), maxTime + 1);\n\n    minCost[startCity] = passingFees[startCity];\n    minTime[startCity] = 0;\n    using State = tuple<int, int, int>;  // (currentCost, currentTime, currentCity)\n    priority_queue<State, vector<State>, greater<>> minHeap;\n    minHeap.emplace(minCost[startCity], minTime[startCity], startCity);\n\n    while (!minHeap.empty()) {\n      const auto [currentCost, currentTime, currentCity] = minHeap.top();\n      minHeap.pop();\n      if (currentCity == endCity)\n        return minCost[endCity];\n      if (currentTime > minTime[currentCity] && currentCost > minCost[currentCity])\n        continue;\n      for (const auto& [neighborCity, travelTime] : cityGraph[currentCity]) {\n        if (currentTime + travelTime > maxTime)\n          continue;\n        // Go from currentCity -> neighborCity.\n        if (currentCost + passingFees[neighborCity] < minCost[neighborCity]) {\n          minCost[neighborCity] = currentCost + passingFees[neighborCity];\n          minTime[neighborCity] = currentTime + travelTime;\n          minHeap.emplace(minCost[neighborCity], minTime[neighborCity], neighborCity);\n        } else if (currentTime + travelTime < minTime[neighborCity]) {\n          minTime[neighborCity] = currentTime + travelTime;\n          minHeap.emplace(currentCost + passingFees[neighborCity], minTime[neighborCity], neighborCity);\n        }\n      }\n    }\n\n    return -1;\n  }\n};"
    }
  },
  "1929": {
    "solution": {
      "array": ""
    }
  },
  "1930": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1931": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1932": {
    "solution": {
      "tree": ""
    }
  },
  "1933": {
    "solution": {
      "string": ""
    }
  },
  "1934": {
    "solution": {
      "database": ""
    }
  },
  "1935": {
    "solution": {
      "hash-table": ""
    }
  },
  "1936": {
    "solution": {
      "greedy": ""
    }
  },
  "1937": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1938": {
    "solution": {
      "trie": ""
    }
  },
  "1939": {
    "solution": {
      "database": ""
    }
  },
  "1940": {
    "solution": {
      "counting": "class Solution {\npublic:\n    vector<int> longestCommomSubsequence(vector<vector<int>>& arrays) {\n        unordered_map<int, int> counter;\n        vector<int> res;\n        int n = arrays.size();\n        for (auto array : arrays) {\n            for (auto e : array) {\n                counter[e] += 1;\n                if (counter[e] == n) {\n                    res.push_back(e);\n                }\n            }\n        }\n        return res;\n    }\n};"
    }
  },
  "1941": {
    "solution": {
      "counting": ""
    }
  },
  "1942": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1943": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1944": {
    "solution": {
      "monotonic-stack": "import java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    public int[] canSeePersonsCount(int[] heights) {\n        int n = heights.length;\n        int[] result = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        for (int i = 0; i < n; i++) {\n            while (!stack.isEmpty() && heights[stack.peek()] <= heights[i]) {\n                result[stack.pop()]++;\n            }\n            if (!stack.isEmpty()) {\n                result[stack.peek()]++; \n            }\n            stack.push(i);\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "1945": {
    "solution": {
      "string": ""
    }
  },
  "1946": {
    "solution": {
      "greedy": ""
    }
  },
  "1947": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1948": {
    "solution": {
      "hash-function": ""
    }
  },
  "1949": {
    "solution": {
      "database": ""
    }
  },
  "1950": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1951": {
    "solution": {
      "database": ""
    }
  },
  "1952": {
    "solution": {
      "number-theory": "#include <cmath>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool isPrime(int num) {\n        if (num <= 1) return false;\n        for (int i = 2; i <= sqrt(num); ++i) {\n            if (num % i == 0) return false;\n        }\n        return true;\n    }\n\n    bool isThree(int n) {\n        int root = sqrt(n);\n        \n        return root * root == n && isPrime(root);\n    }\n};\n"
    }
  },
  "1953": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    long long numberOfWeeks(vector<int>& milestones) {\n        long long totalMilestones = 0;\n        int maxMilestone = 0;\n        \n        for (int milestone : milestones) {\n            totalMilestones += milestone;\n            maxMilestone = max(maxMilestone, milestone);\n        }\n        \n        // If the total milestones minus the largest milestone is greater than or equal to the largest milestone,\n        // then we can distribute the work across all weeks.\n        if (totalMilestones - maxMilestone >= maxMilestone) {\n            return totalMilestones;\n        }\n        \n        // Otherwise, the maximum number of weeks we can work is twice the sum of the other milestones minus the largest one.\n        return 2 * (totalMilestones - maxMilestone) + 1;\n    }\n};"
    }
  },
  "1954": {
    "solution": {
      "math": ""
    }
  },
  "1955": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1956": {
    "solution": {
      "geometry": ""
    }
  },
  "1957": {
    "solution": {
      "string": ""
    }
  },
  "1958": {
    "solution": {
      "matrix": ""
    }
  },
  "1959": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1960": {
    "solution": {
      "rolling-hash": "class Solution {\npublic:\n    long long maxProduct(string s) {\n        const int n = s.length();\n        long ans = 1;\n        vector<long> pows{1}; // pows[i] := kBase^i % kHash\n        // hashL[i] = the hash of the first i letters of s, where hashL[i] =\n        // (26^(i - 1) * s[0] + 26^(i - 2) * s[1] + ... + s[i - 1]) % kHash\n        vector<long> hashL{0};\n        // hashR[i] = the hash of the last i letters of s, where hashR[i] =\n        // (26^(i - 1) * s[-1] + 26^(i - 2) * s[-2] + ... + s[-i]) % kHash\n        vector<long> hashR{0};\n        // maxLeft[i] := the maximum odd length of palindromes in s[0..i]\n        vector<int> maxLeft(n);\n        // maxRight[i] := the maximum odd length of palindromes in s[i..n - 1]\n        vector<int> maxRight(n);\n\n        for (int i = 0; i < n; ++i)\n            pows.push_back(pows.back() * kBase % kHash);\n\n        for (int i = 0; i < n; ++i)\n            hashL.push_back((hashL.back() * kBase + val(s[i])) % kHash);\n\n        for (int i = n - 1; i >= 0; --i)\n            hashR.push_back((hashR.back() * kBase + val(s[i])) % kHash);\n\n        ranges::reverse(hashR);\n\n        int maxLength = 1;\n        for (int r = 0; r < n; ++r) {\n            const int l = (r - maxLength - 2) + 1;\n            if (l >= 0 && isPalindrome(l, r + 1, hashL, hashR, pows))\n                maxLength += 2;\n            maxLeft[r] = maxLength;\n        }\n\n        maxLength = 1;\n        for (int l = n - 1; l >= 0; --l) {\n            const int r = (l + maxLength + 2) - 1;\n            if (r < n && isPalindrome(l, r + 1, hashL, hashR, pows))\n                maxLength += 2;\n            maxRight[l] = maxLength;\n        }\n\n        for (int i = 1; i < n; ++i)\n            ans = max(ans, static_cast<long>(maxLeft[i - 1]) * maxRight[i]);\n\n        return ans;\n    }\n\nprivate:\n    static constexpr int kBase = 26;\n    static constexpr int kHash = 1'000'000'007;\n\n    static constexpr int val(char c) { return c - 'a'; }\n\n    bool isPalindrome(int l, int r, const vector<long>& hashL,\n                      const vector<long>& hashR, const vector<long>& pows) {\n        return getLeftRollingHash(l, r, hashL, pows) ==\n               getRightRollingHash(l, r, hashR, pows);\n    }\n\n    // Returns the left rolling hash of s[l..r).\n    long getLeftRollingHash(int l, int r, const vector<long>& hashL,\n                            const vector<long>& pows) {\n        const long h = (hashL[r] - hashL[l] * pows[r - l]) % kHash;\n        return h < 0 ? h + kHash : h;\n    }\n\n    // Returns the right rolling hash of s[l..r).\n    long getRightRollingHash(int l, int r, const vector<long>& hashR,\n                             const vector<long>& pows) {\n        const long h = (hashR[l] - hashR[r] * pows[r - l]) % kHash;\n        return h < 0 ? h + kHash : h;\n    }\n};"
    }
  },
  "1961": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1962": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "1963": {
    "solution": {
      "two-pointers": ""
    }
  },
  "1964": {
    "solution": {
      "array": ""
    }
  },
  "1965": {
    "solution": {
      "database": ""
    }
  },
  "1966": {
    "solution": {
      "array": ""
    }
  },
  "1967": {
    "solution": {
      "string": ""
    }
  },
  "1968": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    vector<int> rearrangeArray(vector<int>& nums) {\n        ranges::sort(nums);\n        for (int i = 1; i < nums.size(); i += 2)\n            swap(nums[i], nums[i - 1]);\n        return nums;\n    }\n};"
    }
  },
  "1969": {
    "solution": {
      "recursion": ""
    }
  },
  "1970": {
    "solution": {
      "union-find": ""
    }
  },
  "1971": {
    "solution": {
      "union-find": "#include <iostream>\n#include <vector>\n\nusing namespace std;\n\nclass Solution {\nprivate:\n    vector<int> parent;\n\n    int find(int x) {\n        if (parent[x] != x) {\n            parent[x] = find(parent[x]);\n        }\n        return parent[x];\n    }\n\n    void unionSets(int x, int y) {\n        int rootX = find(x);\n        int rootY = find(y);\n        if (rootX != rootY) {\n            parent[rootY] = rootX;\n        }\n    }\n\npublic:\n    bool validPath(int n, vector<vector<int>>& edges, int source,\n                   int destination) {\n        parent.resize(n);\n        for (int i = 0; i < n; ++i) {\n            parent[i] = i;\n        }\n\n        for (const auto& edge : edges) {\n            unionSets(edge[0], edge[1]);\n        }\n\n        return find(source) == find(destination);\n    }\n};\n"
    }
  },
  "1972": {
    "solution": {
      "database": ""
    }
  },
  "1973": {
    "solution": {
      "tree": ""
    }
  },
  "1974": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minTimeToType(string word) {\n        int time = word.size();  // Initial time for typing each character\n        char current = 'a';  // Start with 'a'\n\n        for (char c : word) {\n            int dist = abs(c - current);  // Find the distance between current character and the one to be typed\n            time += min(dist, 26 - dist);  // Minimum time to type the character (either forward or backward)\n            current = c;  // Update current character to the one typed\n        }\n\n        return time;\n    }\n};"
    }
  },
  "1975": {
    "solution": {
      "matrix": "class Solution {\n    public long maxMatrixSum(int[][] matrix) {\n        int rows = matrix.length;\n        int cols = matrix[0].length;\n\n        long totalSum = 0;\n        int minAbsValue = Integer.MAX_VALUE;\n        int negativeCount = 0;\n\n        for (int[] row : matrix) {\n            for (int num : row) {\n                totalSum += Math.abs(num);\n                if (num < 0) {\n                    negativeCount++;\n                }\n                minAbsValue = Math.min(minAbsValue, Math.abs(num));\n            }\n        }\n\n        // If the count of negatives is odd, adjust the sum\n        if (negativeCount % 2 != 0) {\n            totalSum -= 2 * minAbsValue;\n        }\n\n        return totalSum;\n    }\n}\n"
    }
  },
  "1976": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    int countPaths(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& road : roads) {\n            const int u = road[0];\n            const int v = road[1];\n            const int w = road[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        return dijkstra(graph, 0, n - 1);\n    }\n\nprivate:\n    int dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n                 int dst) {\n        constexpr int kMod = 1'000'000'007;\n        vector<long> ways(graph.size());\n        vector<long> dist(graph.size(), LONG_MAX);\n\n        ways[src] = 1;\n        dist[src] = 0;\n        using P = pair<long, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    ways[v] = ways[u];\n                    minHeap.emplace(dist[v], v);\n                } else if (d + w == dist[v]) {\n                    ways[v] += ways[u];\n                    ways[v] %= kMod;\n                }\n        }\n\n        return ways[dst];\n    }\n};"
    }
  },
  "1977": {
    "solution": {
      "suffix-array": "class Solution {\n    public int numberOfCombinations(String num) {\n        if (num.charAt(0) == '0')\n            return 0;\n\n      int kMod = 1_000_000_007;\n      int n = num.length();\n        // dp[i][k] := the number of possible lists of integers ending in num[i] with\n        // the length of the last number being 1..k\n        long[][] dp = new long[n][n + 1];\n        // lcs[i][j] := the number of the same digits in num[i..n) and num[j..n)\n        int[][] lcs = new int[n + 1][n + 1];\n\n        // Step 1: Compute LCS array\n        for (int i = n - 1; i >= 0; --i)\n            for (int j = i + 1; j < n; ++j)\n                if (num.charAt(i) == num.charAt(j))\n                    lcs[i][j] = lcs[i + 1][j + 1] + 1;\n\n        // Step 2: Dynamic programming to count number of combinations\n        for (int i = 0; i < n; ++i)\n            for (int k = 1; k <= i + 1; ++k) {\n                dp[i][k] += dp[i][k - 1];\n                dp[i][k] %= kMod;\n                // The last number is num[s..i].\n              int s = i - k + 1;\n                if (num.charAt(s) == '0')\n                    // If the number starts with '0', skip it as it's invalid\n                    continue;\n                if (s == 0) {\n                    // If the whole string is considered, increment the count by 1\n                    dp[i][k] += 1;\n                    continue;\n                }\n                if (s < k) {\n                    // If the length k is not enough, add counts from num[0..s - 1]\n                    dp[i][k] += dp[s - 1][s];\n                    continue;\n                }\n              int left = lcs[s - k][s];\n                if (left >= k || num.charAt(s - k + left) <= num.charAt(s + left))\n                    // If num[s - k..s - 1] <= num[s..i], add counts from dp[s - 1][k]\n                    dp[i][k] += dp[s - 1][k];\n                else\n                    // Otherwise, add counts from dp[s - 1][k - 1]\n                    dp[i][k] += dp[s - 1][k - 1];\n                \n                dp[i][k] %= kMod;\n            }\n\n        return (int) dp[n - 1][n] % kMod;\n    }\n}\n"
    }
  },
  "1978": {
    "solution": {
      "database": ""
    }
  },
  "1979": {
    "solution": {
      "number-theory": "#include <algorithm>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int gcd(int a, int b) {\n        while (b != 0) {\n            int temp = b;\n            b = a % b;\n            a = temp;\n        }\n        return a;\n    }\n\n    int findGCD(vector<int>& nums) {\n        int minNum = *min_element(nums.begin(), nums.end());\n        int maxNum = *max_element(nums.begin(), nums.end());\n\n        return gcd(minNum, maxNum);\n    }\n};\n"
    }
  },
  "1980": {
    "solution": {
      "backtracking": ""
    }
  },
  "1981": {
    "solution": {
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private Integer[][] memo;\n\n    public int minimizeTheDifference(int[][] mat, int target) {\n        int rows = mat.length;\n        int cols = mat[0].length;\n        memo = new Integer[rows][5000]; \n\n        for (int[] row : mat) {\n            Arrays.sort(row);\n        }\n\n        return dfs(mat, target, 0, 0);\n    }\n\n    private int dfs(int[][] mat, int target, int row, int currentSum) {\n        if (row == mat.length) {\n            return Math.abs(currentSum - target);\n        }\n\n        // Memoization check\n        if (memo[row][currentSum] != null) {\n            return memo[row][currentSum];\n        }\n\n        int minDiff = Integer.MAX_VALUE;\n\n        // Explore each element in the current row\n        for (int num : mat[row]) {\n            int newSum = currentSum + num;\n            if (newSum - target > minDiff) break; // Prune if new sum exceeds current minDiff\n            \n            minDiff = Math.min(minDiff, dfs(mat, target, row + 1, newSum));\n        }\n\n        return memo[row][currentSum] = minDiff;\n    }\n}\n"
    }
  },
  "1982": {
    "solution": {
      "divide-and-conquer": "class Solution {\npublic:\n    vector<int> recoverArray(int n, vector<int>& sums) {\n        ranges::sort(sums);\n        return recover(sums);\n    }\n\nprivate:\n    vector<int> recover(const vector<int>& sums) {\n        if (sums.size() == 1) // sums[0] must be 0.\n            return {};\n\n        // Either num or -num must be in the final array.\n        //  num + sumsExcludingNum = sumsIncludingNum\n        // -num + sumsIncludingNum = sumsExcludingNum\n        unordered_map<int, int> count;\n        for (const int sum : sums)\n            ++count[sum];\n\n        const int num = sums[1] - sums[0];\n        vector<int> sumsExcludingNum;\n        vector<int> sumsIncludingNum;\n        bool chooseSumsIncludingNum = false;\n\n        for (const int sum : sums) {\n            if (count[sum] == 0)\n                continue;\n            --count[sum];\n            --count[sum + num];\n            sumsExcludingNum.push_back(sum);\n            sumsIncludingNum.push_back(sum + num);\n            if (sum + num == 0)\n                chooseSumsIncludingNum = true;\n        }\n\n        vector<int> recovered = recover(\n            chooseSumsIncludingNum ? sumsIncludingNum : sumsExcludingNum);\n        recovered.push_back(chooseSumsIncludingNum ? -num : num);\n        return recovered;\n    }\n};"
    }
  },
  "1983": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "1984": {
    "solution": {
      "sliding-window": "import java.util.Arrays;\n\nclass Solution {\n    public int minimumDifference(int[] nums, int k) {\n        Arrays.sort(nums);\n        int minDiff = Integer.MAX_VALUE;\n        for (int i = 0; i <= nums.length - k; i++) {\n            int diff = nums[i + k - 1] - nums[i];\n            minDiff = Math.min(minDiff, diff);\n        }\n\n        return minDiff;\n    }\n}\n"
    }
  },
  "1985": {
    "solution": {
      "quickselect": "class Solution {\n    Random rand;\n\n    public int compare(String a, String b) {\n        if (a.length() != b.length()) {\n            return b.length() - a.length();\n        } else {\n            return b.compareTo(a);\n        }\n    }\n\n    public String kthLargestNumber(String[] nums, int k) {\n        rand = new Random();\n        quickSort(nums, k, 0, nums.length);\n        return nums[k - 1];\n    }\n\n    public void quickSort(String[] nums, int k, int start, int end) {\n        int selected = start + rand.nextInt(end - start);\n        swap(nums, selected, start);\n        int idx = start;\n        for (int i = start + 1; i < end; i++) {\n            if (compare(nums[start], nums[i]) > 0) {\n                swap(nums, ++idx, i);\n            }\n        }\n        swap(nums, idx, start);\n        if (k == idx - start + 1) {\n            return;\n        } else if (k < idx - start + 1) {\n            quickSort(nums, k, start, idx);\n        } else {\n            quickSort(nums, k - (idx - start + 1), idx + 1, end);\n        }\n    }\n\n    public void swap(String[] nums, int a, int b) {\n        String temp = nums[a];\n        nums[a] = nums[b];\n        nums[b] = temp;\n    }\n}",
      "heap-(priority-queue)": "class Solution {\n\n  public String kthLargestNumber(String[] nums, int k) {\n    Queue<String> minHeap = new PriorityQueue<>(\n        (a, b) -> a.length() == b.length() ? a.compareTo(b) : a.length() - b.length());\n\n    for (final String num : nums) {\n      minHeap.offer(num);\n      if (minHeap.size() > k)\n        minHeap.poll();\n    }\n\n    return minHeap.poll();\n  }\n}"
    }
  },
  "1986": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1987": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1988": {
    "solution": {
      "database": ""
    }
  },
  "1989": {
    "solution": {
      "greedy": ""
    }
  },
  "1990": {
    "solution": {
      "database": ""
    }
  },
  "1991": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int findMiddleIndex(int[] nums) {\n        int totalSum = 0;\n        int leftSum = 0;\n\n        for (int num : nums) {\n            totalSum += num;\n        }\n\n        for (int i = 0; i < nums.length; i++) {\n            if (leftSum == totalSum - leftSum - nums[i]) {\n                return i;\n            }\n            leftSum += nums[i];\n        }\n\n        // If no middle index is found, return -1\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.findMiddleIndex(new int[]{2, 3, -1, 8, 4})); // Output: 3\n        System.out.println(solution.findMiddleIndex(new int[]{1, 2, 3})) ; // Output: -1\n    }\n}\n"
    }
  },
  "1992": {
    "solution": {
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private boolean[][] visited;\n\n    public int[][] findFarmland(int[][] land) {\n        int rows = land.length;\n        int cols = land[0].length;\n        visited = new boolean[rows][cols];\n\n        List<int[]> result = new ArrayList<>();\n\n        for (int r = 0; r < rows; r++) {\n            for (int c = 0; c < cols; c++) {\n                if (land[r][c] == 1 && !visited[r][c]) {\n                    int[] bounds = new int[4]; // {topRow, leftCol, bottomRow, rightCol}\n                    bounds[0] = r; // Initialize top-left row\n                    bounds[1] = c; // Initialize top-left col\n                    bounds[2] = r; // Initialize bottom-right row\n                    bounds[3] = c; // Initialize bottom-right col\n\n                    dfs(land, r, c, bounds);\n\n                    result.add(bounds);\n                }\n            }\n        }\n\n        return result.toArray(new int[result.size()][]);\n    }\n\n    private void dfs(int[][] land, int r, int c, int[] bounds) {\n        visited[r][c] = true;\n\n        // Update rectangle boundaries\n        bounds[0] = Math.min(bounds[0], r); // Update top row\n        bounds[1] = Math.min(bounds[1], c); // Update left column\n        bounds[2] = Math.max(bounds[2], r); // Update bottom row\n        bounds[3] = Math.max(bounds[3], c); // Update right column\n\n        for (int[] direction : DIRECTIONS) {\n            int newRow = r + direction[0];\n            int newCol = c + direction[1];\n\n            // Check bounds and whether the cell is unvisited farmland\n            if (newRow >= 0 && newRow < land.length && newCol >= 0 && newCol < land[0].length \n                && land[newRow][newCol] == 1 && !visited[newRow][newCol]) {\n                dfs(land, newRow, newCol, bounds);\n            }\n        }\n    }\n}\n"
    }
  },
  "1993": {
    "solution": {
      "tree": ""
    }
  },
  "1994": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1995": {
    "solution": {
      "enumeration": ""
    }
  },
  "1996": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "1997": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "1998": {
    "solution": {
      "union-find": ""
    }
  },
  "1999": {
    "solution": {
      "enumeration": ""
    }
  },
  "2000": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2001": {
    "solution": {
      "number-theory": ""
    }
  },
  "2002": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2003": {
    "solution": {
      "union-find": ""
    }
  },
  "2004": {
    "solution": {
      "database": ""
    }
  },
  "2005": {
    "solution": {
      "game-theory": ""
    }
  },
  "2006": {
    "solution": {
      "counting": ""
    }
  },
  "2007": {
    "solution": {
      "greedy": ""
    }
  },
  "2008": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2009": {
    "solution": {
      "sliding-window": "import java.util.Arrays;\nimport java.util.HashSet;\nimport java.util.Set;\n\nclass Solution {\n    public int minOperations(int[] nums) {\n        Set<Integer> set = new HashSet<>();\n        for (int num : nums) {\n            set.add(num);\n        }\n        int[] uniqueNums = new int[set.size()];\n        int index = 0;\n        for (int num : set) {\n            uniqueNums[index++] = num;\n        }\n        Arrays.sort(uniqueNums);\n\n        int maxLength = 0;\n        int left = 0;\n        for (int right = 0; right < uniqueNums.length; ++right) {\n            while (uniqueNums[right] - uniqueNums[left] >= nums.length) {\n                left++;\n            }\n            maxLength = Math.max(maxLength, right - left + 1);\n        }\n\n        return nums.length - maxLength;\n    }\n}\n"
    }
  },
  "2010": {
    "solution": {
      "database": ""
    }
  },
  "2011": {
    "solution": {
      "string": ""
    }
  },
  "2012": {
    "solution": {
      "array": ""
    }
  },
  "2013": {
    "solution": {
      "counting": ""
    }
  },
  "2014": {
    "solution": {
      "backtracking": "class Solution {\npublic:\n    string longestSubsequenceRepeatedK(string s, int k) {\n        string ans;\n        vector<int> count(26);\n        vector<char> possibleChars;\n        queue<string> q{{\"\"}};\n\n        for (const char c : s)\n            ++count[c - 'a'];\n\n        for (char c = 'a'; c <= 'z'; ++c)\n            if (count[c - 'a'] >= k)\n                possibleChars.push_back(c);\n\n        while (!q.empty()) {\n            const string currSubseq = q.front();\n            q.pop();\n            if (currSubseq.length() * k > s.length())\n                return ans;\n            for (const char c : possibleChars) {\n                const string& newSubseq = currSubseq + c;\n                if (isSubsequence(newSubseq, s, k)) {\n                    q.push(newSubseq);\n                    ans = newSubseq;\n                }\n            }\n        }\n\n        return ans;\n    }\n\nprivate:\n    bool isSubsequence(const string& subseq, string& s, int k) {\n        int i = 0;\n        for (const char c : s)\n            if (c == subseq[i])\n                if (++i == subseq.length()) {\n                    if (--k == 0)\n                        return true;\n                    i = 0;\n                }\n        return false;\n    }\n};"
    }
  },
  "2015": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2016": {
    "solution": {
      "array": ""
    }
  },
  "2017": {
    "solution": {
      "matrix": ""
    }
  },
  "2018": {
    "solution": {
      "matrix": ""
    }
  },
  "2019": {
    "solution": {
      "stack": ""
    }
  },
  "2020": {
    "solution": {
      "database": ""
    }
  },
  "2021": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2022": {
    "solution": {
      "matrix": "class Solution {\n  public int[][] construct2DArray(int[] original, int m, int n) {\n    if (original.length != m * n)\n      return new int[][] {};\n\n    int[][] ans = new int[m][n];\n\n    for (int i = 0; i < original.length; ++i)\n      ans[i / n][i % n] = original[i];\n\n    return ans;\n  }\n}"
    }
  },
  "2023": {
    "solution": {
      "counting": ""
    }
  },
  "2024": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxConsecutiveAnswers(String answerKey, int k) {\n        return Math.max(maxConsecutiveChar(answerKey, k, 'T'), maxConsecutiveChar(answerKey, k, 'F'));\n    }\n\n    private int maxConsecutiveChar(String answerKey, int k, char ch) {\n        int maxLen = 0;\n        int left = 0, right = 0;\n        int flipCount = 0;\n\n        while (right < answerKey.length()) {\n            if (answerKey.charAt(right) != ch) {\n                flipCount++;\n            }\n\n            while (flipCount > k) {\n                if (answerKey.charAt(left) != ch) {\n                    flipCount--;\n                }\n                left++;\n            }\n\n            maxLen = Math.max(maxLen, right - left + 1);\n            right++;\n        }\n\n        return maxLen;\n    }\n}\n"
    }
  },
  "2025": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2026": {
    "solution": {
      "database": ""
    }
  },
  "2027": {
    "solution": {
      "greedy": ""
    }
  },
  "2028": {
    "solution": {
      "math": ""
    }
  },
  "2029": {
    "solution": {
      "game-theory": "class Solution {\npublic:\n    bool stoneGameIX(vector<int>& stones) {\n        vector<int> count(3);\n\n        for (const int stone : stones)\n            ++count[stone % 3];\n\n        if (count[0] % 2 == 0)\n            return min(count[1], count[2]) > 0;\n        return abs(count[1] - count[2]) > 2;\n    }\n};"
    }
  },
  "2030": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2031": {
    "solution": {
      "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int subarraysWithMoreZerosThanOnes(int[] nums) {\n  int kMod = 1_000_000_007;\n  int n = nums.length;\n    int ans = 0;\n    int prefix = 0;\n    FenwickTree tree = new FenwickTree(2 * n + 1);\n    tree.add(remap(0, n), 1);\n\n    for (final int num : nums) {\n      prefix += num == 0 ? -1 : 1;\n      ans += tree.get(remap(prefix - 1, n));\n      ans %= kMod;\n      tree.add(remap(prefix, n), 1);\n    }\n\n    return ans;\n  }\n\n  private int remap(int i, int n) {\n    return i + n + 1;\n  }\n}"
    }
  },
  "2032": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2033": {
    "solution": {
      "matrix": ""
    }
  },
  "2034": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2035": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2036": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2037": {
    "solution": {
      "greedy": ""
    }
  },
  "2038": {
    "solution": {
      "game-theory": "class Solution {\npublic:\n    bool winnerOfGame(string colors) {\n        int countA = 0, countB = 0;\n        \n        for (int i = 1; i < colors.size() - 1; ++i) {\n            if (colors[i] == 'A' && colors[i - 1] == 'A' && colors[i + 1] == 'A') {\n                countA++;\n            }\n            if (colors[i] == 'B' && colors[i - 1] == 'B' && colors[i + 1] == 'B') {\n                countB++;\n            }\n        }\n        \n        return countA > countB;  // A wins if it can remove more pieces\n    }\n};\n"
    }
  },
  "2039": {
    "solution": {
      "graph": ""
    }
  },
  "2040": {
    "solution": {
      "array": ""
    }
  },
  "2041": {
    "solution": {
      "database": ""
    }
  },
  "2042": {
    "solution": {
      "string": ""
    }
  },
  "2043": {
    "solution": {
      "design": ""
    }
  },
  "2044": {
    "solution": {
      "backtracking": ""
    }
  },
  "2045": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    int secondMinimum(int n, vector<vector<int>>& edges, int time, int change) {\n        vector<vector<int>> graph(n + 1);\n        queue<pair<int, int>> q{{{1, 0}}};\n        // minTime[u][0] := the first minimum time to reach the node u\n        // minTime[u][1] := the second minimum time to reach the node u\n        vector<vector<int>> minTime(n + 1, vector<int>(2, INT_MAX));\n        minTime[1][0] = 0;\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n\n        while (!q.empty()) {\n            const auto [u, prevTime] = q.front();\n            q.pop();\n            // Start from green.\n            // If `numChangeSignal` is odd, now red.\n            // If `numChangeSignal` is even, now green.\n            const int numChangeSignal = prevTime / change;\n            const int waitTime =\n                numChangeSignal % 2 == 0 ? 0 : change - prevTime % change;\n            const int newTime = prevTime + waitTime + time;\n            for (const int v : graph[u])\n                if (newTime < minTime[v][0]) {\n                    minTime[v][0] = newTime;\n                    q.emplace(v, newTime);\n                } else if (minTime[v][0] < newTime && newTime < minTime[v][1]) {\n                    if (v == n)\n                        return newTime;\n                    minTime[v][1] = newTime;\n                    q.emplace(v, newTime);\n                }\n        }\n\n        throw;\n    }\n};"
    }
  },
  "2046": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2047": {
    "solution": {
      "string": ""
    }
  },
  "2048": {
    "solution": {
      "backtracking": ""
    }
  },
  "2049": {
    "solution": {
      "tree": ""
    }
  },
  "2050": {
    "solution": {
      "topological-sort": ""
    }
  },
  "2051": {
    "solution": {
      "database": ""
    }
  },
  "2052": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2053": {
    "solution": {
      "counting": "class Solution {\npublic:\n    string kthDistinct(vector<string>& arr, int k) {\n        unordered_map<string, int> freq; \n        \n        for (const string& str : arr) {\n            ++freq[str];\n        }\n\n        vector<string> distinctStrings;\n        for (const string& str : arr) {\n            if (freq[str] == 1) {\n                distinctStrings.push_back(str);\n            }\n        }\n\n        // Return the k-th distinct string if it exists\n        return (k <= distinctStrings.size()) ? distinctStrings[k - 1] : \"\";\n    }\n};\n"
    }
  },
  "2054": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2055": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2056": {
    "solution": {
      "backtracking": ""
    }
  },
  "2057": {
    "solution": {
      "array": ""
    }
  },
  "2058": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    vector<int> nodesBetweenCriticalPoints(ListNode* head) {\n        if (!head || !head->next || !head->next->next)\n            return {-1, -1};\n\n        vector<int> criticalIndices;\n        ListNode* prev = head;\n        ListNode* curr = head->next;\n        int index = 1;\n\n        while (curr->next) {\n            if ((curr->val > prev->val && curr->val > curr->next->val) ||\n                (curr->val < prev->val && curr->val < curr->next->val)) {\n                criticalIndices.push_back(index);\n            }\n            prev = curr;\n            curr = curr->next;\n            index++;\n        }\n\n        if (criticalIndices.size() < 2)\n            return {-1, -1};\n\n        int minDist = INT_MAX;\n        for (int i = 1; i < criticalIndices.size(); ++i) {\n            minDist = min(minDist, criticalIndices[i] - criticalIndices[i - 1]);\n        }\n\n        int maxDist = criticalIndices.back() - criticalIndices.front();\n        return {minDist, maxDist};\n    }\n};\n"
    }
  },
  "2059": {
    "solution": {
      "breadth-first-search": ""
    }
  },
  "2060": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2061": {
    "solution": {
      "matrix": ""
    }
  },
  "2062": {
    "solution": {
      "hash-table": ""
    }
  },
  "2063": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    long long countVowels(string word) {\n        long long totalVowels = 0;\n        int n = word.size();\n\n        // Iterate through all possible substrings\n        for (int i = 0; i < n; ++i) {\n            // Check each character of the substring\n            for (int j = i; j < n; ++j) {\n                if (isVowel(word[j])) {\n                    totalVowels++;\n                }\n            }\n        }\n        return totalVowels;\n    }\n\nprivate:\n    bool isVowel(char c) {\n        return c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u' ||\n               c == 'A' || c == 'E' || c == 'I' || c == 'O' || c == 'U';\n    }\n};"
    }
  },
  "2064": {
    "solution": {
      "array": ""
    }
  },
  "2065": {
    "solution": {
      "backtracking": ""
    }
  },
  "2066": {
    "solution": {
      "database": ""
    }
  },
  "2067": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2068": {
    "solution": {
      "counting": "class Solution {\n public:\n  bool checkAlmostEquivalent(string word1, string word2) {\n    vector<int> count(26);\n\n    for (const char c : word1)\n      ++count[c - 'a'];\n\n    for (const char c : word2)\n      --count[c - 'a'];\n\n    return ranges::all_of(count, [](int freq) { return abs(freq) <= 3; });\n  }\n};"
    }
  },
  "2069": {
    "solution": {
      "design": ""
    }
  },
  "2070": {
    "solution": {
      "sorting": ""
    }
  },
  "2071": {
    "solution": {
      "monotonic-queue": "import java.util.Arrays;\nimport java.util.ArrayDeque;\nimport java.util.Deque;\n\nclass Solution {\n    private int[] tasks;\n    private int[] workers;\n    private int strength;\n    private int pills;\n    private int taskCount;\n    private int workerCount;\n\n    public int maxTaskAssign(int[] tasks, int[] workers, int pills, int strength) {\n        Arrays.sort(tasks);\n        Arrays.sort(workers);\n        this.tasks = tasks;\n        this.workers = workers;\n        this.strength = strength;\n        this.pills = pills;\n        taskCount = tasks.length; \n        workerCount = workers.length; \n\n        int left = 0, right = Math.min(workerCount, taskCount);\n        while (left < right) {\n            int mid = (left + right + 1) / 2; \n            if (check(mid)) {\n                left = mid; \n            } else {\n                right = mid - 1;\n            }\n        }\n\n        return left; \n    }\n\n    private boolean check(int x) {\n        int taskIdx = 0;\n        Deque<Integer> taskQueue = new ArrayDeque<>();\n        int remainingPills = pills;\n\n        for (int workerIdx = workerCount - x; workerIdx < workerCount; ++workerIdx) {\n            while (taskIdx < x && tasks[taskIdx] <= workers[workerIdx] + strength) {\n                taskQueue.offer(tasks[taskIdx++]); \n            }\n            if (taskQueue.isEmpty()) {\n                return false;\n            }\n            if (taskQueue.peekFirst() <= workers[workerIdx]) {\n                taskQueue.pollFirst(); \n            } else if (remainingPills == 0) {\n                return false; \n            } else {\n                --remainingPills; \n                taskQueue.pollLast();\n            }\n        }\n      \n        return true; \n    }\n}"
    }
  },
  "2072": {
    "solution": {
      "database": ""
    }
  },
  "2073": {
    "solution": {
      "queue": ""
    }
  },
  "2074": {
    "solution": {
      "linked-list": ""
    }
  },
  "2075": {
    "solution": {
      "string": ""
    }
  },
  "2076": {
    "solution": {
      "union-find": ""
    }
  },
  "2077": {
    "solution": {
      "graph": ""
    }
  },
  "2078": {
    "solution": {
      "greedy": ""
    }
  },
  "2079": {
    "solution": {
      "array": ""
    }
  },
  "2080": {
    "solution": {
      "design": ""
    }
  },
  "2081": {
    "solution": {
      "enumeration": ""
    }
  },
  "2082": {
    "solution": {
      "database": ""
    }
  },
  "2083": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2084": {
    "solution": {
      "database": ""
    }
  },
  "2085": {
    "solution": {
      "counting": ""
    }
  },
  "2086": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2087": {
    "solution": {
      "greedy": ""
    }
  },
  "2088": {
    "solution": {
      "matrix": ""
    }
  },
  "2089": {
    "solution": {
      "sorting": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> targetIndices(vector<int>& nums, int target) {\n        sort(nums.begin(), nums.end());\n        \n        vector<int> result;\n        int n = nums.size();\n        \n        int left = lower_bound(nums.begin(), nums.end(), target) - nums.begin();\n        if (left == n || nums[left] != target) return result;\n        while (left < n && nums[left] == target) {\n            result.push_back(left);\n            left++;\n        }\n        \n        return result;\n    }\n};\n"
    }
  },
  "2090": {
    "solution": {
      "sliding-window": "class Solution {\n    public int[] getAverages(int[] nums, int k) {\n        int n = nums.length;\n        int[] result = new int[n];\n        Arrays.fill(result, -1);\n\n        if (2 * k + 1 > n) return result;  \n        long windowSum = 0;\n        int windowSize = 2 * k + 1;\n        for (int i = 0; i < windowSize; i++) {\n            windowSum += nums[i];\n        }\n        result[k] = (int)(windowSum / windowSize);\n        for (int i = k + 1; i < n - k; i++) {\n            windowSum = windowSum - nums[i - k - 1] + nums[i + k];\n            result[i] = (int)(windowSum / windowSize);\n        }\n\n        return result;\n    }\n}\n"
    }
  },
  "2091": {
    "solution": {
      "greedy": ""
    }
  },
  "2092": {
    "solution": {
      "union-find": ""
    }
  },
  "2093": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    int minimumCost(int n, vector<vector<int>>& E, int d) {\n        vector<unordered_map<int, int>> G(n);\n        for (auto &e : E) {\n            int u = e[0], v = e[1], w = e[2];\n            G[u][v] = w;\n            G[v][u] = w;\n        }\n        vector<vector<int>> dist(d + 1, vector<int>(n, INT_MAX));\n        auto dijkstra = [&](int i) {\n            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;\n            pq.emplace(0, 0);\n            dist[i][0] = 0;\n            while (pq.size()) {\n                auto [cost, u] = pq.top();\n                pq.pop();\n                if (cost > dist[i][u]) continue;\n                for (auto &[v, w] : G[u]) {\n                    int keep = cost + w, use = i > 0 ? dist[i - 1][u] + w / 2 : INT_MAX, newCost = min(use, keep);\n                    if (dist[i][v] > newCost) {\n                        dist[i][v] = newCost;\n                        pq.emplace(dist[i][v], v);\n                    }\n                }\n            }\n        };\n        for (int i = 0; i <= d; ++i) dijkstra(i);\n        return dist[d][n - 1] == INT_MAX ? -1 : dist[d][n - 1];\n    }\n};"
    }
  },
  "2094": {
    "solution": {
      "enumeration": ""
    }
  },
  "2095": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2096": {
    "solution": {
      "tree": ""
    }
  },
  "2097": {
    "solution": {
      "eulerian-circuit": "class Solution {\n    public int[][] validArrangement(int[][] pairs) {\n        List<int[]> ans = new ArrayList<>();\n        Map<Integer, Stack<Integer>> graph = new HashMap<>();\n        Map<Integer, Integer> outDegree = new HashMap<>();\n        Map<Integer, Integer> inDegrees = new HashMap<>();\n\n        for (int[] pair : pairs) {\n          int start = pair[0];\n          int end = pair[1];\n            graph.putIfAbsent(start, new Stack<>());\n            graph.get(start).push(end);\n            outDegree.merge(start, 1, Integer::sum);\n            inDegrees.merge(end, 1, Integer::sum);\n        }\n\n      int startNode = getStartNode(graph, outDegree, inDegrees, pairs);\n        eulerDFS(graph, startNode, ans);\n        Collections.reverse(ans);\n        return ans.stream().toArray(int[][]::new);\n    }\n\n    private int getStartNode(Map<Integer, Stack<Integer>> graph, Map<Integer, Integer> outDegree,\n            Map<Integer, Integer> inDegrees, int[][] pairs) {\n        for (final int u : graph.keySet())\n            if (outDegree.getOrDefault(u, 0) - inDegrees.getOrDefault(u, 0) == 1)\n                return u;\n        return pairs[0][0];\n    }\n\n    private void eulerDFS(Map<Integer, Stack<Integer>> graph, int u, List<int[]> ans) {\n        Stack<Integer> stack = graph.get(u);\n        while (stack != null && !stack.isEmpty()) {\n          int v = stack.pop();\n            eulerDFS(graph, v, ans);\n            ans.add(new int[] { u, v });\n        }\n    }\n}"
    }
  },
  "2098": {
    "solution": {
      "greedy": ""
    }
  },
  "2099": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2100": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2101": {
    "solution": {
      "geometry": ""
    }
  },
  "2102": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2103": {
    "solution": {
      "hash-table": ""
    }
  },
  "2104": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public long subArrayRanges(int[] nums) {\n        return subarraySum(nums, '<') - subarraySum(nums, '>');\n    }\n\n    private long subarraySum(int[] A, char op) {\n        int n = A.length;\n        long res = 0;\n        int[] prev = new int[n];\n        int[] next = new int[n];\n        Deque<Integer> stack = new ArrayDeque<>();\n\n        Arrays.fill(prev, -1);\n        Arrays.fill(next, n);\n\n        for (int i = 0; i < n; ++i) {\n            while (!stack.isEmpty() && func(op, A[stack.peek()], A[i])) {\n                int index = stack.pop();\n                next[index] = i;\n            }\n            if (!stack.isEmpty())\n                prev[i] = stack.peek();\n            stack.push(i);\n        }\n\n        for (int i = 0; i < n; ++i)\n            res += (long) A[i] * (i - prev[i]) * (next[i] - i);\n\n        return res;\n    }\n\n    private boolean func(char op, int a, int b) {\n        if (op == '<')\n            return a < b;\n        return a > b;\n    }\n}"
    }
  },
  "2105": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2106": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxTotalFruits(int[][] fruits, int startPos, int k) {\n      int maxRight = Math.max(startPos, fruits[fruits.length - 1][0]);\n        int ans = 0;\n        int[] amounts = new int[1 + maxRight];\n        int[] prefix = new int[2 + maxRight];\n\n        for (int[] dp : fruits)\n            amounts[dp[0]] = dp[1];\n\n        for (int i = 0; i + 1 < prefix.length; ++i)\n            prefix[i + 1] = prefix[i] + amounts[i];\n\n      int maxRightSteps = Math.min(maxRight - startPos, k);\n        for (int rightSteps = 0; rightSteps <= maxRightSteps; ++rightSteps) {\n          int leftSteps = Math.max(0, k - 2 * rightSteps);\n            ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\n        }\n\n      int maxLeftSteps = Math.min(startPos, k);\n        for (int leftSteps = 0; leftSteps <= maxLeftSteps; ++leftSteps) {\n          int rightSteps = Math.max(0, k - 2 * leftSteps);\n            ans = Math.max(ans, getFruits(startPos, maxRight, leftSteps, rightSteps, prefix));\n        }\n\n        return ans;\n    }\n\n    private int getFruits(int startPos, int maxRight, int leftSteps, int rightSteps, int[] prefix) {\n      int left = Math.max(0, startPos - leftSteps);\n      int right = Math.min(maxRight, startPos + rightSteps);\n        return prefix[right + 1] - prefix[left];\n    }\n}"
    }
  },
  "2107": {
    "solution": {
      "sliding-window": "class Solution {\n    public int shareCandies(int[] candies, int k) {\n        Map<Integer, Integer> count = new HashMap<>();\n        int n = candies.length;\n        for (int i = k; i < n; ++i) {\n            count.merge(candies[i], 1, Integer::sum);\n        }\n        int ans = count.size();\n        for (int i = k; i < candies.length; ++i) {\n            if (count.merge(candies[i], -1, Integer::sum) == 0) {\n                count.remove(candies[i]);\n            }\n            count.merge(candies[i - k], 1, Integer::sum);\n            ans = Math.max(ans, count.size());\n        }\n        return ans;\n    }\n}"
    }
  },
  "2108": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2109": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2110": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2111": {
    "solution": {
      "array": ""
    }
  },
  "2112": {
    "solution": {
      "database": ""
    }
  },
  "2113": {
    "solution": {
      "array": ""
    }
  },
  "2114": {
    "solution": {
      "string": ""
    }
  },
  "2115": {
    "solution": {
      "topological-sort": ""
    }
  },
  "2116": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    bool canBeValid(string s, string locked) {\n        int n = s.size();\n        \n        if (n % 2 != 0) {\n            return false;  // An odd length string can never be valid\n        }\n        \n        // Forward pass: ensure the number of open parentheses is balanced\n        int openCount = 0;\n        for (int i = 0; i < n; ++i) {\n            if (s[i] == '(' || locked[i] == '0') {\n                openCount++;\n            } else {\n                openCount--;\n            }\n            \n            if (openCount < 0) {\n                return false;  // More closing parentheses than opening\n            }\n        }\n        \n        // Backward pass: ensure there are enough closing parentheses\n        openCount = 0;\n        for (int i = n - 1; i >= 0; --i) {\n            if (s[i] == ')' || locked[i] == '0') {\n                openCount++;\n            } else {\n                openCount--;\n            }\n            \n            if (openCount < 0) {\n                return false;  // More opening parentheses than closing\n            }\n        }\n        \n        return true;\n    }\n};"
    }
  },
  "2117": {
    "solution": {
      "math": ""
    }
  },
  "2118": {
    "solution": {
      "database": ""
    }
  },
  "2119": {
    "solution": {
      "math": "class Solution {\npublic:\n    bool isSameAfterReversals(int num) { return num == 0 || num % 10; }\n};\n"
    }
  },
  "2120": {
    "solution": {
      "string": ""
    }
  },
  "2121": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2122": {
    "solution": {
      "enumeration": ""
    }
  },
  "2123": {
    "solution": {
      "matrix": ""
    }
  },
  "2124": {
    "solution": {
      "string": ""
    }
  },
  "2125": {
    "solution": {
      "matrix": ""
    }
  },
  "2126": {
    "solution": {
      "greedy": ""
    }
  },
  "2127": {
    "solution": {
      "topological-sort": ""
    }
  },
  "2128": {
    "solution": {
      "matrix": "class Solution {\n    public boolean removeOnes(int[][] grid) {\n        Set<String> s = new HashSet<>();\n        int n = grid[0].length;\n        for (var row : grid) {\n            var cs = new char[n];\n            for (int i = 0; i < n; ++i) {\n                cs[i] = (char) (row[0] ^ row[i]);\n            }\n            s.add(String.valueOf(cs));\n        }\n        return s.size() == 1;\n    }\n}"
    }
  },
  "2129": {
    "solution": {
      "string": ""
    }
  },
  "2130": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2131": {
    "solution": {
      "counting": ""
    }
  },
  "2132": {
    "solution": {
      "matrix": ""
    }
  },
  "2133": {
    "solution": {
      "matrix": "class Solution {\n  public boolean checkValid(int[][] matrix) {\n    final int n = matrix.length;\n\n    for (int i = 0; i < n; ++i) {\n      Set<Integer> row = new HashSet<>();\n      Set<Integer> col = new HashSet<>();\n      for (int j = 0; j < n; ++j) {\n        row.add(matrix[i][j]);\n        col.add(matrix[j][i]);\n      }\n      if (Math.min(row.size(), col.size()) < n)\n        return false;\n    }\n\n    return true;\n  }\n}"
    }
  },
  "2134": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minSwaps(int[] nums) {\n      int n = nums.length;\n      int k = (int) Arrays.stream(nums).filter(a -> a == 1).count();\n        int ones = 0;\n        int maxOnes = 0;\n\n        for (int i = 0; i < n * 2; ++i) {\n            if (i >= k && nums[(i - k) % n] == 1)\n                --ones;\n            if (nums[i % n] == 1)\n                ++ones;\n            maxOnes = Math.max(maxOnes, ones);\n        }\n\n        return k - maxOnes;\n    }\n}"
    }
  },
  "2135": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2136": {
    "solution": {
      "greedy": ""
    }
  },
  "2137": {
    "solution": {
      "array": ""
    }
  },
  "2138": {
    "solution": {
      "string": ""
    }
  },
  "2139": {
    "solution": {
      "greedy": ""
    }
  },
  "2140": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2141": {
    "solution": {
      "greedy": ""
    }
  },
  "2142": {
    "solution": {
      "database": ""
    }
  },
  "2143": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2144": {
    "solution": {
      "greedy": ""
    }
  },
  "2145": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2146": {
    "solution": {
      "matrix": ""
    }
  },
  "2147": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2148": {
    "solution": {
      "sorting": ""
    }
  },
  "2149": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2150": {
    "solution": {
      "counting": ""
    }
  },
  "2151": {
    "solution": {
      "backtracking": ""
    }
  },
  "2152": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2153": {
    "solution": {
      "database": ""
    }
  },
  "2154": {
    "solution": {
      "sorting": ""
    }
  },
  "2155": {
    "solution": {
      "array": ""
    }
  },
  "2156": {
    "solution": {
      "sliding-window": "class Solution {\n    public String subStrHash(String s, int power, int modulo, int k, int hashValue) {\n        long maxPower = 1;\n        long hash = 0;\n        int bestLeft = -1;\n\n        for (int i = s.length() - 1; i >= 0; --i) {\n            hash = (hash * power + val(s.charAt(i))) % modulo;\n            if (i + k < s.length())\n                hash = (hash - val(s.charAt(i + k)) * maxPower % modulo + modulo) % modulo;\n            else\n                maxPower = maxPower * power % modulo;\n            if (hash == hashValue)\n                bestLeft = i;\n        }\n\n        return s.substring(bestLeft, bestLeft + k);\n    }\n\n    private int val(char c) {\n        return c - 'a' + 1;\n    }\n}"
    }
  },
  "2157": {
    "solution": {
      "union-find": ""
    }
  },
  "2158": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2159": {
    "solution": {
      "database": ""
    }
  },
  "2160": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minimumSum(int num) {\n        vector<int> digits;\n        \n        while (num > 0) {\n            digits.push_back(num % 10);\n            num /= 10;\n        }\n        \n        sort(digits.begin(), digits.end());\n        \n        int num1 = digits[0] * 10 + digits[2];\n        int num2 = digits[1] * 10 + digits[3];\n        \n        return num1 + num2;\n    }\n};"
    }
  },
  "2161": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2162": {
    "solution": {
      "enumeration": ""
    }
  },
  "2163": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2164": {
    "solution": {
      "sorting": "#include <vector>\n#include <algorithm>\n\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> sortEvenOdd(vector<int>& nums) {\n        vector<int> even, odd;\n\n        for (int i = 0; i < nums.size(); i++) {\n            if (i % 2 == 0) {\n                even.push_back(nums[i]);\n            } else {\n                odd.push_back(nums[i]);\n            }\n        }\n\n        sort(even.begin(), even.end());\n        sort(odd.rbegin(), odd.rend()); // reverse sort\n\n        int evenIndex = 0, oddIndex = 0;\n        for (int i = 0; i < nums.size(); i++) {\n            if (i % 2 == 0) {\n                nums[i] = even[evenIndex++];\n            } else {\n                nums[i] = odd[oddIndex++];\n            }\n        }\n\n        return nums;\n    }\n};\n"
    }
  },
  "2165": {
    "solution": {
      "sorting": "class Solution {\npublic:\n    long long smallestNumber(long long num) {\n        string s = to_string(abs(num));\n        ranges::sort(s, [&](int a, int b) { return num < 0 ? a > b : a < b; });\n        if (num > 0)\n            swap(s[0], s[s.find_first_not_of('0')]);\n        return stoll(s) * (num < 0 ? -1 : 1);\n    }\n};"
    }
  },
  "2166": {
    "solution": {
      "design": ""
    }
  },
  "2167": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2168": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "2169": {
    "solution": {
      "math": ""
    }
  },
  "2170": {
    "solution": {
      "counting": ""
    }
  },
  "2171": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2172": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2173": {
    "solution": {
      "database": ""
    }
  },
  "2174": {
    "solution": {
      "matrix": "class Solution {\n    public int removeOnes(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int state = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    state |= 1 << (i * n + j);\n                }\n            }\n        }\n        Deque<Integer> q = new ArrayDeque<>();\n        q.offer(state);\n        Set<Integer> vis = new HashSet<>();\n        vis.add(state);\n        int ans = 0;\n        while (!q.isEmpty()) {\n            for (int k = q.size(); k > 0; --k) {\n                state = q.poll();\n                if (state == 0) {\n                    return ans;\n                }\n                for (int i = 0; i < m; ++i) {\n                    for (int j = 0; j < n; ++j) {\n                        if (grid[i][j] == 0) {\n                            continue;\n                        }\n                        int nxt = state;\n                        for (int r = 0; r < m; ++r) {\n                            nxt &= ~(1 << (r * n + j));\n                        }\n                        for (int c = 0; c < n; ++c) {\n                            nxt &= ~(1 << (i * n + c));\n                        }\n                        if (!vis.contains(nxt)) {\n                            vis.add(nxt);\n                            q.offer(nxt);\n                        }\n                    }\n                }\n            }\n            ++ans;\n        }\n        return -1;\n    }\n}"
    }
  },
  "2175": {
    "solution": {
      "database": ""
    }
  },
  "2176": {
    "solution": {
      "array": ""
    }
  },
  "2177": {
    "solution": {
      "math": ""
    }
  },
  "2178": {
    "solution": {
      "backtracking": ""
    }
  },
  "2179": {
    "solution": {
      "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public long goodTriplets(int[] nums1, int[] nums2) {\n  int n = nums1.length;\n    long ans = 0;\n    Map<Integer, Integer> numToIndex = new HashMap<>();\n    int[] nums = new int[n];\n    int[] leftSmaller = new int[n];\n    int[] rightLarger = new int[n];\n    FenwickTree tree1 = new FenwickTree(n);\n    FenwickTree tree2 = new FenwickTree(n);\n\n    for (int i = 0; i < n; ++i)\n      numToIndex.put(nums1[i], i);\n    for (int i = 0; i < n; ++i)\n      nums[i] = numToIndex.get(nums2[i]);\n\n    for (int i = 0; i < n; ++i) {\n      leftSmaller[i] = tree1.get(nums[i]);\n      tree1.add(nums[i] + 1, 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      rightLarger[i] = tree2.get(n) - tree2.get(nums[i]);\n      tree2.add(nums[i] + 1, 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans += (long) leftSmaller[i] * rightLarger[i];\n\n    return ans;\n  }\n}"
    }
  },
  "2180": {
    "solution": {
      "math": ""
    }
  },
  "2181": {
    "solution": {
      "linked-list": ""
    }
  },
  "2182": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2183": {
    "solution": {
      "number-theory": ""
    }
  },
  "2184": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2185": {
    "solution": {
      "string-matching": ""
    }
  },
  "2186": {
    "solution": {
      "counting": ""
    }
  },
  "2187": {
    "solution": {
      "array": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    bool canCompleteTrips(const vector<int>& buses, long long time, int trips) {\n        long long completedTrips = 0;\n        for (int bus : buses) {\n            completedTrips += time / bus;\n            if (completedTrips >= trips) {\n                return true;\n            }\n        }\n        return completedTrips >= trips;\n    }\n    \n    long long minimumTime(vector<int>& buses, int trips) {\n        long long left = 1, right = (long long) *min_element(buses.begin(), buses.end()) * trips;\n        \n        while (left < right) {\n            long long mid = left + (right - left) / 2;\n            \n            if (canCompleteTrips(buses, mid, trips)) {\n                right = mid; \n            } else {\n                left = mid + 1; \n            }\n        }\n        \n        return left; \n    }\n};\n"
    }
  },
  "2188": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2189": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2190": {
    "solution": {
      "hash-table": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mostFrequent(vector<int>& nums, int key) {\n        unordered_map<int, int> freqMap;\n        \n        for (int i = 0; i < nums.size() - 1; ++i) {\n            if (nums[i] == key) {\n                freqMap[nums[i + 1]]++;\n            }\n        }\n        \n        int mostFrequentNum = -1;\n        int maxFreq = 0;\n        \n        for (const auto& entry : freqMap) {\n            if (entry.second > maxFreq) {\n                maxFreq = entry.second;\n                mostFrequentNum = entry.first;\n            }\n        }\n        \n        return mostFrequentNum;\n    }\n};"
    }
  },
  "2191": {
    "solution": {
      "sorting": ""
    }
  },
  "2192": {
    "solution": {
      "graph": "class Solution {\npublic:\n    vector<vector<int>> getAncestors(int n, vector<vector<int>>& edges) {\n        vector<vector<int>> ans(n);\n        vector<vector<int>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n        }\n\n        for (int i = 0; i < n; ++i)\n            dfs(graph, i, i, vector<bool>(n), ans);\n\n        return ans;\n    }\n\nprivate:\n    void dfs(const vector<vector<int>>& graph, int u, int ancestor,\n             vector<bool>&& seen, vector<vector<int>>& ans) {\n        seen[u] = true;\n        for (const int v : graph[u]) {\n            if (seen[v])\n                continue;\n            ans[v].push_back(ancestor);\n            dfs(graph, v, ancestor, std::move(seen), ans);\n        }\n    }\n};"
    }
  },
  "2193": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2194": {
    "solution": {
      "string": ""
    }
  },
  "2195": {
    "solution": {
      "greedy": ""
    }
  },
  "2196": {
    "solution": {
      "tree": ""
    }
  },
  "2197": {
    "solution": {
      "stack": ""
    }
  },
  "2198": {
    "solution": {
      "math": ""
    }
  },
  "2199": {
    "solution": {
      "database": ""
    }
  },
  "2200": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2201": {
    "solution": {
      "hash-table": ""
    }
  },
  "2202": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int maximumTop(vector<int>& nums, int k) {\n        const int n = nums.size();\n        // After taking k elements, if there's something left, then return\n        // nums[k]. Otherwise, return -1.\n        if (k == 0 || k == 1)\n            return n == k ? -1 : nums[k];\n        // Remove then add even number of times.\n        if (n == 1)\n            return k % 2 == 0 ? nums[0] : -1;\n        // Take min(n, k - 1) elements and put the largest one back.\n        const int mx = *max_element(nums.begin(), nums.begin() + min(n, k - 1));\n        if (k >= n)\n            return mx;\n        return max(mx, nums[k]);\n    }\n};"
    }
  },
  "2203": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    long long minimumWeight(int n, vector<vector<int>>& edges, int src1,\n                            int src2, int dest) {\n        vector<vector<pair<int, int>>> graph(n);\n        vector<vector<pair<int, int>>> reversedGraph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            reversedGraph[v].emplace_back(u, w);\n        }\n\n        const vector<long> fromSrc1 = dijkstra(graph, src1);\n        const vector<long> fromSrc2 = dijkstra(graph, src2);\n        const vector<long> fromDest = dijkstra(reversedGraph, dest);\n        long ans = kMax;\n\n        for (int i = 0; i < n; ++i) {\n            if (fromSrc1[i] == kMax || fromSrc2[i] == kMax ||\n                fromDest[i] == kMax)\n                continue;\n            ans = min(ans, fromSrc1[i] + fromSrc2[i] + fromDest[i]);\n        }\n\n        return ans == kMax ? -1 : ans;\n    }\n\nprivate:\n    static constexpr long kMax = 10'000'000'000;\n\n    vector<long> dijkstra(const vector<vector<pair<int, int>>>& graph,\n                          int src) {\n        vector<long> dist(graph.size(), kMax);\n\n        dist[src] = 0;\n        using P = pair<long, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.emplace(dist[v], v);\n                }\n        }\n\n        return dist;\n    }\n};"
    }
  },
  "2204": {
    "solution": {
      "union-find": "class Solution {\npublic:\n    vector<int> distanceToCycle(int n, vector<vector<int>>& edges) {\n        unordered_set<int> adjList[n]; \n        \n        for (auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            adjList[u].insert(v);\n            adjList[v].insert(u);\n        }\n        \n        queue<int> q;  \n        for (int i = 0; i < n; ++i) {\n            if (adjList[i].size() == 1) {\n                q.push(i);\n            }\n        }\n\n        vector<int> parent(n, -1); \n        vector<int> nodeOrder;  \n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            nodeOrder.push_back(node);\n\n            for (int neighbor : adjList[node]) {\n                adjList[neighbor].erase(node);  \n                parent[node] = neighbor; \n                // If the neighbor becomes a leaf, add it to the queue\n                if (adjList[neighbor].size() == 1) {\n                    q.push(neighbor);\n                }\n            }\n            adjList[node].clear();  \n        }\n\n        vector<int> distanceToCycle(n, -1); \n        for (int i = nodeOrder.size() - 1; i >= 0; --i) {\n            int node = nodeOrder[i];\n            if (parent[node] != -1) {\n                distanceToCycle[node] = distanceToCycle[parent[node]] + 1;\n            }\n        }\n\n        return distanceToCycle;\n    }\n};\n"
    }
  },
  "2205": {
    "solution": {
      "database": ""
    }
  },
  "2206": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2207": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2208": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2209": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2210": {
    "solution": {
      "array": ""
    }
  },
  "2211": {
    "solution": {
      "stack": ""
    }
  },
  "2212": {
    "solution": {
      "backtracking": ""
    }
  },
  "2213": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2214": {
    "solution": {
      "greedy": ""
    }
  },
  "2215": {
    "solution": {
      "hash-table": ""
    }
  },
  "2216": {
    "solution": {
      "array": "class Solution {\npublic:\n    int minDeletion(vector<int>& nums) {\n        int ans = 0;\n\n        for (int i = 0; i + 1 < nums.size(); ++i)\n            // i - ans := the index after deletion\n            if (nums[i] == nums[i + 1] && (i - ans) % 2 == 0)\n                ++ans;\n\n        return ans + ((nums.size() - ans) & 1);\n    }\n};"
    }
  },
  "2217": {
    "solution": {
      "math": "class Solution {\n public:\n  vector<long long> kthPalindrome(vector<int>& queries, int intLength) {\n    const int start = pow(10, (intLength + 1) / 2 - 1);\n    const int end = pow(10, (intLength + 1) / 2);\n    const int mul = pow(10, intLength / 2);\n    vector<long long> ans;\n\n    for (const int query : queries)\n      if (start + query > end)\n        ans.push_back(-1);\n      else\n        ans.push_back(getKthPalindrome(query, start, mul, intLength));\n\n    return ans;\n  }\n\n private:\n  long getKthPalindrome(int query, int start, int mul, int intLength) {\n    const long prefix = start + query - 1;\n    return prefix * mul + reverse(intLength % 2 == 0 ? prefix : prefix / 10);\n  }\n\n  long reverse(int num) {\n    long res = 0;\n    while (num > 0) {\n      res = res * 10 + num % 10;\n      num /= 10;\n    }\n    return res;\n  }\n};\n"
    }
  },
  "2218": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2219": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2220": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    int minBitFlips(int start, int goal) {\n        return __builtin_popcount(start ^ goal);\n    }\n};"
    }
  },
  "2221": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2222": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2223": {
    "solution": {
      "suffix-array": "class Solution {\n    public long sumScores(String s) {\n      int n = s.length();\n        // https://cp-algorithms.com/string/z-function.html#implementation\n        int[] z = new int[n];\n        // [left, right] := the indices of the rightmost segment match\n        int left = 0;\n        int right = 0;\n\n        for (int i = 1; i < n; ++i) {\n            if (i < right)\n                z[i] = Math.min(right - i, z[i - left]);\n            while (i + z[i] < n && s.charAt(z[i]) == s.charAt(i + z[i]))\n                ++z[i];\n            if (i + z[i] > right) {\n                left = i;\n                right = i + z[i];\n            }\n        }\n\n        return Arrays.stream(z).asLongStream().sum() + n;\n    }\n}"
    }
  },
  "2224": {
    "solution": {
      "greedy": ""
    }
  },
  "2225": {
    "solution": {
      "counting": ""
    }
  },
  "2226": {
    "solution": {
      "array": ""
    }
  },
  "2227": {
    "solution": {
      "trie": ""
    }
  },
  "2228": {
    "solution": {
      "database": ""
    }
  },
  "2229": {
    "solution": {
      "sorting": ""
    }
  },
  "2230": {
    "solution": {
      "database": ""
    }
  },
  "2231": {
    "solution": {
      "heap-(priority-queue)": "class Solution {\n    public int largestInteger(int num) {\n        String s = String.valueOf(num);\n        int ans = 0;\n        // maxHeap[0] := the odd digits\n        // maxHeap[1] := the even digits\n        Queue<Integer>[] maxHeap = new Queue[2];\n\n        for (int i = 0; i < 2; ++i)\n            maxHeap[i] = new PriorityQueue<>(Comparator.reverseOrder());\n\n        for (char c : s.toCharArray()) {\n            int digit = c - '0';\n            maxHeap[digit & 1].offer(digit);\n        }\n\n        for (char c : s.toCharArray()) {\n            int i = c - '0' & 1;\n            ans = (ans * 10 + maxHeap[i].poll());\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2232": {
    "solution": {
      "enumeration": ""
    }
  },
  "2233": {
    "solution": {
      "heap-(priority-queue)": "class Solution {\n    public int maximumProduct(int[] nums, int k) {\n        int kMod = 1_000_000_007;\n        long ans = 1;\n        Queue<Integer> minHeap = new PriorityQueue<>();\n\n        for (int num : nums)\n            minHeap.offer(num);\n\n        for (int i = 0; i < k; ++i) {\n            int minNum = minHeap.poll();\n            minHeap.offer(minNum + 1);\n        }\n\n        while (!minHeap.isEmpty()) {\n            ans *= minHeap.poll();\n            ans %= kMod;\n        }\n\n        return (int) ans;\n    }\n}"
    }
  },
  "2234": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2235": {
    "solution": {
      "math": "class Solution {\npublic:\n    int sum(int num1, int num2) {\n        return num1 + num2;\n    }\n};\n"
    }
  },
  "2236": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    bool checkTree(TreeNode* root) {\n        if (!root || !root->left || !root->right) {\n            return false; // if any child is missing, return false\n        }\n        return root->val == root->left->val + root->right->val;\n    }\n};"
    }
  },
  "2237": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2238": {
    "solution": {
      "database": ""
    }
  },
  "2239": {
    "solution": {
      "array": ""
    }
  },
  "2240": {
    "solution": {
      "enumeration": ""
    }
  },
  "2241": {
    "solution": {
      "design": ""
    }
  },
  "2242": {
    "solution": {
      "enumeration": ""
    }
  },
  "2243": {
    "solution": {
      "string": ""
    }
  },
  "2244": {
    "solution": {
      "counting": ""
    }
  },
  "2245": {
    "solution": {
      "matrix": ""
    }
  },
  "2246": {
    "solution": {
      "topological-sort": ""
    }
  },
  "2247": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2248": {
    "solution": {
      "counting": "class Solution {\npublic:\n    vector<int> intersection(vector<vector<int>>& nums) {\n        unordered_map<int, int> freq;\n        int n = nums.size();\n\n        // Count the frequency of each element across all arrays\n        for (const auto& arr : nums) {\n            unordered_set<int>\n                seen; // To avoid counting duplicates within the same array\n            for (int num : arr) {\n                if (seen.find(num) == seen.end()) {\n                    freq[num]++;\n                    seen.insert(num);\n                }\n            }\n        }\n\n        // Collect the elements that appear in every array\n        vector<int> result;\n        for (const auto& [num, count] : freq) {\n            if (count == n) {\n                result.push_back(num);\n            }\n        }\n\n        // Sort the result\n        sort(result.begin(), result.end());\n\n        return result;\n    }\n};\n"
    }
  },
  "2249": {
    "solution": {
      "geometry": ""
    }
  },
  "2250": {
    "solution": {
      "sorting": ""
    }
  },
  "2251": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2252": {
    "solution": {
      "database": ""
    }
  },
  "2253": {
    "solution": {
      "database": ""
    }
  },
  "2254": {
    "solution": {
      "design": "class VideoSharingPlatform {\n public:\n  int upload(string video) {\n    int videoId = getVideoId();\n    videoIdToVideo[videoId] = video;\n    videoIdToViews[videoId] = 0;\n    videoIdToLikes[videoId] = 0;\n    videoIdToDislikes[videoId] = 0;\n    return videoId;\n  }\n\n  void remove(int videoId) {\n    if (videoIdToVideo.find(videoId) != videoIdToVideo.end()) {\n      usedIds.push(videoId);\n      videoIdToVideo.erase(videoId);\n      videoIdToViews.erase(videoId);\n      videoIdToLikes.erase(videoId);\n      videoIdToDislikes.erase(videoId);\n    }\n  }\n\n  string watch(int videoId, int startMinute, int endMinute) {\n    auto it = videoIdToVideo.find(videoId);\n    if (it == videoIdToVideo.end())\n      return \"-1\";\n\n    ++videoIdToViews[videoId];\n    string video = it->second;\n    int duration = min(endMinute, static_cast<int>(video.length()) - 1) - startMinute + 1;\n\n    if (duration <= 0 || startMinute >= video.length()) {\n      return \"\";\n    }\n\n    return video.substr(startMinute, duration);\n  }\n\n  void like(int videoId) {\n    if (videoIdToVideo.find(videoId) != videoIdToVideo.end()) {\n      ++videoIdToLikes[videoId];\n    }\n  }\n\n  void dislike(int videoId) {\n    if (videoIdToVideo.find(videoId) != videoIdToVideo.end()) {\n      ++videoIdToDislikes[videoId];\n    }\n  }\n\n  vector<int> getLikesAndDislikes(int videoId) {\n    if (videoIdToVideo.find(videoId) != videoIdToVideo.end()) {\n      return {videoIdToLikes[videoId], videoIdToDislikes[videoId]};\n    }\n    return {-1};\n  }\n\n  int getViews(int videoId) {\n    if (videoIdToVideo.find(videoId) != videoIdToVideo.end()) {\n      return videoIdToViews[videoId];\n    }\n    return -1;\n  }\n\n private:\n  int currVideoId = 0;\n  priority_queue<int, vector<int>, greater<>> usedIds;\n  unordered_map<int, string> videoIdToVideo;\n  unordered_map<int, int> videoIdToViews;\n  unordered_map<int, int> videoIdToLikes;\n  unordered_map<int, int> videoIdToDislikes;\n\n  int getVideoId() {\n    if (usedIds.empty()) {\n      return currVideoId++;\n    }\n    int minUsedId = usedIds.top();\n    usedIds.pop();\n    return minUsedId;\n  }\n};"
    }
  },
  "2255": {
    "solution": {
      "string": ""
    }
  },
  "2256": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int minimumAverageDifference(int[] nums) {\n        int n = nums.length;\n        long totalSum = 0;\n        \n        for (int num : nums) {\n            totalSum += num;\n        }\n        \n        long leftSum = 0;  // Sum of elements to the left of the current index\n        long minDiff = Long.MAX_VALUE;\n        int resultIndex = -1;\n\n        for (int i = 0; i < n; i++) {\n            // Update leftSum (sum of elements from 0 to i)\n            leftSum += nums[i];\n            \n            // Calculate rightSum (totalSum - leftSum)\n            long rightSum = totalSum - leftSum;\n            \n            // Calculate the average difference\n            long leftAvg = leftSum / (i + 1);\n            long rightAvg = (i == n - 1) ? 0 : rightSum / (n - i - 1);  // Avoid division by zero for the last element\n            \n            // Calculate the absolute difference in averages\n            long diff = Math.abs(leftAvg - rightAvg);\n            \n            // Update resultIndex if a new minimum difference is found\n            if (diff < minDiff) {\n                minDiff = diff;\n                resultIndex = i;\n            }\n        }\n        \n        return resultIndex;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        System.out.println(solution.minimumAverageDifference(new int[]{2, 4, 1, 3, 2})); // Output: 2\n        System.out.println(solution.minimumAverageDifference(new int[]{0, 0, 0, 0})); // Output: 0\n    }\n}\n"
    }
  },
  "2257": {
    "solution": {
      "matrix": ""
    }
  },
  "2258": {
    "solution": {
      "matrix": ""
    }
  },
  "2259": {
    "solution": {
      "enumeration": ""
    }
  },
  "2260": {
    "solution": {
      "sliding-window": "class Solution {\n  public int minimumCardPickup(int[] cards) {\n    int ans = Integer.MAX_VALUE;\n    Map<Integer, Integer> seen = new HashMap<>();\n\n    for (int i = 0; i < cards.length; ++i) {\n      if (seen.containsKey(cards[i]))\n        ans = Math.min(ans, i - seen.get(cards[i]) + 1);\n      seen.put(cards[i], i);\n    }\n\n    return ans == Integer.MAX_VALUE ? -1 : ans;\n  }\n}"
    }
  },
  "2261": {
    "solution": {
      "trie": "class Solution {\npublic:\n    int countDistinct(vector<int>& nums, int k, int p) {\n        struct TrieNode {\n            unordered_map<int, TrieNode*> children;\n        };\n\n        TrieNode* root = new TrieNode();\n        int distinctCount = 0;\n\n        for (int i = 0; i < nums.size(); ++i) {\n            TrieNode* node = root;\n            int divisibleCount = 0;\n\n            for (int j = i; j < nums.size(); ++j) {\n                if (nums[j] % p == 0)\n                    ++divisibleCount;\n\n                // Stop adding subarrays if divisible count exceeds k\n                if (divisibleCount > k)\n                    break;\n\n                // If the current number is not in the trie, add it\n                if (!node->children.count(nums[j])) {\n                    node->children[nums[j]] = new TrieNode();\n                    ++distinctCount; // Each new node represents a new subarray\n                }\n\n                node = node->children[nums[j]];\n            }\n        }\n\n        return distinctCount;\n    }\n};\n"
    }
  },
  "2262": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2263": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2264": {
    "solution": {
      "string": ""
    }
  },
  "2265": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int averageOfSubtree(TreeNode* root) {\n        int ans = 0;\n        dfs(root, ans);\n        return ans;\n    }\n\nprivate:\n    pair<int, int> dfs(TreeNode* root, int& ans) {\n        if (root == nullptr)\n            return {0, 0};\n        const auto [leftSum, leftCount] = dfs(root->left, ans);\n        const auto [rightSum, rightCount] = dfs(root->right, ans);\n        const int sum = root->val + leftSum + rightSum;\n        const int count = 1 + leftCount + rightCount;\n        if (sum / count == root->val)\n            ++ans;\n        return {sum, count};\n    }\n};"
    }
  },
  "2266": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2267": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    bool hasValidPath(vector<vector<char>>& grid) {\n        const int rows = grid.size();\n        const int cols = grid[0].size();\n        vector<vector<vector<int>>> memo(\n            rows, vector<vector<int>>(cols, vector<int>(rows + cols, -1)));\n        return isValidPath(grid, 0, 0, 0, memo);\n    }\n\nprivate:\n    bool isValidPath(const vector<vector<char>>& grid, int row, int col, int balance,\n                     vector<vector<vector<int>>>& memo) {\n        const int rows = grid.size();\n        const int cols = grid[0].size();\n\n        // If out of bounds, return false\n        if (row == rows || col == cols) \n            return false;\n\n        // Update balance based on the current cell\n        balance += (grid[row][col] == '(' ? 1 : -1);\n\n        // If balance goes negative, it's invalid\n        if (balance < 0)\n            return false;\n\n        // If we reach the bottom-right cell, check if balance is zero\n        if (row == rows - 1 && col == cols - 1)\n            return balance == 0;\n\n        // If the result for the current state is already computed, return it\n        if (memo[row][col][balance] != -1)\n            return memo[row][col][balance];\n\n        bool moveRight = isValidPath(grid, row, col + 1, balance, memo);\n        bool moveDown = isValidPath(grid, row + 1, col, balance, memo);\n\n        return memo[row][col][balance] = (moveRight || moveDown);\n    }\n};"
    }
  },
  "2268": {
    "solution": {
      "counting": ""
    }
  },
  "2269": {
    "solution": {
      "sliding-window": "class Solution {\n  public int divisorSubstrings(int num, int k) {\n  String s = String.valueOf(num);\n    int ans = 0;\n\n    for (int i = 0; i + k <= s.length(); ++i) {\n    int x = Integer.parseInt(s.substring(i, i + k));\n      if (x != 0 && num % x == 0)\n        ++ans;\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2270": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2271": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2272": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2273": {
    "solution": {
      "sorting": ""
    }
  },
  "2274": {
    "solution": {
      "sorting": ""
    }
  },
  "2275": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2276": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2277": {
    "solution": {
      "tree": ""
    }
  },
  "2278": {
    "solution": {
      "string": ""
    }
  },
  "2279": {
    "solution": {
      "greedy": ""
    }
  },
  "2280": {
    "solution": {
      "geometry": ""
    }
  },
  "2281": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2282": {
    "solution": {
      "matrix": ""
    }
  },
  "2283": {
    "solution": {
      "counting": ""
    }
  },
  "2284": {
    "solution": {
      "counting": ""
    }
  },
  "2285": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2286": {
    "solution": {
      "design": ""
    }
  },
  "2287": {
    "solution": {
      "counting": ""
    }
  },
  "2288": {
    "solution": {
      "string": ""
    }
  },
  "2289": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2290": {
    "solution": {
      "shortest-path": "class Solution {\n public:\n  int minimumObstacles(vector<vector<int>>& grid) {\n    const int m = grid.size();\n    const int n = grid[0].size();\n    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    using T = tuple<int, int, int>;  // (d, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<int>> dist(m, vector<int>(n, INT_MAX));\n\n    minHeap.emplace(grid[0][0], 0, 0);\n    dist[0][0] = grid[0][0];\n\n    while (!minHeap.empty()) {\n      const auto [d, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return d;\n      for (const auto& [dx, dy] : dirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        const int newDist = d + grid[i][j];\n        if (newDist < dist[x][y]) {\n          dist[x][y] = newDist;\n          minHeap.emplace(newDist, x, y);\n        }\n      }\n    }\n\n    return dist[m - 1][n - 1];\n  }\n};"
    }
  },
  "2291": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2292": {
    "solution": {
      "database": ""
    }
  },
  "2293": {
    "solution": {
      "array": ""
    }
  },
  "2294": {
    "solution": {
      "greedy": ""
    }
  },
  "2295": {
    "solution": {
      "hash-table": ""
    }
  },
  "2296": {
    "solution": {
      "doubly-linked-list": "class TextEditor {\n    private class Node {\n        char c;\n        Node prev, next;\n\n        Node(char c) {\n            this.c = c;\n        }\n    }\n\n    private Node head, tail, cursor;\n\n    public TextEditor() {\n        head = new Node('0');\n        tail = new Node('0');\n        head.next = tail;\n        tail.prev = head;\n        cursor = tail;\n    }\n\n    public void addText(String text) {\n        for (char c : text.toCharArray()) {\n            Node newNode = new Node(c);\n            Node prev = cursor.prev;\n            prev.next = newNode;\n            newNode.prev = prev;\n            newNode.next = cursor;\n            cursor.prev = newNode;\n        }\n    }\n\n    public int deleteText(int k) {\n        int deleted = 0;\n        while (k > 0 && cursor.prev != head) {\n            Node prev = cursor.prev;\n            prev.prev.next = cursor;\n            cursor.prev = prev.prev;\n            k--;\n            deleted++;\n        }\n        return deleted;\n    }\n\n    public String cursorLeft(int k) {\n        while (k > 0 && cursor.prev != head) {\n            cursor = cursor.prev;\n            k--;\n        }\n        return getText();\n    }\n\n    public String cursorRight(int k) {\n        while (k > 0 && cursor != tail) {\n            cursor = cursor.next;\n            k--;\n        }\n        return getText();\n    }\n\n    private String getText() {\n        StringBuilder sb = new StringBuilder();\n        Node temp = cursor.prev;\n        for (int i = 0; i < 10 && temp != head; i++) {\n            sb.append(temp.c);\n            temp = temp.prev;\n        }\n        return sb.reverse().toString();\n    }\n}\n"
    }
  },
  "2297": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    long long minCost(vector<int>& nums, vector<int>& costs) {\n        int n = nums.size();\n        vector<int> graph[n]; \n        stack<int> stack;     \n\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.empty() && nums[stack.top()] < nums[i]) {\n                stack.pop();\n            }\n            if (!stack.empty()) {\n                graph[i].push_back(stack.top());\n            }\n            stack.push(i);\n        }\n\n        stack = stack<int>();\n        for (int i = n - 1; i >= 0; --i) {\n            while (!stack.empty() && nums[stack.top()] >= nums[i]) {\n                stack.pop();\n            }\n            if (!stack.empty()) {\n                graph[i].push_back(stack.top());\n            }\n            stack.push(i);\n        }\n\n        vector<long long> dp(n, 1e18);\n        dp[0] = 0; // Starting point\n\n        for (int i = 0; i < n; ++i) {\n            for (int neighbor : graph[i]) {\n                dp[neighbor] = min(dp[neighbor], dp[i] + costs[neighbor]);\n            }\n        }\n\n        return dp[n - 1];\n    }\n};"
    }
  },
  "2298": {
    "solution": {
      "database": ""
    }
  },
  "2299": {
    "solution": {
      "string": ""
    }
  },
  "2300": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2301": {
    "solution": {
      "string-matching": ""
    }
  },
  "2302": {
    "solution": {
      "sliding-window": "class Solution {\n    public long countSubarrays(int[] nums, long k) {\n        long ans = 0;\n        long sum = 0;\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            sum += nums[right];\n            while (sum * (right - left + 1) >= k)\n                sum -= nums[left++];\n            ans += right - left + 1;\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2303": {
    "solution": {
      "array": ""
    }
  },
  "2304": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    int minPathCost(vector<vector<int>>& grid, vector<vector<int>>& moveCost) {\n        int rows = grid.size();\n        int cols = grid[0].size();\n\n        vector<vector<int>> dp(rows, vector<int>(cols, INT_MAX));\n\n        for (int col = 0; col < cols; ++col) {\n            dp[0][col] = grid[0][col];\n        }\n\n        for (int row = 1; row < rows; ++row) {\n            for (int col = 0; col < cols; ++col) {\n                for (int prevCol = 0; prevCol < cols; ++prevCol) {\n                    int transitionCost = moveCost[grid[row - 1][prevCol]][col];\n                    dp[row][col] = min(dp[row][col], dp[row - 1][prevCol] + transitionCost + grid[row][col]);\n                }\n            }\n        }\n\n        int minCost = INT_MAX;\n        for (int col = 0; col < cols; ++col) {\n            minCost = min(minCost, dp[rows - 1][col]);\n        }\n\n        return minCost;\n    }\n};"
    }
  },
  "2305": {
    "solution": {
      "backtracking": "class Solution {\npublic:\n    int distributeCookies(vector<int>& cookies, int k) {\n        int n = cookies.size();\n        vector<int> childCookies(k, 0); \n        int result = INT_MAX; \n        \n        function<void(int)> dfs = [&](int index) {\n            if (index == n) {\n                int maxCookies = *max_element(childCookies.begin(), childCookies.end());\n                result = min(result, maxCookies);\n                return;\n            }\n\n            for (int i = 0; i < k; i++) {\n                if (i > 0 && childCookies[i] == childCookies[i-1]) continue;\n\n                childCookies[i] += cookies[index];\n                dfs(index + 1);\n                childCookies[i] -= cookies[index];\n            }\n        };\n        \n        sort(cookies.rbegin(), cookies.rend());        \n        dfs(0);\n        \n        return result;\n    }\n};\n"
    }
  },
  "2306": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2307": {
    "solution": {
      "union-find": ""
    }
  },
  "2308": {
    "solution": {
      "database": ""
    }
  },
  "2309": {
    "solution": {
      "enumeration": ""
    }
  },
  "2310": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2311": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2312": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2313": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2314": {
    "solution": {
      "database": ""
    }
  },
  "2315": {
    "solution": {
      "string": ""
    }
  },
  "2316": {
    "solution": {
      "union-find": ""
    }
  },
  "2317": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2318": {
    "solution": {
      "memoization": "class Solution {\npublic:\n    int distinctSequences(int n) {\n        vector<vector<vector<int>>> mem(n + 1,\n                                        vector<vector<int>>(7, vector<int>(7)));\n        return distinctSequences(n, 0, 0, mem);\n    }\n\nprivate:\n    static constexpr int kMod = 1'000'000'007;\n\n    // Returns the number of distinct sequences for n dices with `prev` and\n    // `prevPrev`.\n    int distinctSequences(int n, int prev, int prevPrev,\n                          vector<vector<vector<int>>>& mem) {\n        if (n == 0)\n            return 1;\n        if (mem[n][prev][prevPrev] > 0)\n            return mem[n][prev][prevPrev];\n\n        for (int dice = 1; dice <= 6; ++dice)\n            if (dice != prev && dice != prevPrev &&\n                (prev == 0 || gcd(dice, prev) == 1)) {\n                mem[n][prev][prevPrev] +=\n                    distinctSequences(n - 1, dice, prev, mem);\n                mem[n][prev][prevPrev] %= kMod;\n            }\n\n        return mem[n][prev][prevPrev];\n    }\n};"
    }
  },
  "2319": {
    "solution": {
      "matrix": ""
    }
  },
  "2320": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2321": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2322": {
    "solution": {
      "tree": ""
    }
  },
  "2323": {
    "solution": {
      "greedy": ""
    }
  },
  "2324": {
    "solution": {
      "database": ""
    }
  },
  "2325": {
    "solution": {
      "hash-table": ""
    }
  },
  "2326": {
    "solution": {
      "matrix": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\npublic class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n\n    public int[][] spiralMatrix(int m, int n, ListNode head) {\n        int[][] result = new int[m][n];\n        \n        for (int i = 0; i < m; i++) {\n            for (int j = 0; j < n; j++) {\n                result[i][j] = -1;\n            }\n        }\n        \n        int r = 0, c = 0, dirIndex = 0;\n        \n        ListNode current = head;\n        while (current != null) {\n            result[r][c] = current.val;\n            current = current.next;\n            \n            int newR = r + DIRECTIONS[dirIndex][0];\n            int newC = c + DIRECTIONS[dirIndex][1];\n            \n            if (newR < 0 || newR >= m || newC < 0 || newC >= n || result[newR][newC] != -1) {\n                dirIndex = (dirIndex + 1) % 4;\n                newR = r + DIRECTIONS[dirIndex][0];\n                newC = c + DIRECTIONS[dirIndex][1];\n            }\n            \n            r = newR;\n            c = newC;\n        }\n        \n        return result;\n    }\n\n    public static void main(String[] args) {\n        ListNode head = new ListNode(3);\n        head.next = new ListNode(0);\n        head.next.next = new ListNode(2);\n        head.next.next.next = new ListNode(6);\n        head.next.next.next.next = new ListNode(8);\n        head.next.next.next.next.next = new ListNode(1);\n        head.next.next.next.next.next.next = new ListNode(7);\n        head.next.next.next.next.next.next.next = new ListNode(9);\n        head.next.next.next.next.next.next.next.next = new ListNode(4);\n        head.next.next.next.next.next.next.next.next.next = new ListNode(2);\n        head.next.next.next.next.next.next.next.next.next.next = new ListNode(5);\n        Solution spiralMatrix = new Solution();\n        int[][] result = spiralMatrix.spiralMatrix(3, 5, head);\n        for (int[] row : result) {\n            for (int val : row) {\n                System.out.print(val + \" \");\n            }\n            System.out.println();\n        }\n    }\n}"
    }
  },
  "2327": {
    "solution": {
      "queue": ""
    }
  },
  "2328": {
    "solution": {
      "matrix": ""
    }
  },
  "2329": {
    "solution": {
      "database": ""
    }
  },
  "2330": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2331": {
    "solution": {
      "tree": ""
    }
  },
  "2332": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2333": {
    "solution": {
      "heap-(priority-queue)": "class Solution {\n    public long minSumSquareDiff(int[] nums1, int[] nums2, int k1, int k2) {\n        int[] diff = getDiff(nums1, nums2);\n        int k = k1 + k2;\n        if (Arrays.stream(diff).asLongStream().sum() <= k)\n            return 0;\n\n        Map<Integer, Integer> count = new HashMap<>();\n        // (num, freq)\n        Queue<Pair<Integer, Integer>> maxHeap = new PriorityQueue<>((a, b) -> b.getKey() - a.getKey());\n\n        for (int d : diff)\n            if (d != 0)\n                count.merge(d, 1, Integer::sum);\n\n        for (Map.Entry<Integer, Integer> entry : count.entrySet())\n            maxHeap.offer(new Pair<>(entry.getKey(), entry.getValue()));\n\n        while (k > 0) {\n            Pair<Integer, Integer> pair = maxHeap.poll();\n            int maxNum = pair.getKey();\n            int maxNumFreq = pair.getValue();\n            // Buck decrease in this turn\n            int numDecreased = Math.min(k, maxNumFreq);\n            k -= numDecreased;\n            if (maxNumFreq > numDecreased)\n                maxHeap.offer(new Pair<>(maxNum, maxNumFreq - numDecreased));\n            if (!maxHeap.isEmpty() && maxHeap.peek().getKey() + 1 == maxNum) {\n                Pair<Integer, Integer> secondNode = maxHeap.poll();\n                int secondMaxNum = secondNode.getKey();\n                int secondMaxNumFreq = secondNode.getValue();\n                maxHeap.offer(new Pair<>(secondMaxNum, secondMaxNumFreq + numDecreased));\n            } else if (maxNum > 1) {\n                maxHeap.offer(new Pair<>(maxNum - 1, numDecreased));\n            }\n        }\n\n        long ans = 0;\n        while (!maxHeap.isEmpty()) {\n            Pair<Integer, Integer> pair = maxHeap.poll();\n            int num = pair.getKey();\n            int freq = pair.getValue();\n            ans += (long) num * num * freq;\n        }\n\n        return ans;\n    }\n\n    private int[] getDiff(int[] nums1, int[] nums2) {\n        int[] diff = new int[nums1.length];\n        for (int i = 0; i < nums1.length; ++i)\n            diff[i] = Math.abs(nums1[i] - nums2[i]);\n        return diff;\n    }\n}"
    }
  },
  "2334": {
    "solution": {
      "union-find": ""
    }
  },
  "2335": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2336": {
    "solution": {
      "design": "#include <set>\nusing namespace std;\n\nclass SmallestInfiniteSet {\nprivate:\n    set<int> infiniteSet;  // Maintains the additional numbers\n    int current;           // Tracks the current smallest number in the sequence\n\npublic:\n    SmallestInfiniteSet() : current(1) {}\n\n    int popSmallest() {\n        if (!infiniteSet.empty()) {\n            int smallest = *infiniteSet.begin();\n            infiniteSet.erase(infiniteSet.begin());\n            return smallest;\n        }\n        return current++;  // Return the current smallest number and increment it\n    }\n\n    void addBack(int num) {\n        if (num < current && infiniteSet.find(num) == infiniteSet.end()) {\n            infiniteSet.insert(num);\n        }\n    }\n};\n\n/**\n * Your SmallestInfiniteSet object will be instantiated and called as such:\n * SmallestInfiniteSet* obj = new SmallestInfiniteSet();\n * int param_1 = obj->popSmallest();\n * obj->addBack(num);\n */"
    }
  },
  "2337": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2338": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2339": {
    "solution": {
      "database": ""
    }
  },
  "2340": {
    "solution": {
      "greedy": ""
    }
  },
  "2341": {
    "solution": {
      "counting": ""
    }
  },
  "2342": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2343": {
    "solution": {
      "radix-sort": "import java.math.BigInteger;\nimport java.util.*;\n\nclass Solution {\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n        int[] ans = new int[queries.length];\n        for (int i = 0; i < queries.length; i++) {\n            ans[i] = getKSmallestIndex(nums, queries[i][0], queries[i][1]);\n        }\n        return ans;\n    }\n\n    private int getKSmallestIndex(String[] nums, int k, int trim) {\n        int startIndex = nums[0].length() - trim;\n        List<Pair<String, Integer>> trimmed = new ArrayList<>();  \n\n        for (int i = 0; i < nums.length; ++i) {\n            String numStr = nums[i].substring(startIndex);\n            trimmed.add(new Pair<>(numStr, i));\n        }\n\n        int n = trimmed.size();\n        String[] numArray = new String[n];\n        int[] indexArray = new int[n];\n\n        for (int i = 0; i < n; i++) {\n            numArray[i] = trimmed.get(i).getKey();\n            indexArray[i] = trimmed.get(i).getValue();\n        }\n\n        radixSort(numArray, indexArray);\n\n        return indexArray[k - 1];\n    }\n\n    public static void radixSort(String[] arr, int[] indexArr) {\n        int maxLen = Arrays.stream(arr).mapToInt(String::length).max().orElse(0);\n        for (int exp = maxLen - 1; exp >= 0; exp--) {\n            countingSort(arr, indexArr, exp);\n        }\n    }\n\n    private static void countingSort(String[] arr, int[] indexArr, int exp) {\n        int n = arr.length;\n        String[] output = new String[n];\n        int[] outputIndex = new int[n];\n        int[] count = new int[256];  // ASCII characters count\n\n        for (int i = 0; i < n; i++) {\n            char index = exp < arr[i].length() ? arr[i].charAt(exp) : 0;\n            count[index]++;\n        }\n\n        for (int i = 1; i < 256; i++) {\n            count[i] += count[i - 1];\n        }\n\n        for (int i = n - 1; i >= 0; i--) {\n            char index = exp < arr[i].length() ? arr[i].charAt(exp) : 0;\n            output[count[index] - 1] = arr[i];\n            outputIndex[count[index] - 1] = indexArr[i];\n            count[index]--;\n        }\n\n        System.arraycopy(output, 0, arr, 0, n);\n        System.arraycopy(outputIndex, 0, indexArr, 0, n);\n    }\n\n    static class Pair<K, V> {\n        private final K key;\n        private final V value;\n\n        public Pair(K key, V value) {\n            this.key = key;\n            this.value = value;\n        }\n\n        public K getKey() {\n            return key;\n        }\n\n        public V getValue() {\n            return value;\n        }\n    }\n\n}\n",
      "quickselect": "import java.util.*;\n\npublic class Solution {\n\n    class Pair implements Comparable<Pair> {\n        String trimmedNumber;\n        int originalIndex;\n\n        public Pair(String trimmedNumber, int originalIndex) {\n            this.trimmedNumber = trimmedNumber;\n            this.originalIndex = originalIndex;\n        }\n\n        @Override\n        public int compareTo(Pair other) {\n            if (this.trimmedNumber.equals(other.trimmedNumber)) {\n                return Integer.compare(this.originalIndex, other.originalIndex);\n            }\n            return this.trimmedNumber.compareTo(other.trimmedNumber);\n        }\n    }\n\n    public int[] smallestTrimmedNumbers(String[] nums, int[][] queries) {\n        int[] result = new int[queries.length];\n        int resultIndex = 0;\n        Map<Integer, String[]> trimmedMap = new HashMap<>();\n\n        for (int[] query : queries) {\n            int trimLength = query[1];\n            \n            if (!trimmedMap.containsKey(trimLength)) {\n                trimmedMap.put(trimLength, trimStrings(nums, trimLength));\n            }\n            String[] trimmedArray = trimmedMap.get(trimLength);\n            \n            Pair[] pairs = new Pair[trimmedArray.length];\n            for (int i = 0; i < trimmedArray.length; i++) {\n                pairs[i] = new Pair(trimmedArray[i], i);\n            }\n            \n            Pair kthSmallest = findKthSmallest(pairs, query[0]);\n            result[resultIndex++] = kthSmallest.originalIndex;\n        }\n\n        return result;\n    }\n\n    private String[] trimStrings(String[] nums, int trimLength) {\n        int fullLength = nums[0].length();\n        if (trimLength == fullLength) {\n            return nums; // No trimming needed\n        }\n\n        String[] trimmed = new String[nums.length];\n        for (int i = 0; i < nums.length; i++) {\n            trimmed[i] = nums[i].substring(fullLength - trimLength);\n        }\n        return trimmed;\n    }\n\n    private Pair findKthSmallest(Pair[] pairs, int k) {\n        k--; // Convert k to zero-based index\n        int left = 0;\n        int right = pairs.length - 1;\n\n        while (left <= right) {\n            int pivotIndex = partition(pairs, left, right);\n            if (pivotIndex == k) {\n                return pairs[k];\n            } else if (pivotIndex < k) {\n                left = pivotIndex + 1;\n            } else {\n                right = pivotIndex - 1;\n            }\n        }\n\n        return pairs[k];\n    }\n\n    private int partition(Pair[] pairs, int left, int right) {\n        // Select middle element as pivot\n        int mid = left + (right - left) / 2;\n        Pair pivot = pairs[mid];\n        \n        swap(pairs, mid, right);\n\n        int i = left;\n        for (int j = left; j < right; j++) {\n            if (pairs[j].compareTo(pivot) <= 0) {\n                swap(pairs, i, j);\n                i++;\n            }\n        }\n        \n        swap(pairs, i, right);\n        return i;\n    }\n\n    private void swap(Pair[] pairs, int i, int j) {\n        Pair temp = pairs[i];\n        pairs[i] = pairs[j];\n        pairs[j] = temp;\n    }\n}\n"
    }
  },
  "2344": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2345": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2346": {
    "solution": {
      "database": ""
    }
  },
  "2347": {
    "solution": {
      "counting": ""
    }
  },
  "2348": {
    "solution": {
      "math": ""
    }
  },
  "2349": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2350": {
    "solution": {
      "greedy": ""
    }
  },
  "2351": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    char repeatedCharacter(string s) {\n        vector<bool> seen(26, false);\n        for (char c : s) {\n            if (seen[c - 'a']) \n                return c;\n            seen[c - 'a'] = true;\n        }\n        return '\\0'; // Should not reach here as per problem constraints\n    }\n};"
    }
  },
  "2352": {
    "solution": {
      "matrix": "class Solution {\n    private static final int[][] DIRECTIONS = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    private int n;\n\n    public int equalPairs(int[][] grid) {\n        n = grid.length;\n        int count = 0;\n\n        for (int row = 0; row < n; row++) {\n            for (int col = 0; col < n; col++) {\n                if (checkEquality(grid, row, col)) {\n                    count++;\n                }\n            }\n        }\n\n        return count;\n    }\n\n    private boolean checkEquality(int[][] grid, int row, int col) {\n        for (int i = 0; i < n; i++) {\n            if (grid[row][i] != grid[i][col]) {\n                return false; \n            }\n        }\n        return true;\n    }\n}\n"
    }
  },
  "2353": {
    "solution": {
      "design": "#include <unordered_map>\n#include <map>\n#include <set>\n#include <vector>\n#include <string>\nusing namespace std;\n\nclass FoodRatings {\nprivate:\n    unordered_map<string, int> foodRatings;             // Maps food to its rating\n    unordered_map<string, string> foodCuisines;        // Maps food to its cuisine\n    unordered_map<string, set<pair<int, string>>> cuisineRatings; // Maps cuisine to a set of {rating, food}\n\npublic:\n    FoodRatings(vector<string>& foods, vector<string>& cuisines, vector<int>& ratings) {\n        for (size_t i = 0; i < foods.size(); ++i) {\n            string food = foods[i];\n            string cuisine = cuisines[i];\n            int rating = ratings[i];\n\n            foodRatings[food] = rating;\n            foodCuisines[food] = cuisine;\n            cuisineRatings[cuisine].emplace(-rating, food); // Store negative rating for max-heap behavior\n        }\n    }\n\n    void changeRating(string food, int newRating) {\n        string cuisine = foodCuisines[food];\n        int oldRating = foodRatings[food];\n\n        // Remove the old rating entry\n        cuisineRatings[cuisine].erase({-oldRating, food});\n\n        // Update the rating and add the new entry\n        foodRatings[food] = newRating;\n        cuisineRatings[cuisine].emplace(-newRating, food);\n    }\n\n    string highestRated(string cuisine) {\n        // Retrieve the food with the highest rating (lowest negative value)\n        return cuisineRatings[cuisine].begin()->second;\n    }\n};\n\n/**\n * Your FoodRatings object will be instantiated and called as such:\n * FoodRatings* obj = new FoodRatings(foods, cuisines, ratings);\n * obj->changeRating(food, newRating);\n * string param_2 = obj->highestRated(cuisine);\n */"
    }
  },
  "2354": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2355": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2356": {
    "solution": {
      "database": ""
    }
  },
  "2357": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2358": {
    "solution": {
      "greedy": ""
    }
  },
  "2359": {
    "solution": {
      "graph": "#include <vector>\n#include <queue>\n#include <climits>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> bfs(int start, const vector<int>& edges, int n) {\n        vector<int> distance(n, INT_MAX);  \n        queue<int> q;\n        distance[start] = 0;  \n        q.push(start);\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            int next = edges[node];  \n            if (next != -1 && distance[next] == INT_MAX) { \n                distance[next] = distance[node] + 1;\n                q.push(next);\n            }\n        }\n\n        return distance;\n    }\n\n    int closestMeetingNode(vector<int>& edges, int node1, int node2) {\n        int n = edges.size();\n        \n        vector<int> dist1 = bfs(node1, edges, n);\n        vector<int> dist2 = bfs(node2, edges, n);\n\n        int minDist = INT_MAX;  \n        int resultNode = -1;\n\n        for (int i = 0; i < n; ++i) {\n            int dist = max(dist1[i], dist2[i]);\n\n            if (dist < minDist) {\n                minDist = dist;\n                resultNode = i;\n            }\n            else if (dist == minDist && i < resultNode) {\n                resultNode = i;\n            }\n        }\n\n        return resultNode;\n    }\n};\n"
    }
  },
  "2360": {
    "solution": {
      "topological-sort": "#include <bits/stdc++.h>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestCycle(vector<int>& edges) {\n        int n = edges.size();\n        vector<int> inDegree(n, 0);\n\n        for (int i = 0; i < n; i++) {\n            if (edges[i] != -1) {\n                inDegree[edges[i]]++;\n            }\n        }\n\n        queue<int> q;\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] == 0) {\n                q.push(i);\n            }\n        }\n\n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n\n            int neighbor = edges[node];\n            if (neighbor != -1) {\n                inDegree[neighbor]--;\n                if (inDegree[neighbor] == 0) {\n                    q.push(neighbor);\n                }\n            }\n        }\n\n        int longestCycle = -1;\n        vector<bool> visited(n, false);\n\n        for (int i = 0; i < n; i++) {\n            if (inDegree[i] > 0 && !visited[i]) {\n                int current = i, length = 0;\n                while (!visited[current]) {\n                    visited[current] = true;\n                    current = edges[current];\n                    length++;\n                }\n                longestCycle = max(longestCycle, length);\n            }\n        }\n\n        return longestCycle;\n    }\n};\n"
    }
  },
  "2361": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2362": {
    "solution": {
      "database": ""
    }
  },
  "2363": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2364": {
    "solution": {
      "hash-table": ""
    }
  },
  "2365": {
    "solution": {
      "hash-table": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nclass Solution {\npublic:\n    long long taskSchedulerII(vector<int>& tasks, int space) {\n        unordered_map<int, long long> lastExecution;\n        long long time = 0;\n        \n        for (int task : tasks) {\n            if (lastExecution.find(task) != lastExecution.end()) {\n                time = max(time, lastExecution[task] + space + 1);\n            }\n            lastExecution[task] = time;\n            time++;\n        }\n        \n        return time;\n    }\n};"
    }
  },
  "2366": {
    "solution": {
      "greedy": ""
    }
  },
  "2367": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2368": {
    "solution": {
      "union-find": ""
    }
  },
  "2369": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2370": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2371": {
    "solution": {
      "matrix": "class Solution {\n    public int[][] minScore(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        List<int[]> nums = new ArrayList<>();\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                nums.add(new int[] {grid[i][j], i, j});\n            }\n        }\n        Collections.sort(nums, (a, b) -> a[0] - b[0]);\n        int[] rowMax = new int[m];\n        int[] colMax = new int[n];\n        int[][] ans = new int[m][n];\n        for (int[] num : nums) {\n            int i = num[1], j = num[2];\n            ans[i][j] = Math.max(rowMax[i], colMax[j]) + 1;\n            rowMax[i] = ans[i][j];\n            colMax[j] = ans[i][j];\n        }\n        return ans;\n    }\n}"
    }
  },
  "2372": {
    "solution": {
      "database": ""
    }
  },
  "2373": {
    "solution": {
      "matrix": ""
    }
  },
  "2374": {
    "solution": {
      "graph": ""
    }
  },
  "2375": {
    "solution": {
      "stack": ""
    }
  },
  "2376": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2377": {
    "solution": {
      "database": ""
    }
  },
  "2378": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2379": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minimumRecolors(String blocks, int k) {\n        int countB = 0;\n        int maxCountB = 0;\n\n        for (int i = 0; i < blocks.length(); ++i) {\n            if (blocks.charAt(i) == 'B')\n                ++countB;\n            if (i >= k && blocks.charAt(i - k) == 'B')\n                --countB;\n            maxCountB = Math.max(maxCountB, countB);\n        }\n\n        return k - maxCountB;\n    }\n}"
    }
  },
  "2380": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2381": {
    "solution": {
      "string": "class Solution {\npublic:\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\n        int currShift = 0;\n        vector<int> timeline(s.length() + 1);\n\n        for (const vector<int>& shift : shifts) {\n            const int start = shift[0];\n            const int end = shift[1];\n            const int direction = shift[2];\n            const int diff = direction ? 1 : -1;\n            timeline[start] += diff;\n            timeline[end + 1] -= diff;\n        }\n\n        for (int i = 0; i < s.length(); ++i) {\n            currShift = (currShift + timeline[i]) % 26;\n            const int num = (s[i] - 'a' + currShift + 26) % 26;\n            s[i] = 'a' + num;\n        }\n\n        return s;\n    }\n};"
    }
  },
  "2382": {
    "solution": {
      "union-find": ""
    }
  },
  "2383": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\n        int totalEnergyRequired = 0, totalExperienceRequired = 0;\n        int n = energy.size();\n        \n        // Traverse through each battle\n        for (int i = 0; i < n; ++i) {\n            // If initial energy is less than the energy required for battle, train\n            if (initialEnergy <= energy[i]) {\n                totalEnergyRequired += energy[i] - initialEnergy + 1; // Train to surpass energy[i]\n                initialEnergy = energy[i] + 1;\n            }\n            initialEnergy -= energy[i]; // After the battle, energy decreases\n            \n            // If initial experience is less than the experience required for battle, train\n            if (initialExperience <= experience[i]) {\n                totalExperienceRequired += experience[i] - initialExperience + 1; // Train to surpass experience[i]\n                initialExperience = experience[i] + 1;\n            }\n            initialExperience += experience[i]; // After the battle, experience increases\n        }\n        \n        // Total hours of training are the sum of training required for energy and experience\n        return totalEnergyRequired + totalExperienceRequired;\n    }\n};"
    }
  },
  "2384": {
    "solution": {
      "counting": ""
    }
  },
  "2385": {
    "solution": {
      "tree": ""
    }
  },
  "2386": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2387": {
    "solution": {
      "matrix": ""
    }
  },
  "2388": {
    "solution": {
      "database": ""
    }
  },
  "2389": {
    "solution": {
      "prefix-sum": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    vector<int> answerQueries(vector<int>& nums, vector<int>& queries) {\n        sort(nums.begin(), nums.end());\n\n        vector<int> prefixSum(nums.size());\n        prefixSum[0] = nums[0];\n        for (int i = 1; i < nums.size(); ++i) {\n            prefixSum[i] = prefixSum[i - 1] + nums[i];\n        }\n\n        vector<int> result;\n        for (int query : queries) {\n            int idx = upper_bound(prefixSum.begin(), prefixSum.end(), query) - prefixSum.begin();\n            result.push_back(idx); \n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "2390": {
    "solution": {
      "stack": "import java.util.*;\n\nclass Solution {\n    public String removeStars(String s) {\n        Deque<Integer> stack = new ArrayDeque<>();\n        \n        for (int i = 0; i < s.length(); i++) {\n            char ch = s.charAt(i);\n            if (ch == '*') {\n                if (!stack.isEmpty()) {\n                    stack.pop(); \n                }\n            } else {\n                stack.push(i); \n            }\n        }\n        \n        StringBuilder result = new StringBuilder();\n        while (!stack.isEmpty()) {\n            result.append(s.charAt(stack.pop()));\n        }\n        \n        return result.reverse().toString();\n    }\n}\n"
    }
  },
  "2391": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2392": {
    "solution": {
      "matrix": ""
    }
  },
  "2393": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    long long countSubarrays(vector<int>& nums) {\n        long long ans = 0;\n        int i = 0, n = nums.size();\n        while (i < n) {\n            int j = i + 1;\n            while (j < n && nums[j] > nums[j - 1]) {\n                ++j;\n            }\n            int count = j - i;\n            ans += 1ll * (1 + count) * count / 2;\n            i = j;\n        }\n        return ans;\n    }\n};"
    }
  },
  "2394": {
    "solution": {
      "database": ""
    }
  },
  "2395": {
    "solution": {
      "hash-table": ""
    }
  },
  "2396": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2397": {
    "solution": {
      "matrix": ""
    }
  },
  "2398": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximumRobots(int[] times, int[] costs, long budget) {\n        long sum = 0;\n        int i = 0, n = times.length;\n        Deque<Integer> deque = new LinkedList<Integer>();\n        for (int j = 0; j < n; ++j) {\n            sum += costs[j];\n            while (!deque.isEmpty() && times[deque.peekLast()] <= times[j])\n                deque.pollLast();\n            deque.addLast(j);\n            if (times[deque.getFirst()] + (j - i + 1) * sum > budget) {\n                if (deque.getFirst() == i)\n                    deque.pollFirst();\n                sum -= costs[i++];\n            }\n        }\n        return n - i;\n    }\n}\n"
    }
  },
  "2399": {
    "solution": {
      "hash-table": ""
    }
  },
  "2400": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2401": {
    "solution": {
      "sliding-window": "class Solution {\n  public int longestNiceSubarray(int[] nums) {\n    int ans = 0;\n    int used = 0;\n\n    for (int left = 0, right = 0; right < nums.length; ++right) {\n      while ((used & nums[right]) > 0)\n        used ^= nums[left++];\n      used |= nums[right];\n      ans = Math.max(ans, right - left + 1);\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2402": {
    "solution": {
      "heap-(priority-queue)": "#include <vector>\n#include <queue>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mostBooked(int n, vector<vector<int>>& meetings) {\n        // Sort meetings by start time\n        sort(meetings.begin(), meetings.end());\n\n        // Priority queue for free rooms (min-heap of room indices)\n        priority_queue<int, vector<int>, greater<int>> freeRooms;\n        for (int i = 0; i < n; ++i) freeRooms.push(i);\n\n        // Priority queue for occupied rooms (min-heap of {endTime, roomIndex})\n        priority_queue<pair<long long, int>, vector<pair<long long, int>>, greater<>> occupiedRooms;\n\n        // Array to track usage count for each room\n        vector<int> roomUsage(n, 0);\n\n        // Process each meeting\n        for (const auto& meeting : meetings) {\n            long long start = meeting[0];\n            long long end = meeting[1];\n\n            // Free up rooms that have completed their meetings\n            while (!occupiedRooms.empty() && occupiedRooms.top().first <= start) {\n                freeRooms.push(occupiedRooms.top().second);\n                occupiedRooms.pop();\n            }\n\n            // Assign a room for the current meeting\n            if (!freeRooms.empty()) {\n                // Take the smallest available room\n                int room = freeRooms.top();\n                freeRooms.pop();\n                occupiedRooms.push({end, room});\n                roomUsage[room]++;\n            } else {\n                // Wait for the earliest room to be free\n                auto earliest = occupiedRooms.top();\n                occupiedRooms.pop();\n                long long newEndTime = earliest.first + (end - start);\n                occupiedRooms.push({newEndTime, earliest.second});\n                roomUsage[earliest.second]++;\n            }\n        }\n\n        // Find the room with the highest usage\n        int maxBookedRoom = 0;\n        for (int i = 1; i < n; ++i) {\n            if (roomUsage[i] > roomUsage[maxBookedRoom]) {\n                maxBookedRoom = i;\n            }\n        }\n\n        return maxBookedRoom;\n    }\n};\n"
    }
  },
  "2403": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2404": {
    "solution": {
      "hash-table": "#include <iostream>\n#include <vector>\n#include <unordered_map>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int mostFrequentEven(vector<int>& nums) {\n        unordered_map<int, int> freqMap;\n        int result = -1;\n        int maxFreq = 0;\n\n        for (int num : nums) {\n            if (num % 2 == 0) {\n                freqMap[num]++;\n            }\n        }\n\n        for (const auto& entry : freqMap) {\n            if (entry.second > maxFreq || (entry.second == maxFreq && entry.first < result)) {\n                maxFreq = entry.second;\n                result = entry.first;\n            }\n        }\n\n        return result;\n    }\n};"
    }
  },
  "2405": {
    "solution": {
      "greedy": ""
    }
  },
  "2406": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2407": {
    "solution": {
      "monotonic-queue": "class Solution {\n    public int lengthOfLIS(int[] nums, int k) {\n        SegmentTree root = new SegmentTree(1, 100000);\n        int res = 0;\n        for (int num : nums) {\n            int preMax = root.rangeMaxQuery(root, num - k, num - 1);\n            root.update(root, num, preMax + 1);\n            res = Math.max(res, preMax + 1);\n        }\n        return res;\n    }\n}\n\nclass SegmentTree {\n    SegmentTree left, right;\n    int start, end, val;\n    public SegmentTree(int start, int end) {\n        this.start = start;\n        this.end = end;\n        setup(this, start, end);\n    }\n    public void setup(SegmentTree node, int start, int end) {\n        if (start == end) return;\n        int mid = start + (end - start) / 2;\n        if (node.left == null) {\n            node.left = new SegmentTree(start, mid);\n            node.right = new SegmentTree(mid + 1, end);\n        }\n        setup(node.left, start, mid);\n        setup(node.right, mid + 1, end);\n        node.val = Math.max(node.left.val, node.right.val);\n    }\n    \n    public void update(SegmentTree node, int index, int val) {\n        if (index < node.start || index > node.end) return;\n        if (node.start == node.end && node.start == index) {\n            node.val = val;\n            return;\n        }\n        update(node.left, index, val);\n        update(node.right, index, val);\n        node.val = Math.max(node.left.val, node.right.val);\n    }\n    \n    public int rangeMaxQuery(SegmentTree node, int start, int end) {\n        if (node.start > end || node.end < start) return 0;\n        if (node.start >= start && node.end <= end) return node.val;\n        return Math.max(rangeMaxQuery(node.left, start, end), rangeMaxQuery(node.right, start, end));\n    }\n}"
    }
  },
  "2408": {
    "solution": {
      "design": "class SQL {\n public:\n  // Inserts a row into the table with the given name\n  void insertRow(string name, vector<string> row) {\n    db[name].push_back(row);\n  }\n\n  // Deletes a row from the table with the given name and rowId (1-based index)\n  void deleteRow(string name, int rowId) {\n    if (rowId > 0 && rowId <= db[name].size()) {\n      db[name].erase(db[name].begin() + (rowId - 1));\n    }\n  }\n\n  // Selects a cell from the table by name, rowId (1-based index), and columnId (1-based index)\n  string selectCell(string name, int rowId, int columnId) {\n    if (rowId > 0 && rowId <= db[name].size() && columnId > 0 && columnId <= db[name][rowId - 1].size()) {\n      return db[name][rowId - 1][columnId - 1];\n    }\n    return \"\"; // Return an empty string if indices are out of bounds\n  }\n\n private:\n  unordered_map<string, vector<vector<string>>> db; // Stores the database as a map of tables\n};\n\n/**\n * Your SQL object will be instantiated and called as such:\n * SQL* obj = new SQL();\n * obj->insertRow(name, row);\n * obj->deleteRow(name, rowId);\n * string param_3 = obj->selectCell(name, rowId, columnId);\n */"
    }
  },
  "2409": {
    "solution": {
      "math": "class Solution {\npublic:\n    int countDaysTogether(string arriveAlice, string leaveAlice,\n                          string arriveBob, string leaveBob) {\n        const int arriveA = toDays(arriveAlice);\n        const int leaveA = toDays(leaveAlice);\n        const int arriveB = toDays(arriveBob);\n        const int leaveB = toDays(leaveBob);\n        int ans = 0;\n\n        for (int day = 1; day <= 365; ++day)\n            if (arriveA <= day && day <= leaveA && arriveB <= day &&\n                day <= leaveB)\n                ++ans;\n\n        return ans;\n    }\n\nprivate:\n    const vector<int> days{0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31};\n\n    int toDays(const string& s) {\n        const int month = (s[0] - '0') * 10 + (s[1] - '0');\n        const int day = (s[3] - '0') * 10 + (s[4] - '0');\n        int prevDays = 0;\n        for (int m = 1; m < month; ++m)\n            prevDays += days[m];\n        return prevDays + day;\n    }\n};\n"
    }
  },
  "2410": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2411": {
    "solution": {
      "sliding-window": "class Solution {\n  public int[] smallestSubarrays(int[] nums) {\n  int kMaxBit = 30;\n    int[] ans = new int[nums.length];\n    int[] closest = new int[kMaxBit];\n\n    Arrays.fill(ans, 1);\n\n    for (int i = nums.length - 1; i >= 0; --i)\n      for (int j = 0; j < kMaxBit; ++j) {\n        if ((nums[i] >> j & 1) == 1)\n          closest[j] = i;\n        ans[i] = Math.max(ans[i], closest[j] - i + 1);\n      }\n\n    return ans;\n  }\n}"
    }
  },
  "2412": {
    "solution": {
      "greedy": ""
    }
  },
  "2413": {
    "solution": {
      "number-theory": "class Solution {\npublic:\n    int smallestEvenMultiple(int n) {\n        if (n % 2 == 0) {\n            return n;  // If n is even, return n itself\n        } else {\n            return 2 * n;  // If n is odd, return 2 * n\n        }\n    }\n};\n"
    }
  },
  "2414": {
    "solution": {
      "string": "class Solution {\npublic:\n    int longestContinuousSubstring(string s) {\n        int ans = 1;\n        int runningLen = 1;\n\n        for (int i = 1; i < s.length(); ++i)\n            if (s[i] == s[i - 1] + 1)\n                ans = max(ans, ++runningLen);\n            else\n                runningLen = 1;\n\n        return ans;\n    }\n};"
    }
  },
  "2415": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    TreeNode* reverseOddLevels(TreeNode* root) {\n        if (!root) return nullptr; \n\n        queue<TreeNode*> q;\n        q.push(root);\n        int level = 0;\n        \n        while (!q.empty()) {\n            int size = q.size();\n            vector<TreeNode*> nodesAtCurrentLevel;\n            \n            for (int i = 0; i < size; ++i) {\n                TreeNode* node = q.front();\n                q.pop();\n                nodesAtCurrentLevel.push_back(node);\n                \n                if (node->left) q.push(node->left);\n                if (node->right) q.push(node->right);\n            }\n            \n            if (level % 2 == 1) {\n                int n = nodesAtCurrentLevel.size();\n                for (int i = 0; i < n / 2; ++i) {\n                    swap(nodesAtCurrentLevel[i]->val, nodesAtCurrentLevel[n - i - 1]->val);\n                }\n            }\n            \n            ++level;\n        }\n        \n        return root;\n    }\n};\n"
    }
  },
  "2416": {
    "solution": {
      "trie": "class Solution {\npublic:\n    vector<int> sumPrefixScores(vector<string>& words) {\n        struct TrieNode {\n            unordered_map<char, TrieNode*> children;\n            int count = 0;  \n        };\n\n        TrieNode* root = new TrieNode();\n\n        auto insert = [&](const string& word) {\n            TrieNode* node = root;\n            for (char c : word) {\n                if (!node->children.count(c))\n                    node->children[c] = new TrieNode();\n                node = node->children[c];\n                ++node->count; \n            }\n        };\n\n        auto getPrefixScore = [&](const string& word) -> int {\n            TrieNode* node = root;\n            int score = 0;\n            for (char c : word) {\n                node = node->children[c];\n                score += node->count;  \n            }\n            return score;\n        };\n\n        for (const string& word : words)\n            insert(word);\n\n        vector<int> result;\n        for (const string& word : words)\n            result.push_back(getPrefixScore(word));\n\n        return result;\n    }\n};\n"
    }
  },
  "2417": {
    "solution": {
      "enumeration": ""
    }
  },
  "2418": {
    "solution": {
      "sorting": ""
    }
  },
  "2419": {
    "solution": {
      "brainteaser": "class Solution {\n    public int longestSubarray(int[] nums) {\n        int max = 0;\n        for (int num : nums) {\n            max = Math.max(max, num);\n        }\n\n        int maxLength = 0;\n        int currentLength = 0;\n        for (int num : nums) {\n            if (num == max) {\n                currentLength++;\n                maxLength = Math.max(maxLength, currentLength);\n            } else {\n                currentLength = 0;\n            }\n        }\n        return maxLength;\n    }\n}\n"
    }
  },
  "2420": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    vector<int> goodIndices(vector<int>& nums, int k) {\n        int n = nums.size();\n        vector<int> result;\n\n        vector<int> nonInc(n, 1), nonDec(n, 1);\n\n        // Compute non-increasing prefix lengths\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] <= nums[i - 1]) {\n                nonInc[i] = nonInc[i - 1] + 1;\n            }\n        }\n\n        // Compute non-decreasing suffix lengths\n        for (int i = n - 2; i >= 0; --i) {\n            if (nums[i] <= nums[i + 1]) {\n                nonDec[i] = nonDec[i + 1] + 1;\n            }\n        }\n\n        // Check for good indices\n        for (int i = k; i < n - k; ++i) {\n            if (nonInc[i - 1] >= k && nonDec[i + 1] >= k) {\n                result.push_back(i);\n            }\n        }\n\n        return result;\n    }\n};"
    }
  },
  "2421": {
    "solution": {
      "union-find": "class UnionFind {\npublic:\n    UnionFind(int n) : parent(n), rank(n) { iota(parent.begin(), parent.end(), 0); }\n\n    void unionByRank(int u, int v) {\n        const int i = find(u);\n        const int j = find(v);\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            parent[i] = j;\n        } else if (rank[i] > rank[j]) {\n            parent[j] = i;\n        } else {\n            parent[i] = j;\n            ++rank[j];\n        }\n    }\n\n    int find(int u) { return parent[u] == u ? u : parent[u] = find(parent[u]); }\n\nprivate:\n    vector<int> parent;\n    vector<int> rank;\n};\n\nclass Solution {\npublic:\n    int numberOfGoodPaths(vector<int>& vals, vector<vector<int>>& edges) {\n        const int n = vals.size();\n        int ans = n;\n        UnionFind uf(n);\n        vector<vector<int>> tree(n);\n        map<int, vector<int>> valToNodes;\n\n        for (int i = 0; i < vals.size(); ++i)\n            valToNodes[vals[i]].push_back(i);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            if (vals[v] <= vals[u])\n                tree[u].push_back(v);\n            if (vals[u] <= vals[v])\n                tree[v].push_back(u);\n        }\n\n        for (const auto& [val, nodes] : valToNodes) {\n            for (const int u : nodes)\n                for (const int v : tree[u])\n                    uf.unionByRank(u, v);\n            unordered_map<int, int> rootCount;\n            for (const int u : nodes)\n                ++rootCount[uf.find(u)];\n            for (const auto& [_, count] : rootCount)\n                ans += count * (count - 1) / 2;\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2422": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2423": {
    "solution": {
      "counting": ""
    }
  },
  "2424": {
    "solution": {
      "union-find": ""
    }
  },
  "2425": {
    "solution": {
      "brainteaser": ""
    }
  },
  "2426": {
    "solution": {
      "merge-sort": "import java.util.*;\n\nclass Solution {\n    public long numberOfPairs(int[] nums1, int[] nums2, int diff) {\n        int n = nums1.length;\n        int[] A = new int[n];\n        \n        for (int i = 0; i < n; ++i) {\n            A[i] = nums1[i] - nums2[i];\n        }\n        \n        long[] ans = {0}; \n        mergeSort(A, 0, n - 1, diff, ans);\n        \n        return ans[0];\n    }\n\n    private void mergeSort(int[] A, int left, int right, int diff, long[] ans) {\n        if (left >= right) {\n            return;\n        }\n        \n        int m = (left + right) / 2;\n        mergeSort(A, left, m, diff, ans);\n        mergeSort(A, m + 1, right, diff, ans);\n        merge(A, left, m, right, diff, ans);\n    }\n\n    private void merge(int[] A, int left, int m, int right, int diff, long[] ans) {\n        int lo = m + 1;\n        int hi = m + 1; \n        for (int i = left; i <= m; ++i) {\n            while (hi <= right && A[i] > A[hi] + diff) {\n                ++hi;\n            }\n            ans[0] += right - hi + 1;\n        }\n        \n        int[] sorted = new int[right - left + 1];\n        int k = 0; // Index for sorted array\n        int i = left; // Index for left subarray\n        int j = m + 1; // Index for right subarray\n        \n        while (i <= m && j <= right) {\n            if (A[i] <= A[j]) {\n                sorted[k++] = A[i++];\n            } else {\n                sorted[k++] = A[j++];\n            }\n        }\n        \n        while (i <= m) {\n            sorted[k++] = A[i++];\n        }\n        \n        while (j <= right) {\n            sorted[k++] = A[j++];\n        }\n        \n        System.arraycopy(sorted, 0, A, left, sorted.length);\n    }\n}\n"
    }
  },
  "2427": {
    "solution": {
      "number-theory": "#include <cmath> \n#include <algorithm>  \n\nclass Solution {\npublic:\n    int commonFactors(int a, int b) {\n        int gcdValue = std::gcd(a, b);  \n        int count = 0;\n        \n        for (int i = 1; i <= sqrt(gcdValue); ++i) {\n            if (gcdValue % i == 0) {  \n                count++; \n                if (i != gcdValue / i) {\n                    count++;  \n                }\n            }\n        }\n        \n        return count;\n    }\n};\n"
    }
  },
  "2428": {
    "solution": {
      "matrix": ""
    }
  },
  "2429": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2430": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2431": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2432": {
    "solution": {
      "array": ""
    }
  },
  "2433": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2434": {
    "solution": {
      "stack": ""
    }
  },
  "2435": {
    "solution": {
      "matrix": "class Solution {\n  public int numberOfPaths(int[][] grid, int k) {\n    final int kMod = 1_000_000_007;\n    final int m = grid.length;\n    final int n = grid[0].length;\n    // dp[i][j][sum] : = the number of paths to(i, j), where the sum / k == sum\n    int[][][] dp = new int[m][n][k];\n    dp[0][0][grid[0][0] % k] = 1;\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j)\n        for (int sum = 0; sum < k; ++sum) {\n          final int newSum = (sum + grid[i][j]) % k;\n          if (i > 0)\n            dp[i][j][newSum] += dp[i - 1][j][sum];\n          if (j > 0)\n            dp[i][j][newSum] += dp[i][j - 1][sum];\n          dp[i][j][newSum] %= kMod;\n        }\n\n    return dp[m - 1][n - 1][0];\n  }\n}"
    }
  },
  "2436": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2437": {
    "solution": {
      "enumeration": ""
    }
  },
  "2438": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2439": {
    "solution": {
      "dynamic-programming": "class Solution {\\n public:\\n  int minimizeArrayValue(vector<int>& nums) {\\n    long ans = 0;\\n    long prefix = 0;\\n\\n    for (int i = 0; i < nums.size(); ++i) {\\n      prefix += nums[i];\\n      const long prefixAvg = ceil(prefix / static_cast<double>(i + 1));\\n      ans = max(ans, prefixAvg);\\n    }\\n\\n    return ans;\\n  }\\n};"
    }
  },
  "2440": {
    "solution": {
      "tree": ""
    }
  },
  "2441": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2442": {
    "solution": {
      "math": ""
    }
  },
  "2443": {
    "solution": {
      "enumeration": ""
    }
  },
  "2444": {
    "solution": {
      "monotonic-queue": "class Solution {\n    public long countSubarrays(int[] nums, int minK, int maxK) {\n        long ans = 0;\n        int j1 = -1, j2 = -1, k = -1;\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] < minK || nums[i] > maxK) {\n                k = i;\n            }\n            if (nums[i] == minK) {\n                j1 = i;\n            }\n            if (nums[i] == maxK) {\n                j2 = i;\n            }\n            ans += Math.max(0, Math.min(j1, j2) - k);\n        }\n        return ans;\n    }\n}"
    }
  },
  "2445": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    int numberOfNodes(int n, vector<int>& queries) {\n        vector<int> tree(n + 1);\n        vector<int> count(n + 1);\n        for (int v : queries) ++count[v];\n        function<void(int)> dfs = [&](int i) {\n            if (i > n) return;\n            tree[i] ^= 1;\n            dfs(i << 1);\n            dfs(i << 1 | 1);\n        };\n        for (int i = 0; i < n + 1; ++i) {\n            if (count[i] & 1) {\n                dfs(i);\n            }\n        }\n        return accumulate(tree.begin(), tree.end(), 0);\n    }\n};\n"
    }
  },
  "2446": {
    "solution": {
      "string": ""
    }
  },
  "2447": {
    "solution": {
      "number-theory": ""
    }
  },
  "2448": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2449": {
    "solution": {
      "greedy": ""
    }
  },
  "2450": {
    "solution": {
      "math": ""
    }
  },
  "2451": {
    "solution": {
      "hash-table": ""
    }
  },
  "2452": {
    "solution": {
      "string": ""
    }
  },
  "2453": {
    "solution": {
      "counting": ""
    }
  },
  "2454": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public int[] secondGreaterElement(int[] nums) {\n        int[] ans = new int[nums.length];\n        Arrays.fill(ans, -1);\n        // a decreasing stack that stores indices that met the first greater number\n        Deque<Integer> prevStack = new ArrayDeque<>();\n        // a decreasing stack that stores indices\n        Deque<Integer> currStack = new ArrayDeque<>();\n\n        for (int i = 0; i < nums.length; ++i) {\n            while (!prevStack.isEmpty() && nums[prevStack.peek()] < nums[i])\n                ans[prevStack.poll()] = nums[i];\n            Deque<Integer> decreasingIndices = new ArrayDeque<>();\n            while (!currStack.isEmpty() && nums[currStack.peek()] < nums[i])\n                decreasingIndices.push(currStack.poll());\n            while (!decreasingIndices.isEmpty())\n                prevStack.push(decreasingIndices.poll());\n            currStack.push(i);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2455": {
    "solution": {
      "math": ""
    }
  },
  "2456": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2457": {
    "solution": {
      "greedy": ""
    }
  },
  "2458": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    vector<int> treeQueries(TreeNode* root, vector<int>& queries) {\n        vector<int> ans;\n\n        dfs(root, 0, 0);\n\n        for (const int query : queries)\n            ans.push_back(valToMaxHeight[query]);\n\n        return ans;\n    }\n\nprivate:\n    // valToMaxHeight[val] := the maximum height without the node with `val`\n    unordered_map<int, int> valToMaxHeight;\n    // valToHeight[val] := the height of the node with `val`\n    unordered_map<int, int> valToHeight;\n\n    int height(TreeNode* root) {\n        if (root == nullptr)\n            return 0;\n        if (const auto it = valToHeight.find(root->val);\n            it != valToHeight.cend())\n            return it->second;\n        return valToHeight[root->val] =\n                   (1 + max(height(root->left), height(root->right)));\n    }\n\n    // maxHeight := the maximum height without the current node `root`\n    void dfs(TreeNode* root, int depth, int maxHeight) {\n        if (root == nullptr)\n            return;\n        valToMaxHeight[root->val] = maxHeight;\n        dfs(root->left, depth + 1, max(maxHeight, depth + height(root->right)));\n        dfs(root->right, depth + 1, max(maxHeight, depth + height(root->left)));\n    }\n};\n"
    }
  },
  "2459": {
    "solution": {
      "greedy": ""
    }
  },
  "2460": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2461": {
    "solution": {
      "sliding-window": "class Solution {\n  public long maximumSubarraySum(int[] nums, int k) {\n    long ans = 0;\n    long sum = 0;\n    int distinct = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (int i = 0; i < nums.length; ++i) {\n      sum += nums[i];\n      if (count.merge(nums[i], 1, Integer::sum) == 1)\n        ++distinct;\n      if (i >= k) {\n        if (count.merge(nums[i - k], -1, Integer::sum) == 0)\n          --distinct;\n        sum -= nums[i - k];\n      }\n      if (i >= k - 1 && distinct == k)\n        ans = Math.max(ans, sum);\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2462": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2463": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2464": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2465": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2466": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2467": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    int mostProfitablePath(vector<vector<int>>& edges, int bob,\n                           vector<int>& amount) {\n        const int n = amount.size();\n        vector<vector<int>> tree(n);\n        vector<int> parent(n);\n        vector<int> aliceDist(n, -1);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            tree[u].push_back(v);\n            tree[v].push_back(u);\n        }\n\n        dfs(tree, 0, -1, 0, parent, aliceDist);\n\n        // Modify the amount along the path from node Bob to node 0.\n        // For each node,\n        //   1. If Bob reaches earlier than Alice does, change the amount to 0.\n        //   2. If Bob and Alice reach simultaneously, devide the amount by 2.\n        for (int u = bob, bobDist = 0; u != 0; u = parent[u], ++bobDist)\n            if (bobDist < aliceDist[u])\n                amount[u] = 0;\n            else if (bobDist == aliceDist[u])\n                amount[u] /= 2;\n\n        return getMoney(tree, 0, -1, amount);\n    }\n\nprivate:\n    void dfs(const vector<vector<int>>& tree, int u, int prev, int d,\n             vector<int>& parent, vector<int>& dist) {\n        parent[u] = prev;\n        dist[u] = d;\n        for (const int v : tree[u]) {\n            if (dist[v] == -1)\n                dfs(tree, v, u, d + 1, parent, dist);\n        }\n    }\n\n    int getMoney(const vector<vector<int>>& tree, int u, int prev,\n                 const vector<int>& amount) {\n        // a leaf node\n        if (tree[u].size() == 1 && tree[u][0] == prev)\n            return amount[u];\n\n        int maxPath = INT_MIN;\n        for (const int v : tree[u])\n            if (v != prev)\n                maxPath = max(maxPath, getMoney(tree, v, u, amount));\n\n        return amount[u] + maxPath;\n    }\n};\n"
    }
  },
  "2468": {
    "solution": {
      "string": ""
    }
  },
  "2469": {
    "solution": {
      "math": "class Solution {\npublic:\n    vector<double> convertTemperature(double celsius) {\n        return {celsius + 273.15, celsius * 1.8 + 32};\n    }\n};\n"
    }
  },
  "2470": {
    "solution": {
      "number-theory": ""
    }
  },
  "2471": {
    "solution": {
      "tree": ""
    }
  },
  "2472": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2473": {
    "solution": {
      "shortest-path": "class Solution {\n public:\n  vector<long long> minCost(int n, vector<vector<int>>& roads,\n                            vector<int>& appleCost, int k) {\n    vector<long long> ans;\n    vector<vector<pair<int, long>>> graph(n);\n\n    for (const vector<int>& road : roads) {\n      const int u = road[0] - 1;\n      const int v = road[1] - 1;\n      const int w = road[2];\n      graph[u].emplace_back(v, w);\n      graph[v].emplace_back(u, w);\n    }\n\n    for (int i = 0; i < n; ++i)\n      ans.push_back(dijkstra(graph, i, appleCost, k));\n\n    return ans;\n  }\n\n private:\n  long dijkstra(const vector<vector<pair<int, long>>>& graph, int i,\n                const vector<int>& appleCost, int k) {\n    vector<long> forwardCost(graph.size(), LONG_MAX);\n    vector<long> totalCost(graph.size(), LONG_MAX);\n    forwardCost[i] = 0;\n    queue<int> q{{i}};\n\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      for (const auto& [v, w] : graph[u]) {\n        const long nextCost = forwardCost[u] + w;\n        if (nextCost >= forwardCost[v])\n          continue;\n        forwardCost[v] = nextCost;\n        // Take apple at city v and return back to city i.\n        totalCost[v] = (k + 1) * nextCost + appleCost[v];\n        q.push(v);\n      }\n    }\n\n    return min(static_cast<long>(appleCost[i]), ranges::min(totalCost));\n  }\n};"
    }
  },
  "2474": {
    "solution": {
      "database": ""
    }
  },
  "2475": {
    "solution": {
      "hash-table": "#include <iostream>\n#include <vector>\n#include <unordered_set>\nusing namespace std;\n\nclass Solution {\npublic:\n    int unequalTriplets(vector<int>& nums) {\n        int n = nums.size();\n        int count = 0;\n\n        for (int i = 0; i < n - 2; ++i) {\n            for (int j = i + 1; j < n - 1; ++j) {\n                for (int k = j + 1; k < n; ++k) {\n                    if (nums[i] != nums[j] && nums[j] != nums[k] && nums[i] != nums[k]) {\n                        count++;\n                    }\n                }\n            }\n        }\n\n        return count;\n    }\n};"
    }
  },
  "2476": {
    "solution": {
      "binary-search-tree": "/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode() {}\n *     TreeNode(int val) { this.val = val; }\n *     TreeNode(int val, TreeNode left, TreeNode right) {\n *         this.val = val;\n *         this.left = left;\n *         this.right = right;\n *     }\n * }\n */\nclass Solution {\n    private List<Integer> nums = new ArrayList<>();\n\n    public List<List<Integer>> closestNodes(TreeNode root, List<Integer> queries) {\n        inorder(root);\n        List<List<Integer>> ans = new ArrayList<>();\n        for (int x : queries) {\n            int i = Collections.binarySearch(nums, x + 1);\n            int j = Collections.binarySearch(nums, x);\n            i = i < 0 ? -i - 2 : i - 1;\n            j = j < 0 ? -j - 1 : j;\n            int mi = i >= 0 && i < nums.size() ? nums.get(i) : -1;\n            int mx = j >= 0 && j < nums.size() ? nums.get(j) : -1;\n            ans.add(List.of(mi, mx));\n        }\n        return ans;\n    }\n\n    private void inorder(TreeNode root) {\n        if (root == null) {\n            return;\n        }\n        inorder(root.left);\n        nums.add(root.val);\n        inorder(root.right);\n    }\n}\n"
    }
  },
  "2477": {
    "solution": {
      "tree": ""
    }
  },
  "2478": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2479": {
    "solution": {
      "tree": ""
    }
  },
  "2480": {
    "solution": {
      "database": ""
    }
  },
  "2481": {
    "solution": {
      "geometry": "class Solution {\npublic:\n    int numberOfCuts(int n) {\n        if (n == 1)\n            return 0;                  // No cuts needed for one part\n        return n % 2 == 0 ? n / 2 : n; // Even: n/2 cuts, Odd: n cuts\n    }\n};\n"
    }
  },
  "2482": {
    "solution": {
      "matrix": "class Solution {\n    public int[][] onesMinusZeros(int[][] grid) {\n        int m = grid.length, n = grid[0].length;\n        int[] rows = new int[m];\n        int[] cols = new int[n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                int v = grid[i][j];\n                rows[i] += v;\n                cols[j] += v;\n            }\n        }\n        int[][] diff = new int[m][n];\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                diff[i][j] = rows[i] + cols[j] - (n - rows[i]) - (m - cols[j]);\n            }\n        }\n        return diff;\n    }\n}"
    }
  },
  "2483": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2484": {
    "solution": {
      "dynamic-programming": "class Solution {\\n public:\\n  int countPalindromes(string s) {\\n    constexpr int kMod = 1'000'000'007;\\n    constexpr int kPatternSize = 5;\\n    long ans = 0;\\n\\n    for (char a = '0'; a <= '9'; ++a)\\n      for (char b = '0'; b <= '9'; ++b) {\\n        const vector<char> pattern{a, b, '.', b, a};\\n        // dp[i] := the number of subsequences of pattern[i..n) in s, where\\n        // pattern[2] can be any character\\n        vector<long> dp(kPatternSize + 1);\\n        dp.back() = 1;\\n        for (const char c : s)\\n          for (int i = 0; i < kPatternSize; ++i)\\n            if (pattern[i] == '.' || pattern[i] == c)\\n              dp[i] += dp[i + 1];\\n        ans += dp[0];\\n        ans %= kMod;\\n      }\\n\\n    return ans;\\n  }\\n};"
    }
  },
  "2485": {
    "solution": {
      "prefix-sum": "class Solution {\n    public int pivotInteger(int n) {\n        int totalSum = n * (n + 1) / 2;\n        \n        for (int x = 1; x <= n; x++) {\n            int sumLeft = x * (x + 1) / 2;            \n            int sumRight = totalSum - sumLeft + x;\n            \n            if (sumLeft == sumRight) {\n                return x;\n            }\n        }\n        \n        // Return -1 if no pivot integer is found\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n\n        // Test cases\n        System.out.println(solution.pivotInteger(8));  // Output: 6\n        System.out.println(solution.pivotInteger(1));  // Output: 1\n        System.out.println(solution.pivotInteger(5));  // Output: -1\n    }\n}\n"
    }
  },
  "2486": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2487": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    ListNode* removeNodes(ListNode* head) {\n        ListNode* prev = nullptr;\n        ListNode* curr = head;\n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        head = prev;\n\n        ListNode* newHead = head;\n        ListNode* maxNode = head;\n        curr = head->next;\n\n        while (curr) {\n            if (curr->val < maxNode->val) {\n                maxNode->next = curr->next;\n            } else {\n                maxNode = curr;\n            }\n            curr = maxNode->next;\n        }\n\n        prev = nullptr;\n        curr = newHead;\n        while (curr) {\n            ListNode* next = curr->next;\n            curr->next = prev;\n            prev = curr;\n            curr = next;\n        }\n        return prev;\n    }\n};\n"
    }
  },
  "2488": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2489": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2490": {
    "solution": {
      "string": ""
    }
  },
  "2491": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2492": {
    "solution": {
      "breadth-first-search": "class Solution {\npublic:\n    int minScore(int n, vector<vector<int>>& roads) {\n        vector<vector<pair<int, int>>> graph(n + 1);\n        \n        for (auto& road : roads) {\n            int u = road[0], v = road[1], score = road[2];\n            graph[u].push_back({v, score});\n            graph[v].push_back({u, score});\n        }\n        \n        vector<bool> visited(n + 1, false);\n        queue<int> q;\n        q.push(1);\n        visited[1] = true;\n        int minScore = INT_MAX;\n        \n        while (!q.empty()) {\n            int node = q.front();\n            q.pop();\n            \n            for (auto& neighbor : graph[node]) {\n                int nextCity = neighbor.first;\n                int roadScore = neighbor.second;\n                \n                minScore = min(minScore, roadScore);\n                \n                if (!visited[nextCity]) {\n                    visited[nextCity] = true;\n                    q.push(nextCity);\n                }\n            }\n        }\n        \n        return minScore;\n    }\n};\n"
    }
  },
  "2493": {
    "solution": {
      "union-find": ""
    }
  },
  "2494": {
    "solution": {
      "database": ""
    }
  },
  "2495": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2496": {
    "solution": {
      "string": ""
    }
  },
  "2497": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2498": {
    "solution": {
      "greedy": "",
      "binary-search": "class Solution {\npublic:\n    int maxJump(vector<int>& stones) {\n        int ans = stones[1] - stones[0];\n        for (int i = 2; i < stones.size(); ++i)\n            ans = max(ans, stones[i] - stones[i - 2]);\n        return ans;\n    }\n};"
    }
  },
  "2499": {
    "solution": {
      "counting": ""
    }
  },
  "2500": {
    "solution": {
      "matrix": ""
    }
  },
  "2501": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2502": {
    "solution": {
      "design": "class Allocator {\npublic:\n    Allocator(int n) {\n        this->memSize = n;\n        this->memory.resize(n, 0); // Initialize all memory blocks to 0\n    }\n\n    // Allocates a block of size `size` for mID, returns the starting index or -1 if not possible\n    int allocate(int size, int mID) {\n        if (size > this->memSize) {\n            return -1;\n        }\n\n        int freeLocCount = 0; // Tracks the current sequence of free blocks\n        for (int adr = 0; adr < this->memSize; ++adr) {\n            if (this->memory[adr] == 0) {\n                freeLocCount++;\n            } else {\n                freeLocCount = 0; // Reset count when encountering an occupied block\n            }\n\n            // Check if we found enough free blocks\n            if (freeLocCount == size) {\n                int startIdx = adr + 1 - freeLocCount;\n                for (int i = startIdx; i < startIdx + size; ++i) {\n                    this->memory[i] = mID; // Assign mID to the allocated blocks\n                }\n                return startIdx;\n            }\n        }\n\n        return -1; // Not enough free space\n    }\n\n    // Frees all memory blocks assigned to mID and returns the number of blocks freed\n    int freeMemory(int mID) {\n        int freedCount = 0;\n        for (int adr = 0; adr < this->memSize; ++adr) {\n            if (this->memory[adr] == mID) {\n                this->memory[adr] = 0; // Reset the block to free\n                freedCount++;\n            }\n        }\n\n        return freedCount;\n    }\n\nprivate:\n    int memSize;               // Total size of memory\n    std::vector<int> memory;   // Memory representation (0 = free, mID = allocated)\n};\n\n/**\n * Your Allocator object will be instantiated and called as such:\n * Allocator* obj = new Allocator(n);\n * int param_1 = obj->allocate(size, mID);\n * int param_2 = obj->freeMemory(mID);\n */"
    }
  },
  "2503": {
    "solution": {
      "union-find": ""
    }
  },
  "2504": {
    "solution": {
      "database": ""
    }
  },
  "2505": {
    "solution": {
      "brainteaser": ""
    }
  },
  "2506": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2507": {
    "solution": {
      "number-theory": ""
    }
  },
  "2508": {
    "solution": {
      "graph": "class Solution {\npublic:\n    bool isPossible(int n, vector<vector<int>>& edges) {\n        vector<unordered_set<int>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0] - 1;\n            const int v = edge[1] - 1;\n            graph[u].insert(v);\n            graph[v].insert(u);\n        }\n\n        const vector<int> oddNodes = getOddNodes(graph);\n        if (oddNodes.empty())\n            return true;\n        if (oddNodes.size() == 2) {\n            const int a = oddNodes[0];\n            const int b = oddNodes[1];\n            for (int i = 0; i < n; ++i)\n                if (!graph[i].contains(a) && !graph[i].contains(b))\n                    return true;\n        }\n        if (oddNodes.size() == 4) {\n            const int a = oddNodes[0];\n            const int b = oddNodes[1];\n            const int c = oddNodes[2];\n            const int d = oddNodes[3];\n            return (!graph[a].contains(b) && !graph[c].contains(d)) ||\n                   (!graph[a].contains(c) && !graph[b].contains(d)) ||\n                   (!graph[a].contains(d) && !graph[b].contains(c));\n        }\n        return false;\n    }\n\nprivate:\n    vector<int> getOddNodes(const vector<unordered_set<int>>& graph) {\n        vector<int> oddNodes;\n        for (int i = 0; i < graph.size(); ++i)\n            if (graph[i].size() % 2 == 1)\n                oddNodes.push_back(i);\n        return oddNodes;\n    }\n};"
    }
  },
  "2509": {
    "solution": {
      "tree": ""
    }
  },
  "2510": {
    "solution": {
      "matrix": "class Solution {\n  public boolean isThereAPath(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    // Map negative (the number of 0s - the number of 1s) to non-negative one.\n    int cells = m + n - 1;\n    if (cells % 2 == 1)\n      return false;\n    Boolean[][][] mem = new Boolean[m][n][cells * 2 + 1];\n    return isThereAPath(grid, 0, 0, 0, cells, mem);\n  }\n\n  // Returns 1 if there's a path to grid[i][j]\n  // s.t. `sum` = (the number of 0s - the number of 1s).\n  private boolean isThereAPath(int[][] grid, int i, int j, int sum, final int cells,\n                               Boolean[][][] mem) {\n    if (i == grid.length || j == grid[0].length)\n      return false;\n    sum += grid[i][j] == 0 ? 1 : -1;\n    if (i == grid.length - 1 && j == grid[0].length - 1)\n      return sum == 0;\n    final int k = cells + sum;\n    if (mem[i][j][k] != null)\n      return mem[i][j][k];\n    return mem[i][j][k] = isThereAPath(grid, i + 1, j, sum, cells, mem) ||\n                          isThereAPath(grid, i, j + 1, sum, cells, mem);\n  }\n}"
    }
  },
  "2511": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2512": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2513": {
    "solution": {
      "number-theory": ""
    }
  },
  "2514": {
    "solution": {
      "math": "class Solution {\npublic:\n    int countAnagrams(string s) {\n        const int n = s.length();\n        const auto [fact, invFact] = getFactAndInvFact(n);\n        int ans = 1;\n        istringstream iss(s);\n\n        for (string word; iss >> word;) {\n            ans = ans * fact[word.length()] % kMod;\n            vector<int> count(26);\n            for (const char c : word)\n                ++count[c - 'a'];\n            for (const int freq : count)\n                ans = ans * invFact[freq] % kMod;\n        }\n\n        return ans;\n    }\n\nprivate:\n    static constexpr int kMod = 1'000'000'007;\n\n    pair<vector<long>, vector<long>> getFactAndInvFact(int n) {\n        vector<long> fact(n + 1);\n        vector<long> invFact(n + 1);\n        vector<long> inv(n + 1);\n        fact[0] = invFact[0] = 1;\n        inv[0] = inv[1] = 1;\n        for (int i = 1; i <= n; ++i) {\n            if (i >= 2)\n                inv[i] = kMod - kMod / i * inv[kMod % i] % kMod;\n            fact[i] = fact[i - 1] * i % kMod;\n            invFact[i] = invFact[i - 1] * inv[i] % kMod;\n        }\n        return {fact, invFact};\n    }\n};\n"
    }
  },
  "2515": {
    "solution": {
      "string": "class Solution {\npublic:\n    int closetTarget(vector<string>& words, string target, int startIndex) {\n        int n = words.size();\n        \n        bool foundTarget = false;\n        for (int i = 0; i < n; i++) {\n            if (words[i] == target) {\n                foundTarget = true;\n                break;\n            }\n        }\n        \n        if (!foundTarget) {\n            return -1; \n        }\n\n        int clockwiseDistance = -1;\n        for (int i = 0; i < n; i++) {\n            int index = (startIndex + i) % n;\n            if (words[index] == target) {\n                clockwiseDistance = i;\n                break;\n            }\n        }\n\n        int counterclockwiseDistance = -1;\n        for (int i = 0; i < n; i++) {\n            int index = (startIndex - i + n) % n; \n            if (words[index] == target) {\n                counterclockwiseDistance = i;\n                break;\n            }\n        }\n        \n        return min(clockwiseDistance, counterclockwiseDistance);\n    }\n};\n"
    }
  },
  "2516": {
    "solution": {
      "sliding-window": "class Solution {\n    public int takeCharacters(String s, int k) {\n      int n = s.length();\n        int ans = n;\n        int[] count = new int[3];\n\n        for (final char c : s.toCharArray())\n            ++count[c - 'a'];\n\n        if (count[0] < k || count[1] < k || count[2] < k)\n            return -1;\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            --count[s.charAt(right) - 'a'];\n            while (count[s.charAt(right) - 'a'] < k)\n                ++count[s.charAt(left++) - 'a'];\n            ans = Math.min(ans, n - (right - left + 1));\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2517": {
    "solution": {
      "greedy": ""
    }
  },
  "2518": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2519": {
    "solution": {
      "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int kBigIndices(int[] nums, int k) {\n  int n = nums.length;\n    int ans = 0;\n    FenwickTree leftTree = new FenwickTree(n);\n    FenwickTree rightTree = new FenwickTree(n);\n    int[] left = new int[n];\n    int[] right = new int[n];\n\n    for (int i = 0; i < n; ++i) {\n      left[i] = leftTree.get(nums[i] - 1);\n      leftTree.add(nums[i], 1);\n    }\n\n    for (int i = n - 1; i >= 0; --i) {\n      right[i] = rightTree.get(nums[i] - 1);\n      rightTree.add(nums[i], 1);\n    }\n\n    for (int i = 0; i < n; ++i)\n      if (left[i] >= k && right[i] >= k)\n        ++ans;\n\n    return ans;\n  }\n}"
    }
  },
  "2520": {
    "solution": {
      "math": ""
    }
  },
  "2521": {
    "solution": {
      "number-theory": ""
    }
  },
  "2522": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2523": {
    "solution": {
      "number-theory": ""
    }
  },
  "2524": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxFrequencyScore(int[] nums, int k) {\n      int mod = (int) 1e9 + 7;\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int i = 0; i < k; ++i) {\n            count.put(nums[i], count.getOrDefault(nums[i], 0) + 1);\n        }\n        long curr = 0;\n        for (var e : count.entrySet()) {\n            curr = (curr + qmi(e.getKey(), e.getValue(), mod)) % mod;\n        }\n        long ans = curr;\n        for (int i = k; i < nums.length; ++i) {\n            int a = nums[i - k];\n            int b = nums[i];\n            if (a != b) {\n                if (count.getOrDefault(b, 0) > 0) {\n                    curr += (b - 1) * qmi(b, count.get(b), mod) % mod;\n                } else {\n                    curr += b;\n                }\n                if (count.getOrDefault(a, 0) > 1) {\n                    curr -= (a - 1) * qmi(a, count.get(a) - 1, mod) % mod;\n                } else {\n                    curr -= a;\n                }\n                curr = (curr + mod) % mod;\n                count.put(b, count.getOrDefault(b, 0) + 1);\n                count.put(a, count.getOrDefault(a, 0) - 1);\n                ans = Math.max(ans, curr);\n            }\n        }\n        return (int) ans;\n    }\n\n    long qmi(long a, long k, long p) {\n        long res = 1;\n        while (k != 0) {\n            if ((k & 1) == 1) {\n                res = res * a % p;\n            }\n            k >>= 1;\n            a = a * a % p;\n        }\n        return res;\n    }\n}"
    }
  },
  "2525": {
    "solution": {
      "math": ""
    }
  },
  "2526": {
    "solution": {
      "queue": "",
      "ordered-set": "class DataStream {\npublic:\n    DataStream(int value, int k) : targetValue(value), requiredCount(k), currentCount(0) {}\n\n    bool consec(int num) {\n        if (num == targetValue) {\n            currentCount++;\n        } else {\n            currentCount = 0;\n        }\n        return currentCount >= requiredCount;\n    }\n\nprivate:\n    int targetValue;  // The target value to check for\n    int requiredCount;  // The required number of consecutive occurrences\n    int currentCount;  // The current number of consecutive occurrences\n};\n\n/**\n * Your DataStream object will be instantiated and called as such:\n * DataStream* obj = new DataStream(value, k);\n * bool param_1 = obj->consec(num);\n */\n"
    }
  },
  "2527": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2528": {
    "solution": {
      "sliding-window": "class Solution {\n  public long maxPower(int[] stations, int right, int k) {\n    long left = Arrays.stream(stations).min().getAsInt();\n    long right = Arrays.stream(stations).asLongStream().sum() + k + 1;\n\n    while (left < right) {\n    long mid = (left + right) / 2;\n      if (check(stations.clone(), right, k, mid))\n        left = mid + 1;\n      else\n        right = mid;\n    }\n\n    return left - 1;\n  }\n\n  boolean check(int[] stations, int right, int additionalStations, long minPower) {\n  int n = stations.length;\n    long power = 0;\n\n    for (int i = 0; i < right; ++i)\n      power += stations[i];\n\n    for (int i = 0; i < n; ++i) {\n      if (i + right < n)\n        power += stations[i + right]; \n      if (power < minPower) {\n      long requiredPower = minPower - power;\n        if (requiredPower > additionalStations)\n          return false;\n        stations[Math.min(n - 1, i + right)] += requiredPower;\n        additionalStations -= requiredPower;\n        power += requiredPower;\n      }\n      if (i - right >= 0)\n        power -= stations[i - right];\n    }\n\n    return true;\n  }\n}"
    }
  },
  "2529": {
    "solution": {
      "counting": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maximumCount(vector<int>& nums) {\n        int n = nums.size();\n        \n        // Find the first non-negative index\n        int firstNonNegative = lower_bound(nums.begin(), nums.end(), 0) - nums.begin();\n        \n        // Find the first positive index\n        int firstPositive = upper_bound(nums.begin(), nums.end(), 0) - nums.begin();\n        \n        // Count negatives and positives\n        int negativeCount = firstNonNegative; // All elements before the first non-negative are negative\n        int positiveCount = n - firstPositive; // All elements from firstPositive to the end are positive\n        \n        return max(negativeCount, positiveCount);\n    }\n};\n"
    }
  },
  "2530": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2531": {
    "solution": {
      "counting": ""
    }
  },
  "2532": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2533": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2534": {
    "solution": {
      "queue": ""
    }
  },
  "2535": {
    "solution": {
      "math": ""
    }
  },
  "2536": {
    "solution": {
      "matrix": ""
    }
  },
  "2537": {
    "solution": {
      "sliding-window": "import java.util.*;\n\nclass Solution {\n    public long countGood(int[] nums, int k) {\n        long ans = 0;\n        int pairs = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            pairs += count.getOrDefault(nums[right], 0);\n            count.put(nums[right], count.getOrDefault(nums[right], 0) + 1);\n            \n            while (pairs >= k) {\n                pairs -= count.get(nums[left]) - 1;\n                count.put(nums[left], count.get(nums[left]) - 1);\n                left++;\n            }\n            \n            ans += left;\n        }\n\n        return ans;\n    }\n}\n"
    }
  },
  "2538": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2539": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2540": {
    "solution": {
      "two-pointers": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int getCommon(vector<int>& nums1, vector<int>& nums2) {\n        for (int num : nums1) {\n            if (binary_search(nums2.begin(), nums2.end(), num)) {\n                return num;\n            }\n        }\n        return -1; \n    }\n};\n"
    }
  },
  "2541": {
    "solution": {
      "greedy": ""
    }
  },
  "2542": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2543": {
    "solution": {
      "number-theory": ""
    }
  },
  "2544": {
    "solution": {
      "math": "class Solution {\npublic:\n    int alternateDigitSum(int n) {\n        int ans = 0;\n        int sign = 1;\n\n        for (; n > 0; n /= 10) {\n            sign *= -1;\n            ans += sign * n % 10;\n        }\n\n        return sign * ans;\n    }\n};\n"
    }
  },
  "2545": {
    "solution": {
      "matrix": ""
    }
  },
  "2546": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2547": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2548": {
    "solution": {
      "greedy": ""
    }
  },
  "2549": {
    "solution": {
      "math": ""
    }
  },
  "2550": {
    "solution": {
      "recursion": "class Solution {\npublic:\n    const int MOD = 1e9 + 7;\n\n    int monkeyMove(int n) {\n        // We need to calculate 2^n - 2, because we can choose to move\n        // the monkeys in either clockwise or counter-clockwise direction\n        // for each of the n monkeys, but the two configurations (all clockwise\n        // and all counter-clockwise) don't result in any collision. Thus, the\n        // total number of collisions is 2^n - 2.\n\n        return (modExp(2, n, MOD) - 2 + MOD) % MOD;\n    }\n\nprivate:\n    long long modExp(long long base, long long exp, int mod) {\n        if (exp == 0)\n            return 1;\n        long long half = modExp(base, exp / 2, mod);\n        half = (half * half) % mod;\n        if (exp % 2 != 0) {\n            half = (half * base) % mod;\n        }\n        return half;\n    }\n};\n"
    }
  },
  "2551": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2552": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2553": {
    "solution": {
      "array": ""
    }
  },
  "2554": {
    "solution": {
      "greedy": ""
    }
  },
  "2555": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximizeWin(int[] prizePositions, int k) {\n        int ans = 0;\n        int[] dp = new int[prizePositions.length + 1];\n\n        for (int i = 0, j = 0; i < prizePositions.length; ++i) {\n            while (prizePositions[i] - prizePositions[j] > k)\n                ++j;\n          int covered = i - j + 1;\n            dp[i + 1] = Math.max(dp[i], covered);\n            ans = Math.max(ans, dp[j] + covered);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2556": {
    "solution": {
      "matrix": "class Solution {\n    public boolean isPossibleToCutPath(int[][] grid) {\n        if (!dfs(grid, 0, 0))\n            return true;\n        // Reassign (0, 0) as 1.\n        grid[0][0] = 1;\n        return !dfs(grid, 0, 0);\n    }\n\n    // Returns true is there's a path from (0, 0) to (m - 1, n - 1).\n    // Also marks the visited path as 0 except (m - 1, n - 1).\n    private boolean dfs(int[][] grid, int i, int j) {\n        if (i == grid.length || j == grid[0].length)\n            return false;\n        if (i == grid.length - 1 && j == grid[0].length - 1)\n            return true;\n        if (grid[i][j] == 0)\n            return false;\n\n        grid[i][j] = 0;\n        return dfs(grid, i + 1, j) || dfs(grid, i, j + 1);\n    }\n}"
    }
  },
  "2557": {
    "solution": {
      "greedy": ""
    }
  },
  "2558": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2559": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2560": {
    "solution": {
      "array": "",
      "binary-search": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minCapability(vector<int>& nums, int k) {\n        int left = *min_element(nums.begin(), nums.end());\n        int right = *max_element(nums.begin(), nums.end());\n        int result = right;\n\n        auto canRob = [&](int maxCapability) -> bool {\n            int count = 0;\n            int i = 0;\n            while (i < nums.size()) {\n                if (nums[i] <= maxCapability) {\n                    count++;\n                    i += 2;\n                } else {\n                    i++;\n                }\n                if (count >= k) return true; \n            }\n            return count >= k;\n        };\n\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (canRob(mid)) {\n                result = mid;\n                right = mid - 1;\n            } else {\n                left = mid + 1;\n            }\n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "2561": {
    "solution": {
      "greedy": ""
    }
  },
  "2562": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2563": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2564": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2565": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2566": {
    "solution": {
      "greedy": ""
    }
  },
  "2567": {
    "solution": {
      "greedy": ""
    }
  },
  "2568": {
    "solution": {
      "brainteaser": "class Solution {\n    public int minImpossibleOR(int[] nums) {\n        int res = 1;\n        Set<Integer> seen = new HashSet<>();\n        for (int num : nums) {\n            seen.add(num);\n        }\n\n        while (seen.contains(res)) {\n            res <<= 1; // Move to the next power of 2\n        }\n        \n        return res;\n    }\n}\n"
    }
  },
  "2569": {
    "solution": {
      "segment-tree": ""
    }
  },
  "2570": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2571": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2572": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2573": {
    "solution": {
      "union-find": ""
    }
  },
  "2574": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2575": {
    "solution": {
      "math": ""
    }
  },
  "2576": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2577": {
    "solution": {
      "shortest-path": "class Solution {\n public:\n  int minimumTime(vector<vector<int>>& grid) {\n    if (grid[0][1] > 1 && grid[1][0] > 1)\n      return -1;\n\n    constexpr int dirs[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};\n    const int m = grid.size();\n    const int n = grid[0].size();\n    using T = tuple<int, int, int>;  // (time, i, j)\n    priority_queue<T, vector<T>, greater<>> minHeap;\n    vector<vector<bool>> seen(m, vector<bool>(n));\n\n    minHeap.emplace(0, 0, 0);\n    seen[0][0] = true;\n\n    while (!minHeap.empty()) {\n      const auto [time, i, j] = minHeap.top();\n      minHeap.pop();\n      if (i == m - 1 && j == n - 1)\n        return time;\n      for (const auto& [dx, dy] : dirs) {\n        const int x = i + dx;\n        const int y = j + dy;\n        if (x < 0 || x == m || y < 0 || y == n)\n          continue;\n        if (seen[x][y])\n          continue;\n        const int extraWait = (grid[x][y] - time) % 2 == 0 ? 1 : 0;\n        const int nextTime = max(time + 1, grid[x][y] + extraWait);\n        minHeap.emplace(nextTime, x, y);\n        seen[x][y] = true;\n      }\n    }\n\n    throw;\n  }\n};"
    }
  },
  "2578": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int splitNum(int num) {\n        vector<int> digits;\n        \n        while (num > 0) {\n            digits.push_back(num % 10);\n            num /= 10;\n        }\n        \n        sort(digits.begin(), digits.end());\n        \n        int num1 = 0, num2 = 0;\n        for (int i = 0; i < digits.size(); ++i) {\n            if (i % 2 == 0) {\n                num1 = num1 * 10 + digits[i]; // Add digit to num1\n            } else {\n                num2 = num2 * 10 + digits[i]; // Add digit to num2\n            }\n        }\n        \n        return num1 + num2;\n    }\n};"
    }
  },
  "2579": {
    "solution": {
      "math": ""
    }
  },
  "2580": {
    "solution": {
      "sorting": ""
    }
  },
  "2581": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2582": {
    "solution": {
      "math": ""
    }
  },
  "2583": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left),\n * right(right) {}\n * };\n */\nclass Solution {\npublic:\n    long long kthLargestLevelSum(TreeNode* root, int k) {\n        vector<long> levelSums;\n        dfs(root, 0, levelSums);\n        if (levelSums.size() < k)\n            return -1;\n\n        nth_element(levelSums.begin(), levelSums.begin() + k - 1,\n                    levelSums.end(), greater<>());\n        return levelSums[k - 1];\n    }\n\nprivate:\n    void dfs(TreeNode* root, int level, vector<long>& levelSums) {\n        if (root == nullptr)\n            return;\n        if (levelSums.size() == level)\n            levelSums.push_back(0);\n        levelSums[level] += root->val;\n        dfs(root->left, level + 1, levelSums);\n        dfs(root->right, level + 1, levelSums);\n    }\n};"
    }
  },
  "2584": {
    "solution": {
      "number-theory": ""
    }
  },
  "2585": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2586": {
    "solution": {
      "string": ""
    }
  },
  "2587": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2588": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2589": {
    "solution": {
      "stack": ""
    }
  },
  "2590": {
    "solution": {
      "design": "struct Task {\n    string taskDescription;\n    int dueDate;\n    unordered_set<string> tags;\n\n    // Comparator for sorting tasks by due date\n    bool operator<(const Task& other) const {\n        return dueDate < other.dueDate;\n    }\n};\n\nclass TodoList {\npublic:\n    // Add a task for a user and return the task ID\n    int addTask(int userId, string taskDescription, int dueDate, vector<string> tags) {\n        Task newTask = {\n            .taskDescription = taskDescription,\n            .dueDate = dueDate,\n            .tags = unordered_set<string>(tags.begin(), tags.end())\n        };\n\n        userIdToTaskIdToTasks[userId][++taskId] = newTask;\n        taskIds.insert(taskId);\n        return taskId;\n    }\n\n    // Get all tasks for a user sorted by due date\n    vector<string> getAllTasks(int userId) {\n        vector<string> result;\n        for (const Task& task : getTasksSortedByDueDate(userId)) {\n            result.push_back(task.taskDescription);\n        }\n        return result;\n    }\n\n    // Get tasks associated with a specific tag for a user, sorted by due date\n    vector<string> getTasksForTag(int userId, string tag) {\n        vector<string> result;\n        for (const Task& task : getTasksSortedByDueDate(userId)) {\n            if (task.tags.count(tag)) {\n                result.push_back(task.taskDescription);\n            }\n        }\n        return result;\n    }\n\n    // Complete and remove a task for a user\n    void completeTask(int userId, int taskId) {\n        if (!taskIds.count(taskId)) {\n            return; // Task ID does not exist\n        }\n\n        auto userIt = userIdToTaskIdToTasks.find(userId);\n        if (userIt == userIdToTaskIdToTasks.end()) {\n            return; // User does not exist\n        }\n\n        auto& taskMap = userIt->second;\n        if (!taskMap.count(taskId)) {\n            return; // Task ID not found for the user\n        }\n\n        taskMap.erase(taskId);\n        taskIds.erase(taskId);\n    }\n\nprivate:\n    int taskId = 0; // Global task ID counter\n    unordered_set<int> taskIds; // Set of all valid task IDs\n    unordered_map<int, unordered_map<int, Task>> userIdToTaskIdToTasks; // User's tasks\n\n    // Helper: Retrieve tasks for a user sorted by due date\n    vector<Task> getTasksSortedByDueDate(int userId) {\n        auto userIt = userIdToTaskIdToTasks.find(userId);\n        if (userIt == userIdToTaskIdToTasks.end()) {\n            return {}; // User does not exist\n        }\n\n        set<Task> sortedTasks;\n        for (const auto& [_, task] : userIt->second) {\n            sortedTasks.insert(task);\n        }\n        return {sortedTasks.begin(), sortedTasks.end()};\n    }\n};\n\n/**\n * Usage example:\n * TodoList* obj = new TodoList();\n * int id = obj->addTask(userId, taskDescription, dueDate, tags);\n * vector<string> allTasks = obj->getAllTasks(userId);\n * vector<string> taggedTasks = obj->getTasksForTag(userId, tag);\n * obj->completeTask(userId, taskId);\n */"
    }
  },
  "2591": {
    "solution": {
      "greedy": ""
    }
  },
  "2592": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2593": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2594": {
    "solution": {
      "array": ""
    }
  },
  "2595": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    vector<int> evenOddBit(int n) {\n        int evenCount = 0, oddCount = 0;\n        \n        for (int i = 0; i < 32; ++i) {\n            if ((n >> i) & 1) {\n                if (i % 2 == 0)\n                    ++evenCount;\n                else\n                    ++oddCount;\n            }\n        }\n        \n        return {evenCount, oddCount};\n    }\n};"
    }
  },
  "2596": {
    "solution": {
      "matrix": ""
    }
  },
  "2597": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2598": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    int findSmallestInteger(vector<int>& nums, int value) {\n        unordered_map<int, int> count;\n\n        for (const int num : nums)\n            ++count[(num % value + value) % value];\n\n        for (int i = 0; i < nums.size(); ++i)\n            if (--count[i % value] < 0)\n                return i;\n\n        return nums.size();\n    }\n};"
    }
  },
  "2599": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2600": {
    "solution": {
      "greedy": ""
    }
  },
  "2601": {
    "solution": {
      "number-theory": ""
    }
  },
  "2602": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2603": {
    "solution": {
      "topological-sort": ""
    }
  },
  "2604": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2605": {
    "solution": {
      "enumeration": ""
    }
  },
  "2606": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2607": {
    "solution": {
      "number-theory": ""
    }
  },
  "2608": {
    "solution": {
      "graph": ""
    }
  },
  "2609": {
    "solution": {
      "string": ""
    }
  },
  "2610": {
    "solution": {
      "hash-table": ""
    }
  },
  "2611": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    int miceAndCheese(vector<int>& reward1, vector<int>& reward2, int k) {\n        // diffs[i] := reward1[i] - reward2[i].\n        vector<int> diffs;\n\n        for (int i = 0; i < reward1.size(); ++i)\n            diffs.push_back(reward1[i] - reward2[i]);\n\n        nth_element(diffs.begin(), diffs.begin() + k, diffs.end(), greater<>());\n        return accumulate(reward2.begin(), reward2.end(), 0) +\n               accumulate(diffs.begin(), diffs.begin() + k, 0);\n    }\n};"
    }
  },
  "2612": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2613": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2614": {
    "solution": {
      "number-theory": "class Solution {\n public:\n  int diagonalPrime(vector<vector<int>>& nums) {\n    int ans = 0;\n    for (int i = 0; i < nums.size(); ++i) {\n      const int a = nums[i][i];\n      const int b = nums[i][nums.size() - i - 1];\n      if (isPrime(a))\n        ans = max(ans, a);\n      if (isPrime(b))\n        ans = max(ans, b);\n    }\n    return ans;\n  }\n\n private:\n  bool isPrime(int n) {\n    if (n <= 1)\n      return false;\n    for (int i = 2; i * i <= n; ++i)\n      if (n % i == 0)\n        return false;\n    return true;\n  }\n};"
    }
  },
  "2615": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2616": {
    "solution": {
      "greedy": ""
    }
  },
  "2617": {
    "solution": {
      "union-find": ""
    }
  },
  "2638": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2639": {
    "solution": {
      "matrix": ""
    }
  },
  "2640": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2641": {
    "solution": {
      "tree": ""
    }
  },
  "2642": {
    "solution": {
      "design": "class Graph {\npublic:\n    // Constructor to initialize the graph with nodes and edges\n    Graph(int n, vector<vector<int>>& edges) {\n        graph.resize(n);\n        for (const vector<int>& edge : edges) {\n            addEdge(edge);\n        }\n    }\n\n    // Method to add an edge to the graph\n    void addEdge(vector<int> edge) {\n        const int u = edge[0];\n        const int v = edge[1];\n        const int w = edge[2];\n        graph[u].emplace_back(v, w);\n    }\n\n    // Method to find the shortest path between two nodes using Dijkstra's algorithm\n    int shortestPath(int node1, int node2) {\n        vector<int> dist(graph.size(), INT_MAX); // Distance array initialized to infinity\n        using P = pair<int, int>; // Pair to store distance and node (dist, node)\n        priority_queue<P, vector<P>, greater<>> minHeap; // Min-heap for Dijkstra's algorithm\n\n        dist[node1] = 0; // Distance to the start node is 0\n        minHeap.emplace(0, node1);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top(); // Get the node with the smallest distance\n            minHeap.pop();\n\n            if (u == node2) {\n                return d; // If destination node is reached, return the distance\n            }\n\n            if (d > dist[u]) {\n                continue; // Skip if the distance is outdated\n            }\n\n            for (const auto& [v, w] : graph[u]) {\n                if (d + w < dist[v]) { // Relax the edge\n                    dist[v] = d + w;\n                    minHeap.emplace(dist[v], v);\n                }\n            }\n        }\n\n        return -1; // If no path exists, return -1\n    }\n\nprivate:\n    vector<vector<pair<int, int>>> graph; // Adjacency list representation of the graph\n};\n\n/**\n * Usage example:\n * Graph* obj = new Graph(n, edges);\n * obj->addEdge(edge);\n * int param_2 = obj->shortestPath(node1, node2);\n */"
    }
  },
  "2643": {
    "solution": {
      "matrix": "class Solution {\n  public int[] rowAndMaximumOnes(int[][] mat) {\n    int[] ans = new int[2];\n\n    for (int i = 0; i < mat.length; ++i) {\n      int ones = (int) Arrays.stream(mat[i]).filter(a -> a == 1).count();\n      if (ones > ans[1]) {\n        ans[0] = i;\n        ans[1] = ones;\n      }\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2644": {
    "solution": {
      "array": "class Solution {\npublic:\n    int maxDivScore(vector<int>& nums, vector<int>& divisors) {\n        int ans = -1;\n        int maxScore = -1;\n\n        for (const int divisor : divisors) {\n            const int score = ranges::count_if(\n                nums, [divisor](const int num) { return num % divisor == 0; });\n            if (score > maxScore) {\n                ans = divisor;\n                maxScore = score;\n            } else if (score == maxScore) {\n                ans = min(ans, divisor);\n            }\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2645": {
    "solution": {
      "stack": ""
    }
  },
  "2646": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2647": {
    "solution": {
      "math": "class Solution {\npublic:\n    vector<vector<int>> colorRed(int n) {\n        vector<vector<int>> ans;\n        ans.push_back({1, 1});\n        for (int i = n, k = 0; i > 1; --i, k = (k + 1) % 4) {\n            if (k == 0) {\n                for (int j = 1; j < i << 1; j += 2) {\n                    ans.push_back({i, j});\n                }\n            } else if (k == 1) {\n                ans.push_back({i, 2});\n            } else if (k == 2) {\n                for (int j = 3; j < i << 1; j += 2) {\n                    ans.push_back({i, j});\n                }\n            } else {\n                ans.push_back({i, 1});\n            }\n        }\n        return ans;\n    }\n};\n"
    }
  },
  "2651": {
    "solution": {
      "math": ""
    }
  },
  "2652": {
    "solution": {
      "math": ""
    }
  },
  "2653": {
    "solution": {
      "sliding-window": "class Solution {\n    public int[] getSubarrayBeauty(int[] nums, int k, int x) {\n        int[] ans = new int[nums.length - k + 1];\n        int[] count = new int[50];\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] < 0)\n                ++count[nums[i] + 50];\n            if (i - k >= 0 && nums[i - k] < 0)\n                --count[nums[i - k] + 50];\n            if (i + 1 >= k)\n                ans[i - k + 1] = getXthSmallestNum(count, x);\n        }\n\n        return ans;\n    }\n\n    private int getXthSmallestNum(int[] count, int x) {\n        int prefix = 0;\n        for (int i = 0; i < 50; ++i) {\n            prefix += count[i];\n            if (prefix >= x)\n                return i - 50;\n        }\n        return 0;\n    }\n}"
    }
  },
  "2654": {
    "solution": {
      "number-theory": ""
    }
  },
  "2655": {
    "solution": {
      "sorting": ""
    }
  },
  "2656": {
    "solution": {
      "greedy": ""
    }
  },
  "2657": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2658": {
    "solution": {
      "union-find": ""
    }
  },
  "2659": {
    "solution": {
      "ordered-set": "class Solution {\npublic:\n    long long countOperationsToEmptyArray(vector<int>& nums) {\n        const int n = nums.size();\n        long ans = n;\n        unordered_map<int, int> numToIndex;\n\n        for (int i = 0; i < n; ++i)\n            numToIndex[nums[i]] = i;\n\n        ranges::sort(nums);\n\n        for (int i = 1; i < n; ++i)\n            // On the i-th step we've already removed the i - 1 smallest numbers\n            // and can ignore them. If an element nums[i] has smaller index in\n            // origin array than nums[i - 1], we should rotate the whole left\n            // array n - i times to set nums[i] element on the first position.\n            if (numToIndex[nums[i]] < numToIndex[nums[i - 1]])\n                ans += n - i;\n\n        return ans;\n    }\n};"
    }
  },
  "2660": {
    "solution": {
      "array": ""
    }
  },
  "2661": {
    "solution": {
      "matrix": ""
    }
  },
  "2662": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2663": {
    "solution": {
      "greedy": ""
    }
  },
  "2664": {
    "solution": {
      "backtracking": "import java.util.*;\n\nclass Solution {\n    private int[][] board;\n    private int rows, cols;\n    private boolean foundSolution = false;\n    private final int[][] knightMoves = {\n        {-2, -1}, {-1, -2}, {1, -2}, {2, -1},\n        {2, 1}, {1, 2}, {-1, 2}, {-2, 1}\n    };\n\n    public List<List<Integer>> tourOfKnight(int rows, int cols, int startRow, int startCol) {\n        this.rows = rows;\n        this.cols = cols;\n        board = new int[rows][cols];\n        for (int[] row : board) {\n            Arrays.fill(row, -1);\n        }\n\n        board[startRow][startCol] = 0;\n        dfs(startRow, startCol, 0);\n\n        // Convert int[][] to List<List<Integer>> to match C++ vector<vector<int>>\n        List<List<Integer>> result = new ArrayList<>();\n        for (int[] row : board) {\n            List<Integer> list = new ArrayList<>();\n            for (int val : row) {\n                list.add(val);\n            }\n            result.add(list);\n        }\n        return result;\n    }\n\n    private void dfs(int row, int col, int moveCount) {\n        if (moveCount == rows * cols - 1) {\n            foundSolution = true;\n            return;\n        }\n\n        for (int[] move : knightMoves) {\n            int newRow = row + move[0];\n            int newCol = col + move[1];\n            if (isSafe(newRow, newCol)) {\n                board[newRow][newCol] = moveCount + 1;\n                dfs(newRow, newCol, moveCount + 1);\n                if (foundSolution) return;\n                board[newRow][newCol] = -1; // backtrack\n            }\n        }\n    }\n\n    private boolean isSafe(int r, int c) {\n        return r >= 0 && r < rows && c >= 0 && c < cols && board[r][c] == -1;\n    }\n\n    // Optional main for testing\n    public static void main(String[] args) {\n        Solution sol = new Solution();\n        List<List<Integer>> res = sol.tourOfKnight(5, 5, 0, 0);\n        for (List<Integer> row : res) {\n            System.out.println(row);\n        }\n    }\n}"
    }
  },
  "2668": {
    "solution": {
      "database": ""
    }
  },
  "2669": {
    "solution": {
      "database": ""
    }
  },
  "2670": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    vector<int> distinctDifferenceArray(vector<int>& nums) {\n        constexpr int kMax = 50;\n        vector<int> ans;\n        vector<int> prefixCount(kMax + 1);\n        vector<int> suffixCount(kMax + 1);\n        int distinctPrefix = 0;\n        int distinctSuffix = 0;\n\n        for (const int num : nums)\n            if (++suffixCount[num] == 1)\n                ++distinctSuffix;\n\n        for (const int num : nums) {\n            if (++prefixCount[num] == 1)\n                ++distinctPrefix;\n            if (--suffixCount[num] == 0)\n                --distinctSuffix;\n            ans.push_back(distinctPrefix - distinctSuffix);\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2671": {
    "solution": {
      "design": "class FrequencyTracker {\npublic:\n    // Adds a number and updates its frequency count\n    void add(int number) {\n        if (count[number] > 0) {\n            --freqCount[count[number]]; // Decrease the count of the old frequency\n        }\n        ++count[number]; // Increase the count of the number\n        ++freqCount[count[number]]; // Increase the frequency of the new count\n    }\n\n    // Deletes one occurrence of the number, if it exists\n    void deleteOne(int number) {\n        if (count[number] == 0) {\n            return; // No occurrences to delete\n        }\n        --freqCount[count[number]]; // Decrease the count of the old frequency\n        --count[number]; // Decrease the count of the number\n        if (count[number] > 0) {\n            ++freqCount[count[number]]; // Increase the frequency of the new count\n        }\n    }\n\n    // Returns true if any number has the exact given frequency\n    bool hasFrequency(int frequency) {\n        return freqCount[frequency] > 0; // Check if the frequency is present\n    }\n\nprivate:\n    unordered_map<int, int> count; // Stores the count of each number\n    unordered_map<int, int> freqCount; // Stores how many numbers have each frequency\n};\n\n/**\n * Your FrequencyTracker object will be instantiated and called as such:\n * FrequencyTracker* obj = new FrequencyTracker();\n * obj->add(number);\n * obj->deleteOne(number);\n * bool param_3 = obj->hasFrequency(frequency);\n */"
    }
  },
  "2672": {
    "solution": {
      "array": "class Solution {\n public:\n  vector<int> colorTheArray(int n, vector<vector<int>>& queries) {\n    vector<int> ans;\n    vector<int> arr(n);\n    int sameColors = 0;\n\n    for (const vector<int>& query : queries) {\n      const int i = query[0];\n      const int color = query[1];\n      if (i + 1 < n) {\n        if (arr[i + 1] > 0 && arr[i + 1] == arr[i])\n          --sameColors;\n        if (arr[i + 1] == color)\n          ++sameColors;\n      }\n      if (i > 0) {\n        if (arr[i - 1] > 0 && arr[i - 1] == arr[i])\n          --sameColors;\n        if (arr[i - 1] == color)\n          ++sameColors;\n      }\n      arr[i] = color;\n      ans.push_back(sameColors);\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "2673": {
    "solution": {
      "binary-tree": "class Solution {\npublic:\n    int minIncrements(int n, vector<int>& cost) {\n        int ans = 0;\n\n        for (int i = n / 2 - 1; i >= 0; --i) {\n            const int l = i * 2 + 1;\n            const int r = i * 2 + 2;\n            ans += abs(cost[l] - cost[r]);\n            // Record the information in the parent from the children. So,\n            // there's need to actually update the values in the children.\n            cost[i] += max(cost[l], cost[r]);\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2674": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * public class ListNode {\n *     int val;\n *     ListNode next;\n *     ListNode() {}\n *     ListNode(int val) { this.val = val; }\n *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n * }\n */\nclass Solution {\n    public ListNode[] splitCircularLinkedList(ListNode list) {\n        ListNode a = list, b = list;\n        while (b.next != list && b.next.next != list) {\n            a = a.next;\n            b = b.next.next;\n        }\n        if (b.next != list) {\n            b = b.next;\n        }\n        ListNode list2 = a.next;\n        b.next = list2;\n        a.next = list;\n        return new ListNode[] {list, list2};\n    }\n}"
    }
  },
  "2678": {
    "solution": {
      "string": ""
    }
  },
  "2679": {
    "solution": {
      "matrix": "class Solution {\n    public int matrixSum(int[][] nums) {\n        int ans = 0;\n\n        for (int[] row : nums)\n            Arrays.sort(row);\n\n        for (int j = 0; j < nums[0].length; ++j) {\n            int max = 0;\n            for (int i = 0; i < nums.length; ++i)\n                max = Math.max(max, nums[i][j]);\n            ans += max;\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2680": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    long long maximumOr(vector<int>& nums, int k) {\n        const int n = nums.size();\n        long ans = 0;\n        // prefix[i] := nums[0] | nums[1] | ... | nums[i - 1]\n        vector<long> prefix(n);\n        // suffix[i] := nums[i + 1] | nums[i + 2] | ... nums[n - 1]\n        vector<long> suffix(n);\n\n        for (int i = 1; i < n; ++i)\n            prefix[i] = prefix[i - 1] | nums[i - 1];\n\n        for (int i = n - 2; i >= 0; --i)\n            suffix[i] = suffix[i + 1] | nums[i + 1];\n\n        // For each num, greedily shift it left by k bits.\n        for (int i = 0; i < n; ++i)\n            ans = max(ans, prefix[i] | static_cast<long>(nums[i]) << k | suffix[i]);\n\n        return ans;\n    }\n};"
    }
  },
  "2681": {
    "solution": {
      "math": "class Solution {\npublic:\n    int sumOfPower(vector<int>& nums) {\n        const int mod = 1e9 + 7;\n        sort(nums.rbegin(), nums.rend());\n        long long result = 0, prevSum = 0;\n        for (long long num : nums) {\n            result = (result + (num * num % mod) * num) % mod;\n            result = (result + num * prevSum % mod) % mod;\n            prevSum = (prevSum * 2 + num * num % mod) % mod;\n        }\n        return result;\n    }\n};\n"
    }
  },
  "2682": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    vector<int> circularGameLosers(int n, int k) {\n        vector<int> ans;\n        vector<bool> seen(n);\n\n        for (int friendIndex = 0, turn = 1; !seen[friendIndex];) {\n            seen[friendIndex] = true;\n            friendIndex += turn++ * k;\n            friendIndex %= n;\n        }\n\n        for (int friendIndex = 0; friendIndex < n; ++friendIndex)\n            if (!seen[friendIndex])\n                ans.push_back(friendIndex + 1);\n\n        return ans;\n    }\n};"
    }
  },
  "2683": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2684": {
    "solution": {
      "matrix": ""
    }
  },
  "2685": {
    "solution": {
      "graph": ""
    }
  },
  "2686": {
    "solution": {
      "database": ""
    }
  },
  "2687": {
    "solution": {
      "database": ""
    }
  },
  "2688": {
    "solution": {
      "database": ""
    }
  },
  "2689": {
    "solution": {
      "binary-tree": "/**\n * Definition for a rope tree node.\n * struct RopeTreeNode {\n *     int len;\n *     string val;\n *     RopeTreeNode *left;\n *     RopeTreeNode *right;\n *     RopeTreeNode() : len(0), val(\"\"), left(nullptr), right(nullptr) {}\n *     RopeTreeNode(string s) : len(0), val(std::move(s)), left(nullptr), right(nullptr) {}\n *     RopeTreeNode(int x) : len(x), val(\"\"), left(nullptr), right(nullptr) {}\n *     RopeTreeNode(int x, RopeTreeNode *left, RopeTreeNode *right) : len(x), val(\"\"), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    char getKthCharacter(RopeTreeNode* root, int k) {\n        function<string(RopeTreeNode* root)> dfs = [&](RopeTreeNode* root) -> string {\n            if (root == nullptr) {\n                return \"\";\n            }\n            if (root->len == 0) {\n                return root->val;\n            }\n            string left = dfs(root->left);\n            string right = dfs(root->right);\n            return left + right;\n        }; \n        return dfs(root)[k - 1];\n    }\n};"
    }
  },
  "2696": {
    "solution": {
      "stack": ""
    }
  },
  "2697": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2698": {
    "solution": {
      "backtracking": ""
    }
  },
  "2699": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2701": {
    "solution": {
      "database": ""
    }
  },
  "2702": {
    "solution": {
      "array": ""
    }
  },
  "2706": {
    "solution": {
      "sorting": ""
    }
  },
  "2707": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2708": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2709": {
    "solution": {
      "union-find": ""
    }
  },
  "2710": {
    "solution": {
      "string": ""
    }
  },
  "2711": {
    "solution": {
      "matrix": ""
    }
  },
  "2712": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2713": {
    "solution": {
      "matrix": "",
      "ordered-set": "class Solution {\npublic:\n    int maxIncreasingCells(vector<vector<int>>& mat) {\n        const int m = mat.size();\n        const int n = mat[0].size();\n        // rows[i] := the maximum path length for the i-th row\n        vector<int> rows(m);\n        // cols[j] := the maximum path length for the j-th column\n        vector<int> cols(n);\n        unordered_map<int, vector<pair<int, int>>> valToIndices;\n        // maxPathLength[i][j] := the maximum path length from mat[i][j]\n        vector<vector<int>> maxPathLength(m, vector<int>(n));\n        // Sort all the unique values in the matrix in non-increasing order.\n        set<int, greater<>> decreasingSet;\n\n        for (int i = 0; i < m; ++i)\n            for (int j = 0; j < n; ++j) {\n                valToIndices[mat[i][j]].emplace_back(i, j);\n                decreasingSet.insert(mat[i][j]);\n            }\n\n        for (const int val : decreasingSet) {\n            for (const auto& [i, j] : valToIndices[val])\n                maxPathLength[i][j] = max(rows[i], cols[j]) + 1;\n            for (const auto& [i, j] : valToIndices[val]) {\n                rows[i] = max(rows[i], maxPathLength[i][j]);\n                cols[j] = max(cols[j], maxPathLength[i][j]);\n            }\n        }\n\n        return max(ranges::max(rows), ranges::max(cols));\n    }\n};"
    }
  },
  "2714": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2716": {
    "solution": {
      "hash-table": ""
    }
  },
  "2717": {
    "solution": {
      "array": ""
    }
  },
  "2718": {
    "solution": {
      "hash-table": ""
    }
  },
  "2719": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2720": {
    "solution": {
      "database": ""
    }
  },
  "2728": {
    "solution": {
      "interactive": ""
    }
  },
  "2729": {
    "solution": {
      "math": ""
    }
  },
  "2730": {
    "solution": {
      "sliding-window": "class Solution {\n  public int longestSemiRepetitiveSubstring(String s) {\n    int ans = 1;\n    int prevStart = 0;\n    int start = 0;\n\n    for (int i = 1; i < s.length(); ++i) {\n      if (s.charAt(i) == s.charAt(i - 1)) {\n        if (prevStart > 0)\n          start = prevStart;\n        prevStart = i;\n      }\n      ans = Math.max(ans, i - start + 1);\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2731": {
    "solution": {
      "brainteaser": ""
    }
  },
  "2732": {
    "solution": {
      "matrix": ""
    }
  },
  "2733": {
    "solution": {
      "sorting": ""
    }
  },
  "2734": {
    "solution": {
      "greedy": ""
    }
  },
  "2735": {
    "solution": {
      "enumeration": ""
    }
  },
  "2736": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2737": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2738": {
    "solution": {
      "database": ""
    }
  },
  "2739": {
    "solution": {
      "math": "class Solution {\npublic:\n    int distanceTraveled(int mainTank, int additionalTank) {\n        // M  M M M M  A  M M M M   A\n        // 1 [2 3 4 5] 6 [7 8 9 10] 11\n        return (mainTank + min((mainTank - 1) / 4, additionalTank)) * 10;\n    }\n};\n"
    }
  },
  "2740": {
    "solution": {
      "sorting": ""
    }
  },
  "2741": {
    "solution": {
      "dynamic-programming": "#include <numeric>\\n#include <unordered_map>\\n#include <vector>\\nusing namespace std;\\n\\nconst int MOD = 1e9 + 7;\\nint dp[14][(1 << 14) + 5];\\n\\nclass Solution {\\npublic:\\n    int helper(vector<int>& nums, int prev, int mask) {\\n        if (mask == (1 << nums.size()) - 1)\\n            return 1;\\n        if (dp[prev][mask] != -1)\\n            return dp[prev][mask];\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            if ((mask & (1 << i)) == 0 &&\\n                (nums[i] % nums[prev] == 0 || nums[prev] % nums[i] == 0)) {\\n                ans += helper(nums, i, mask | (1 << i)) % MOD;\\n                ans = ans % MOD;\\n            }\\n        }\\n        return dp[prev][mask] = ans;\\n    }\\n    int specialPerm(vector<int>& nums) {\\n        memset(dp, -1, sizeof dp);\\n        int ans = 0;\\n        for (int i = 0; i < nums.size(); i++) {\\n            ans += helper(nums, i, (1 << i)) % MOD;\\n            ans = ans % MOD;\\n        }\\n        return ans;\\n    }\\n};"
    }
  },
  "2742": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2743": {
    "solution": {
      "sliding-window": "class Solution {\n    public int numberOfSpecialSubstrings(String s) {\n        int n = s.length();\n        int ans = 0;\n        int[] count = new int[26];\n        for (int i = 0, j = 0; i < n; ++i) {\n            int k = s.charAt(i) - 'a';\n            ++count[k];\n            while (count[k] > 1) {\n                --count[s.charAt(j++) - 'a'];\n            }\n            ans += i - j + 1;\n        }\n        return ans;\n    }\n}"
    }
  },
  "2744": {
    "solution": {
      "hash-table": ""
    }
  },
  "2745": {
    "solution": {
      "brainteaser": "class Solution {\n    public int longestString(int x, int y, int z) {\n        int min = Math.min(x, y);\n        if (x == y)\n            return (min * 2 + z) * 2;\n        return (min * 2 + 1 + z) * 2;\n    }\n}"
    }
  },
  "2746": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2747": {
    "solution": {
      "sliding-window": "class Solution {\n    private class Query {\n        public int query;\n        public int index;\n        public Query(int q, int index) {\n            this.query = q;\n            this.index = index;\n        }\n    }\n\n    public int[] countServers(int n, int[][] logs, int x, int[] queries) {\n        Arrays.sort(logs, (int[] a, int[] b) -> Integer.compare(a[1], b[1]));\n        List<Query> queryList = new ArrayList<>();\n        for (int i = 0; i < queries.length; ++i) {\n            queryList.add(new Query(queries[i], i));\n        }\n        Collections.sort(queryList, (a, b) -> Integer.compare(a.query, b.query));\n\n        int[] ans = new int[queries.length];\n        Map<Integer, Integer> countMap = new HashMap<>();\n        int left = 0;\n        int right = 0;\n        for (int i = 0; i < queryList.size(); ++i) {\n            Query q = queryList.get(i);\n            while (right < logs.length && logs[right][1] <= q.query) {\n                countMap.put(logs[right][0], countMap.getOrDefault(logs[right][0], 0) + 1);\n                ++right;\n            }\n\n            while (left < logs.length && logs[left][1] < q.query - x) {\n                int newCount = countMap.get(logs[left][0]) - 1;\n                if (newCount == 0) {\n                    countMap.remove(logs[left][0]);\n                } else {\n                    countMap.put(logs[left][0], newCount);\n                }\n                ++left;\n            }\n            ans[q.index] = n - countMap.size();\n        }\n        return ans;\n    }\n}"
    }
  },
  "2748": {
    "solution": {
      "number-theory": ""
    }
  },
  "2749": {
    "solution": {
      "brainteaser": ""
    }
  },
  "2750": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2751": {
    "solution": {
      "stack": "class Robot {\n    public int index;\n    public int position;\n    public int health;\n    public char direction;\n\n    public Robot(int index, int position, int health, char direction) {\n        this.index = index;\n        this.position = position;\n        this.health = health;\n        this.direction = direction;\n    }\n}\n\nclass Solution {\n    public List<Integer> survivedRobotsHealths(int[] positions, int[] healths,\n            String directions) {\n        List<Integer> ans = new ArrayList<>();\n        Robot[] robots = new Robot[positions.length];\n        List<Robot> stack = new ArrayList<>();\n        for (int i = 0; i < positions.length; ++i)\n            robots[i] = new Robot(i, positions[i], healths[i], directions.charAt(i));\n\n        Arrays.sort(robots, (a, b) -> a.position - b.position);\n\n        for (Robot robot : robots) {\n            if (robot.direction == 'R') {\n                stack.add(robot);\n                continue;\n            }\n            while (!stack.isEmpty() && stack.get(stack.size() - 1).direction == 'R'\n                    && robot.health > 0) {\n                if (stack.get(stack.size() - 1).health == robot.health) {\n                    stack.remove(stack.size() - 1);\n                    robot.health = 0;\n                } else if (stack.get(stack.size() - 1).health < robot.health) {\n                    stack.remove(stack.size() - 1);\n                    robot.health -= 1;\n                } else {\n                    stack.get(stack.size() - 1).health -= 1;\n                    robot.health = 0;\n                }\n            }\n            if (robot.health > 0)\n                stack.add(robot);\n        }\n\n        stack.sort((a, b) -> a.index - b.index);\n\n        for (Robot robot : stack)\n            ans.add(robot.health);\n\n        return ans;\n    }\n}"
    }
  },
  "2752": {
    "solution": {
      "database": ""
    }
  },
  "2760": {
    "solution": {
      "sliding-window": "class Solution {\n    public int longestAlternatingSubarray(int[] nums, int threshold) {\n        int ans = 0;\n        int dp = 0;\n\n        for (int i = 0; i < nums.length; ++i) {\n            if (nums[i] > threshold)\n                dp = 0;\n            else if (i > 0 && dp > 0 && isOddEven(nums[i - 1], nums[i]))\n                ++dp;\n            else\n                dp = nums[i] % 2 == 0 ? 1 : 0;\n            ans = Math.max(ans, dp);\n        }\n\n        return ans;\n    }\n\n    private boolean isOddEven(int a, int b) {\n        return a % 2 != b % 2;\n    }\n}"
    }
  },
  "2761": {
    "solution": {
      "number-theory": ""
    }
  },
  "2762": {
    "solution": {
      "monotonic-queue": "import java.util.Deque;\nimport java.util.LinkedList;\n\nclass Solution {\n    public long continuousSubarrays(int[] nums) {\n        long count = 0;\n        int left = 0;\n        Deque<Integer> maxDeque = new LinkedList<>();\n        Deque<Integer> minDeque = new LinkedList<>();\n\n        for (int right = 0; right < nums.length; right++) {\n            while (!maxDeque.isEmpty() && nums[maxDeque.peekLast()] <= nums[right]) {\n                maxDeque.pollLast();\n            }\n            maxDeque.offerLast(right);\n\n            while (!minDeque.isEmpty() && nums[minDeque.peekLast()] >= nums[right]) {\n                minDeque.pollLast();\n            }\n            minDeque.offerLast(right);\n\n            while (nums[maxDeque.peekFirst()] - nums[minDeque.peekFirst()] > 2) {\n                left++;\n                if (maxDeque.peekFirst() < left) {\n                    maxDeque.pollFirst();\n                }\n                if (minDeque.peekFirst() < left) {\n                    minDeque.pollFirst();\n                }\n            }\n\n            count += right - left + 1;\n        }\n\n        return count;\n    }\n\n    public static void main(String[] args) {\n        Solution solution = new Solution();\n        int[] nums1 = {5, 4, 2, 4};\n        System.out.println(solution.continuousSubarrays(nums1)); \n\n        int[] nums2 = {1, 2, 3};\n        System.out.println(solution.continuousSubarrays(nums2));\n    }\n}\n"
    }
  },
  "2763": {
    "solution": {
      "ordered-set": ""
    }
  },
  "2764": {
    "solution": {
      "binary-tree": "class Solution {\n public:\n  bool isPreorder(vector<vector<int>>& nodes) {\n    stack<int> stack;  // Stores `id`s.\n\n    for (const vector<int>& node : nodes) {\n      const int id = node[0];\n      const int parentId = node[1];\n      if (parentId == -1) {\n        stack.push(id);\n        continue;\n      }\n      while (!stack.empty() && stack.top() != parentId)\n        stack.pop();\n      if (stack.empty())\n        return false;\n      stack.push(id);\n    }\n\n    return true;\n  }\n};"
    }
  },
  "2765": {
    "solution": {
      "enumeration": ""
    }
  },
  "2766": {
    "solution": {
      "sorting": ""
    }
  },
  "2767": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2768": {
    "solution": {
      "enumeration": ""
    }
  },
  "2769": {
    "solution": {
      "math": ""
    }
  },
  "2770": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2771": {
    "solution": {
      "dynamic-programming": "class Solution {\\npublic:\\n    int maxNonDecreasingLength(vector<int>& nums1, vector<int>& nums2) {\\n        int ans = 1;\\n        int dp1 = 1; // the longest subarray that ends in nums1[i] so far\\n        int dp2 = 1; // the longest subarray that ends in nums2[i] so far\\n\\n        for (int i = 1; i < nums1.size(); ++i) {\\n            const int dp11 = nums1[i - 1] <= nums1[i] ? dp1 + 1 : 1;\\n            const int dp21 = nums2[i - 1] <= nums1[i] ? dp2 + 1 : 1;\\n            const int dp12 = nums1[i - 1] <= nums2[i] ? dp1 + 1 : 1;\\n            const int dp22 = nums2[i - 1] <= nums2[i] ? dp2 + 1 : 1;\\n            dp1 = max(dp11, dp21);\\n            dp2 = max(dp12, dp22);\\n            ans = max({ans, dp1, dp2});\\n        }\\n\\n        return ans;\\n    }\\n};"
    }
  },
  "2772": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2773": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int heightOfTree(TreeNode* root) {\n        int ans = 0;\n        function<void(TreeNode*, int)> dfs = [&](TreeNode* root, int d) {\n            ans = max(ans, d++);\n            if (root->left && root->left->right != root) {\n                dfs(root->left, d);\n            }\n            if (root->right && root->right->left != root) {\n                dfs(root->right, d);\n            }\n        };\n        dfs(root, 0);\n        return ans;\n    }\n};"
    }
  },
  "2778": {
    "solution": {
      "enumeration": ""
    }
  },
  "2779": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximumBeauty(int[] nums, int k) {\n        int ans = 0;\n\n        Arrays.sort(nums);\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            while (nums[right] - nums[left] > 2 * k)\n                ++left;\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2780": {
    "solution": {
      "sorting": ""
    }
  },
  "2781": {
    "solution": {
      "sliding-window": "class Solution {\n    public int longestValidSubstring(String word, List<String> forbidden) {\n        int ans = 0;\n        Set<String> forbiddenSet = new HashSet<>(forbidden);\n\n        int right = word.length() - 1;\n        for (int left = word.length() - 1; left >= 0; --left) {\n            for (int end = left; end < Math.min(left + 10, right + 1); ++end)\n                if (forbiddenSet.contains(word.substring(left, end + 1))) {\n                    right = end - 1;\n                    break;\n                }\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2782": {
    "solution": {
      "union-find": ""
    }
  },
  "2783": {
    "solution": {
      "database": ""
    }
  },
  "2784": {
    "solution": {
      "sorting": "class Solution {\npublic:\n    bool isGood(vector<int>& nums) {\n        constexpr int kMax = 200;\n        const int n = nums.size() - 1;\n        vector<int> count(kMax + 1);\n\n        for (const int num : nums)\n            ++count[num];\n\n        return all_of(count.begin() + 1, count.begin() + n,\n                      [](int c) { return c == 1; }) &&\n               count[n] == 2;\n    }\n};"
    }
  },
  "2785": {
    "solution": {
      "sorting": "class Solution {\npublic:\n    string sortVowels(string s) {\n        string ans;\n        vector<char> vowels;\n\n        for (const char c : s)\n            if (isVowel(c))\n                vowels.push_back(c);\n\n        ranges::sort(vowels);\n\n        int i = 0; // vowels' index\n        for (const char c : s)\n            ans += isVowel(c) ? vowels[i++] : c;\n\n        return ans;\n    }\n\nprivate:\n    bool isVowel(char c) {\n        static constexpr string_view kVowels = \"aeiouAEIOU\";\n        return kVowels.find(c) != string_view::npos;\n    }\n};"
    }
  },
  "2786": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2787": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2788": {
    "solution": {
      "string": "class Solution {\npublic:\n    vector<string> splitWordsBySeparator(vector<string>& words,\n                                         char separator) {\n        vector<string> ans;\n\n        for (const string& word : words) {\n            istringstream iss(word);\n            for (string word; getline(iss, word, separator);)\n                if (!word.empty())\n                    ans.push_back(word);\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2789": {
    "solution": {
      "greedy": ""
    }
  },
  "2790": {
    "solution": {
      "greedy": ""
    }
  },
  "2791": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    vector<vector<int>> findPrimePairs(int n) {\n        vector<vector<int>> result;\n        \n        vector<bool> isPrime(n + 1, true);\n        isPrime[0] = isPrime[1] = false; // 0 and 1 are not prime numbers\n        for (int i = 2; i * i <= n; ++i) {\n            if (isPrime[i]) {\n                for (int j = i * i; j <= n; j += i) {\n                    isPrime[j] = false;\n                }\n            }\n        }\n        \n        for (int i = 2; i <= n / 2; ++i) {\n            if (isPrime[i] && isPrime[n - i]) {\n                result.push_back({i, n - i});\n            }\n        }\n        \n        return result;\n    }\n};\n"
    }
  },
  "2792": {
    "solution": {
      "binary-tree": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int countGreatEnoughNodes(TreeNode* root, int k) {\n        int ans = 0;\n        function<priority_queue<int>(TreeNode*)> dfs = [&](TreeNode* root) {\n            if (!root) {\n                return priority_queue<int>();\n            }\n            auto left = dfs(root->left);\n            auto right = dfs(root->right);\n            while (right.size()) {\n                left.push(right.top());\n                right.pop();\n                if (left.size() > k) {\n                    left.pop();\n                }\n            }\n            if (left.size() == k && left.top() < root->val) {\n                ++ans;\n            }\n            left.push(root->val);\n            if (left.size() > k) {\n                left.pop();\n            }\n            return left;\n        };\n        dfs(root);\n        return ans;\n    }\n};"
    }
  },
  "2798": {
    "solution": {
      "array": ""
    }
  },
  "2799": {
    "solution": {
      "sliding-window": "import java.util.HashSet;\nimport java.util.HashMap;\nimport java.util.Set;\n\nclass Solution {\n    public int countCompleteSubarrays(int[] nums) {\n        Set<Integer> uniqueElements = new HashSet<>();\n        for (int num : nums) {\n            uniqueElements.add(num);\n        }\n        int uniqueCount = uniqueElements.size();\n        int result = 0;\n        HashMap<Integer, Integer> windowCounts = new HashMap<>();\n        int left = 0;\n        \n        for (int right = 0; right < nums.length; right++) {\n            windowCounts.put(nums[right], windowCounts.getOrDefault(nums[right], 0) + 1);\n            \n            while (windowCounts.size() == uniqueCount) {\n                result += nums.length - right;\n                int leftNum = nums[left];\n                windowCounts.put(leftNum, windowCounts.get(leftNum) - 1);\n                if (windowCounts.get(leftNum) == 0) {\n                    windowCounts.remove(leftNum);\n                }\n                left++;\n            }\n        }\n        \n        return result;\n    }\n}\n"
    }
  },
  "2800": {
    "solution": {
      "enumeration": ""
    }
  },
  "2801": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2802": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2806": {
    "solution": {
      "math": ""
    }
  },
  "2807": {
    "solution": {
      "number-theory": ""
    }
  },
  "2808": {
    "solution": {
      "hash-table": ""
    }
  },
  "2809": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2810": {
    "solution": {
      "string": ""
    }
  },
  "2811": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2812": {
    "solution": {
      "union-find": ""
    }
  },
  "2813": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2814": {
    "solution": {
      "matrix": ""
    }
  },
  "2815": {
    "solution": {
      "hash-table": ""
    }
  },
  "2816": {
    "solution": {
      "stack": ""
    }
  },
  "2817": {
    "solution": {
      "ordered-set": "#include <cmath>\n#include <limits>\n#include <set>\n#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minAbsoluteDifference(vector<int>& nums, int x) {\n        if (x == 0)\n            return 0; // Edge case: x cannot be zero as |i - j| >= x\n\n        int n = nums.size();\n        set<int> orderedSet;\n        int minDiff = numeric_limits<int>::max();\n\n        for (int i = x; i < n; ++i) {\n            orderedSet.insert(nums[i - x]);\n\n            // Find the closest numbers in the set\n            auto it = orderedSet.lower_bound(nums[i]);\n\n            // Check the number >= nums[i]\n            if (it != orderedSet.end()) {\n                minDiff = min(minDiff, abs(*it - nums[i]));\n            }\n\n            // Check the number < nums[i]\n            if (it != orderedSet.begin()) {\n                minDiff = min(minDiff, abs(*prev(it) - nums[i]));\n            }\n        }\n\n        return minDiff;\n    }\n};\n"
    }
  },
  "2818": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2819": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2824": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2825": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2826": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2827": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2828": {
    "solution": {
      "string": ""
    }
  },
  "2829": {
    "solution": {
      "greedy": ""
    }
  },
  "2830": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2831": {
    "solution": {
      "sliding-window": "class Solution {\n  public int longestEqualSubarray(List<Integer> nums, int k) {\n    int ans = 0;\n    Map<Integer, Integer> count = new HashMap<>();\n\n    for (int left = 0, right = 0; right < nums.size(); ++right) {\n      ans = Math.max(ans, count.merge(nums.get(right), 1, Integer::sum));\n      while (right - left + 1 - k > ans)\n        count.merge(nums.get(left++), -1, Integer::sum);\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "2832": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2833": {
    "solution": {
      "string": "class Solution {\npublic:\n    int furthestDistanceFromOrigin(string moves) {\n        int countL = 0;\n        int countR = 0;\n        int countUnderline = 0;\n\n        for (const char c : moves)\n            if (c == 'L')\n                ++countL;\n            else if (c == 'R')\n                ++countR;\n            else // c == '_'\n                ++countUnderline;\n\n        return abs(countL - countR) + countUnderline;\n    }\n};"
    }
  },
  "2834": {
    "solution": {
      "greedy": ""
    }
  },
  "2835": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2836": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2837": {
    "solution": {
      "database": ""
    }
  },
  "2838": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2839": {
    "solution": {
      "string": ""
    }
  },
  "2840": {
    "solution": {
      "sorting": ""
    }
  },
  "2841": {
    "solution": {
      "sliding-window": "public class Solution {\n    public long maxSum(List<Integer> nums, int m, int k) {\n        long ans = 0;\n        long sum = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int i = 0; i < nums.size(); ++i) {\n            sum += nums.get(i);\n            count.merge(nums.get(i), 1, Integer::sum);\n            if (i >= k) {\n              int numToRemove = nums.get(i - k);\n                sum -= numToRemove;\n                count.merge(numToRemove, -1, Integer::sum);\n                if (count.get(numToRemove) == 0)\n                    count.remove(numToRemove);\n            }\n            if (count.size() >= m)\n                ans = Math.max(ans, sum);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2842": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2843": {
    "solution": {
      "enumeration": ""
    }
  },
  "2844": {
    "solution": {
      "enumeration": ""
    }
  },
  "2845": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2846": {
    "solution": {
      "strongly-connected-component": "class Solution {\n  public int[] minOperationsQueries(int n, int[][] edges, int[][] queries) {\n  int kMax = 26;\n  int m = (int) (Math.log(n) / Math.log(2)) + 1;\n    int[] ans = new int[queries.length];\n    List<Pair<Integer, Integer>>[] graph = new List[n];\n    int[][] jump = new int[n][m];\n    int[][] count = new int[n][];\n    int[] depth = new int[n];\n\n    for (int i = 0; i < n; ++i)\n      graph[i] = new ArrayList<>();\n\n    for (int[] edge : edges) {\n    int u = edge[0];\n    int v = edge[1];\n    int w = edge[2];\n      graph[u].add(new Pair<>(v, w));\n      graph[v].add(new Pair<>(u, w));\n    }\n\n    count[0] = new int[kMax + 1];\n    dfs(graph, 0, -1, 0, jump, count, depth);\n\n    for (int j = 1; j < m; ++j)\n      for (int i = 0; i < n; ++i)\n        jump[i][j] = jump[jump[i][j - 1]][j - 1];\n\n    for (int i = 0; i < queries.length; ++i) {\n    int u = queries[i][0];\n    int v = queries[i][1];\n    int lca = getLCA(u, v, jump, depth);\n    int numEdges = depth[u] + depth[v] - 2 * depth[lca];\n      int maxFreq = 0;\n      for (int j = 1; j <= kMax; ++j)\n        maxFreq = Math.max(maxFreq, count[u][j] + count[v][j] - 2 * count[lca][j]);\n      ans[i] = numEdges - maxFreq;\n    }\n\n    return ans;\n  }\n\n  private void dfs(List<Pair<Integer, Integer>>[] graph, int u, int prev, int d, int[][] jump,\n                   int[][] count, int[] depth) {\n    if (prev != -1)\n      jump[u][0] = prev;\n    depth[u] = d;\n    for (Pair<Integer, Integer> pair : graph[u]) {\n    int v = pair.getKey();\n    int w = pair.getValue();\n      if (v == prev)\n        continue;\n      count[v] = count[u].clone();\n      ++count[v][w];\n      dfs(graph, v, u, d + 1, jump, count, depth);\n    }\n  }\n\n  private int getLCA(int u, int v, int[][] jump, int[] depth) {\n    if (depth[u] > depth[v])\n      return getLCA(v, u, jump, depth);\n    for (int j = 0; j < jump[0].length; ++j)\n      if ((depth[v] - depth[u] >> j & 1) == 1)\n        v = jump[v][j];\n    if (u == v)\n      return u;\n    for (int j = jump[0].length - 1; j >= 0; --j)\n      if (jump[u][j] != jump[v][j]) {\n        u = jump[u][j];\n        v = jump[v][j];\n      }\n    return jump[v][0];\n  }\n}\n"
    }
  },
  "2847": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    string smallestNumber(long long n) {\n        int count[10]{};\n        for (int i = 9; i > 1; --i) {\n            while (n % i == 0) {\n                n /= i;\n                ++count[i];\n            }\n        }\n        if (n > 1) {\n            return \"-1\";\n        }\n        string ans;\n        for (int i = 2; i < 10; ++i) {\n            ans += string(count[i], '0' + i);\n        }\n        return ans == \"\" ? \"1\" : ans;\n    }\n};"
    }
  },
  "2848": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2849": {
    "solution": {
      "math": ""
    }
  },
  "2850": {
    "solution": {
      "matrix": ""
    }
  },
  "2851": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2852": {
    "solution": {
      "union-find": ""
    }
  },
  "2853": {
    "solution": {
      "database": ""
    }
  },
  "2854": {
    "solution": {
      "database": ""
    }
  },
  "2855": {
    "solution": {
      "array": "class Solution {\npublic:\n    int minimumRightShifts(vector<int>& nums) {\n        int count = 0;\n        int pivot = -1;\n\n        for (int i = 0; i + 1 < nums.size(); i++)\n            if (nums[i] > nums[i + 1]) {\n                ++count;\n                pivot = i;\n            }\n\n        if (count == 0)\n            return 0;\n        if (count > 1 || nums.back() > nums.front())\n            return -1;\n        return nums.size() - 1 - pivot;\n    }\n};"
    }
  },
  "2856": {
    "solution": {
      "two-pointers": "class Solution {\n    public int minLengthAfterRemovals(List<Integer> nums) {\n        Map<Integer, Integer> count = new HashMap<>();\n        for (int x : nums) {\n            count.merge(x, 1, Integer::sum);\n        }\n        PriorityQueue<Integer> pq = new PriorityQueue<>(Comparator.reverseOrder());\n        for (int x : count.values()) {\n            pq.offer(x);\n        }\n        int ans = nums.size();\n        while (pq.size() > 1) {\n            int x = pq.poll();\n            int y = pq.poll();\n            x--;\n            y--;\n            if (x > 0) {\n                pq.offer(x);\n            }\n            if (y > 0) {\n                pq.offer(y);\n            }\n            ans -= 2;\n        }\n        return ans;\n    }\n}"
    }
  },
  "2857": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2858": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2859": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2860": {
    "solution": {
      "enumeration": ""
    }
  },
  "2861": {
    "solution": {
      "array": "",
      "binary-search": "#include <vector>\n#include <algorithm>\nusing namespace std;\n\nclass Solution {\npublic:\n    int maxNumberOfAlloys(int n, int k, int budget, vector<vector<int>>& composition, vector<int>& stock, vector<int>& cost) {\n        int left = 0, right = 1e9, result = 0;\n\n        auto canProduce = [&](int x, vector<int>& recipe) -> bool {\n            long long totalCost = 0;\n            for (int i = 0; i < n; ++i) {\n                // Calculate the additional units needed for material i\n                long long required = 1LL * recipe[i] * x;\n                long long needed = max(0LL, required - stock[i]);\n                totalCost += needed * cost[i];\n                if (totalCost > budget) return false; // Exceeds budget\n            }\n            return totalCost <= budget;\n        };\n\n        // Binary search to find the maximum number of alloys\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            bool possible = false;\n\n            // Check all machines to see if producing `mid` alloys is feasible\n            for (int i = 0; i < k; ++i) {\n                if (canProduce(mid, composition[i])) {\n                    possible = true;\n                    break;\n                }\n            }\n\n            if (possible) {\n                result = mid; // Update result to the maximum feasible `mid`\n                left = mid + 1; // Try for a larger number of alloys\n            } else {\n                right = mid - 1; // Try for a smaller number of alloys\n            }\n        }\n\n        return result;\n    }\n};\n"
    }
  },
  "2862": {
    "solution": {
      "number-theory": "class Solution {\n public:\n  long long maximumSum(vector<int>& nums) {\n    long ans = 0;\n\n    for (int oddPower = 1; oddPower <= nums.size(); ++oddPower) {\n      long sum = 0;\n      for (int num = 1; num * num * oddPower <= nums.size(); ++num)\n        sum += nums[oddPower * num * num - 1];\n      ans = max(ans, sum);\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "2863": {
    "solution": {
      "sorting": ""
    }
  },
  "2864": {
    "solution": {
      "greedy": ""
    }
  },
  "2865": {
    "solution": {
      "monotonic-stack": "import java.util.*;\n\nclass Solution {\n    public long maximumSumOfHeights(int[] heights) {\n        int n = heights.length;\n        long[] maxSum = new long[n];\n        Deque<Integer> stack = new ArrayDeque<>(Arrays.asList(-1));\n        long sum = 0;\n\n        for (int i = 0; i < n; ++i) {\n            sum = process(stack, heights, i, sum);\n            maxSum[i] = sum;\n        }\n\n        stack = new ArrayDeque<>(Arrays.asList(n));\n        sum = 0;\n\n        for (int i = n - 1; i >= 0; --i) {\n            sum = process(stack, heights, i, sum);\n            maxSum[i] += sum - heights[i];\n        }\n\n        return Arrays.stream(maxSum).max().getAsLong();\n    }\n\n    private long process(Deque<Integer> stack, int[] heights, int i, long sum) {\n        while (stack.size() > 1 && heights[stack.peek()] > heights[i]) {\n            int j = stack.pop();\n            sum -= Math.abs(j - stack.peek()) * (long) heights[j];\n        }\n        sum += Math.abs(i - stack.peek()) * (long) heights[i];\n        stack.push(i);\n        return sum;\n    }\n}\n"
    }
  },
  "2866": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "2867": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    long long countPaths(int n, vector<vector<int>>& edges) {\n        long ans = 0;\n        const vector<bool> isPrime = sieveEratosthenes(n + 1);\n        vector<vector<int>> graph(n + 1);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n\n        dfs(graph, 1, -1, isPrime, ans);\n        return ans;\n    }\n\nprivate:\n    pair<long, long> dfs(const vector<vector<int>>& graph, int u, int prev,\n                         const vector<bool>& isPrime, long& ans) {\n        long countZeroPrimePath = !isPrime[u];\n        long countOnePrimePath = isPrime[u];\n\n        for (const int v : graph[u]) {\n            if (v == prev)\n                continue;\n            const auto& [countZeroPrimeChildPath, countOnePrimeChildPath] =\n                dfs(graph, v, u, isPrime, ans);\n            ans += countZeroPrimePath * countOnePrimeChildPath +\n                   countOnePrimePath * countZeroPrimeChildPath;\n            if (isPrime[u]) {\n                countOnePrimePath += countZeroPrimeChildPath;\n            } else {\n                countZeroPrimePath += countZeroPrimeChildPath;\n                countOnePrimePath += countOnePrimeChildPath;\n            }\n        }\n\n        return {countZeroPrimePath, countOnePrimePath};\n    }\n\n    vector<bool> sieveEratosthenes(int n) {\n        vector<bool> isPrime(n, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n        for (int i = 2; i * i < n; ++i)\n            if (isPrime[i])\n                for (int j = i * i; j < n; j += i)\n                    isPrime[j] = false;\n        return isPrime;\n    }\n};\n"
    }
  },
  "2868": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2869": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2870": {
    "solution": {
      "counting": ""
    }
  },
  "2871": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2872": {
    "solution": {
      "tree": ""
    }
  },
  "2873": {
    "solution": {
      "array": ""
    }
  },
  "2874": {
    "solution": {
      "array": ""
    }
  },
  "2875": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minSizeSubarray(int[] nums, int target) {\n      long sum = Arrays.stream(nums).asLongStream().sum();\n      int n = nums.length;\n      int remainingTarget = (int) (target % sum);\n      int repeatLength = (int) (target / sum) * n;\n        if (remainingTarget == 0)\n            return repeatLength;\n\n        int suffixPlusPrefixLength = n;\n        long prefix = 0;\n        HashMap<Long, Integer> prefixToIndex = new HashMap<>();\n        prefixToIndex.put(0L, -1);\n\n        for (int i = 0; i < 2 * n; ++i) {\n            prefix += nums[i % n];\n            if (prefixToIndex.containsKey(prefix - remainingTarget))\n                suffixPlusPrefixLength = Math.min(suffixPlusPrefixLength,\n                        i - prefixToIndex.get(prefix - remainingTarget));\n            prefixToIndex.put(prefix, i);\n        }\n\n        return suffixPlusPrefixLength == n ? -1 : repeatLength + suffixPlusPrefixLength;\n    }\n}"
    }
  },
  "2876": {
    "solution": {
      "graph": "class Solution {\n public:\n  vector<int> countVisitedNodes(vector<int>& edges) {\n    const int n = edges.size();\n    vector<int> ans(n);\n    vector<int> inDegrees(n);\n    vector<bool> seen(n);\n    queue<int> q;\n    stack<int> stack;\n\n    for (const int v : edges)\n      ++inDegrees[v];\n\n    // Perform topological sorting.\n    for (int i = 0; i < n; ++i)\n      if (inDegrees[i] == 0)\n        q.push(i);\n\n    // Push non-cyclic nodes to stack.\n    while (!q.empty()) {\n      const int u = q.front();\n      q.pop();\n      if (--inDegrees[edges[u]] == 0)\n        q.push(edges[u]);\n      stack.push(u);\n      seen[u] = true;\n    }\n\n    // Fill the length of cyclic nodes.\n    for (int i = 0; i < n; ++i)\n      if (!seen[i])\n        fillCycle(edges, i, seen, ans);\n\n    // Fill the length of non-cyclic nodes.\n    while (!stack.empty()) {\n      const int u = stack.top();\n      stack.pop();\n      ans[u] = ans[edges[u]] + 1;\n    }\n\n    return ans;\n  }\n\n private:\n  void fillCycle(const vector<int>& edges, int start, vector<bool>& seen,\n                 vector<int>& ans) {\n    int cycleLength = 0;\n    for (int u = start; !seen[u]; u = edges[u]) {\n      ++cycleLength;\n      seen[u] = true;\n    }\n    ans[start] = cycleLength;\n    for (int u = edges[start]; u != start; u = edges[u])\n      ans[u] = cycleLength;\n  }\n};"
    }
  },
  "2892": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2893": {
    "solution": {
      "database": ""
    }
  },
  "2894": {
    "solution": {
      "math": ""
    }
  },
  "2895": {
    "solution": {
      "greedy": ""
    }
  },
  "2896": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2897": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2898": {
    "solution": {
      "hash-table": ""
    }
  },
  "2899": {
    "solution": {
      "array": ""
    }
  },
  "2900": {
    "solution": {
      "dynamic-programming": "#include <vector>\\n#include <string>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<string> getLongestSubsequence(vector<string>& words, vector<int>& groups) {\\n        int n = words.size();\\n        \\n        // DP array to store the longest subsequence ending at each word\\n        vector<int> dp(n, 1);  \\n        vector<int> prev(n, -1);\\n        \\n        for (int i = 1; i < n; ++i) {\\n            for (int j = 0; j < i; ++j) {\\n                if (groups[i] != groups[j] && dp[i] < dp[j] + 1) {\\n                    dp[i] = dp[j] + 1;\\n                    prev[i] = j;\\n                }\\n            }\\n        }\\n        \\n        int maxLength = 0;\\n        int index = -1;\\n        for (int i = 0; i < n; ++i) {\\n            if (dp[i] > maxLength) {\\n                maxLength = dp[i];\\n                index = i;\\n            }\\n        }\\n        \\n        vector<string> result;\\n        while (index != -1) {\\n            result.push_back(words[index]);\\n            index = prev[index];\\n        }\\n        \\n        reverse(result.begin(), result.end());\\n        return result;\\n    }\\n};"
    }
  },
  "2901": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2902": {
    "solution": {
      "sliding-window": "class Solution {\n    public int countSubMultisets(List<Integer> nums, int left, int right) {\n        int kMod = 1_000_000_007;\n        // dp[i] := the number of submultisets of `nums` with sum i\n        long[] dp = new long[right + 1];\n        dp[0] = 1;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int num : nums)\n            count.merge(num, 1, Integer::sum);\n\n        int zeros = count.containsKey(0) ? count.remove(0) : 0;\n\n        for (Map.Entry<Integer, Integer> entry : count.entrySet()) {\n            int num = entry.getKey();\n            int freq = entry.getValue();\n            long[] stride = dp.clone();\n            for (int i = num; i <= right; ++i)\n                stride[i] += stride[i - num];\n            for (int i = right; i > 0; --i)\n                if (i >= num * (freq + 1))\n                    dp[i] = (stride[i] - stride[i - num * (freq + 1)]) % kMod;\n                else\n                    dp[i] = stride[i] % kMod;\n        }\n\n        long ans = 0;\n        for (int i = left; i <= right; ++i)\n            ans = (ans + dp[i]) % kMod;\n        return (int) (((zeros + 1) * ans) % kMod);\n    }\n}"
    }
  },
  "2903": {
    "solution": {
      "two-pointers": "public class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        int n = nums.length;\n        \n        for (int i = 0; i < n; i++) {\n            for (int j = i + indexDifference; j < n; j++) {\n                if (Math.abs(i - j) >= indexDifference && Math.abs(nums[i] - nums[j]) >= valueDifference) {\n                    return new int[]{i, j};\n                }\n            }\n        }\n        \n        return new int[]{-1, -1};\n    }\n}\n"
    }
  },
  "2904": {
    "solution": {
      "sliding-window": "class Solution {\n    public String shortestBeautifulSubstring(String s, int k) {\n        int bestLeft = -1;\n        int minLength = s.length() + 1;\n        int ones = 0;\n\n        for (int left = 0, right = 0; right < s.length(); ++right) {\n            if (s.charAt(right) == '1')\n                ++ones;\n            while (ones == k) {\n                if (right - left + 1 < minLength) {\n                    bestLeft = left;\n                    minLength = right - left + 1;\n                } else if (right - left + 1 == minLength &&\n                        s.substring(left, left + minLength)\n                                .compareTo(s.substring(bestLeft, bestLeft + minLength)) < 0) {\n                    bestLeft = left;\n                }\n                if (s.charAt(left++) == '1')\n                    --ones;\n            }\n        }\n\n        return bestLeft == -1 ? \"\" : s.substring(bestLeft, bestLeft + minLength);\n    }\n}"
    }
  },
  "2905": {
    "solution": {
      "two-pointers": "class Solution {\n    public int[] findIndices(int[] nums, int indexDifference, int valueDifference) {\n        int minIndex = 0;\n        int maxIndex = 0;\n\n        for (int i = indexDifference; i < nums.length; ++i) {\n            if (nums[i - indexDifference] < nums[minIndex])\n                minIndex = i - indexDifference;\n            if (nums[i - indexDifference] > nums[maxIndex])\n                maxIndex = i - indexDifference;\n            if (nums[i] - nums[minIndex] >= valueDifference)\n                return new int[] { i, minIndex };\n            if (nums[maxIndex] - nums[i] >= valueDifference)\n                return new int[] { i, maxIndex };\n        }\n\n        return new int[] { -1, -1 };\n    }\n}"
    }
  },
  "2906": {
    "solution": {
      "matrix": ""
    }
  },
  "2907": {
    "solution": {
      "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n  void maximize(int i, int val) {\n    while (i < vals.size()) {\n      vals[i] = max(vals[i], val);\n      i += lowbit(i);\n    }\n  }\n\n  int get(int i) const {\n    int res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<int> vals;\n\n  static int lowbit(int i) {\n    return i & -i;\n  }\n};\n\nclass Solution {\n public:\n  int maxProfit(vector<int>& prices, vector<int>& profits) {\n    const int maxPrice = ranges::max(prices);\n    int ans = -1;\n    FenwickTree maxProfitTree1(maxPrice);\n    FenwickTree maxProfitTree2(maxPrice);\n\n    for (int i = 0; i < prices.size(); ++i) {\n      const int price = prices[i];\n      const int profit = profits[i];\n      // max(proftis[i])\n      const int maxProfit1 = maxProfitTree1.get(price - 1);\n      // max(proftis[i]) + max(profits[j])\n      const int maxProfit2 = maxProfitTree2.get(price - 1);\n      maxProfitTree1.maximize(price, profit);\n      if (maxProfit1 > 0)\n        maxProfitTree2.maximize(price, profit + maxProfit1);\n      if (maxProfit2 > 0)\n        ans = max(ans, profit + maxProfit2);\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "2908": {
    "solution": {
      "array": ""
    }
  },
  "2909": {
    "solution": {
      "array": ""
    }
  },
  "2910": {
    "solution": {
      "greedy": ""
    }
  },
  "2911": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2912": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2913": {
    "solution": {
      "hash-table": ""
    }
  },
  "2914": {
    "solution": {
      "string": ""
    }
  },
  "2915": {
    "solution": {
      "dynamic-programming": "#include <vector>\\n#include <algorithm>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    int lengthOfLongestSubsequence(vector<int>& nums, int target) {\\n        // DP array, initialize with -1 (meaning not possible)\\n        vector<int> dp(target + 1, -1);\\n        \\n        dp[0] = 0;\\n        \\n        for (int num : nums) {\\n            for (int s = target; s >= num; --s) {\\n                if (dp[s - num] != -1) {  // If sum s-num is achievable\\n                    dp[s] = max(dp[s], dp[s - num] + 1);  // Update the subsequence length for sum s\\n                }\\n            }\\n        }\\n        \\n        return dp[target];\\n    }\\n};"
    }
  },
  "2916": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2917": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    int findKOr(vector<int>& nums, int k) {\n        int ans = 0;\n        for (int i = 0; i < 32; ++i) {\n            int count = 0;\n            for (int x : nums) {\n                count += (x >> i & 1);\n            }\n            if (count >= k) {\n                ans |= 1 << i;\n            }\n        }\n        return ans;\n    }\n};"
    }
  },
  "2918": {
    "solution": {
      "greedy": ""
    }
  },
  "2919": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2920": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2921": {
    "solution": {
      "array": ""
    }
  },
  "2922": {
    "solution": {
      "database": ""
    }
  },
  "2923": {
    "solution": {
      "matrix": "class Solution {\n    public int findChampion(int[][] grid) {\n        int n = grid.length;\n        int ans = -1;\n        int count = 0;\n        int[] inDegrees = new int[n];\n\n        for (int i = 0; i < n; ++i)\n            for (int j = 0; j < n; ++j) {\n                if (i == j)\n                    continue;\n                if (grid[i][j] == 1)\n                    ++inDegrees[j];\n                else\n                    ++inDegrees[i];\n            }\n\n        for (int i = 0; i < n; ++i)\n            if (inDegrees[i] == 0) {\n                ++count;\n                ans = i;\n            }\n\n        return count > 1 ? -1 : ans;\n    }\n}"
    }
  },
  "2924": {
    "solution": {
      "graph": "#include <vector>\n#include <queue>\nusing namespace std;\n\nclass Solution {\npublic:\n    int findChampion(int n, vector<vector<int>>& edges) {\n        vector<int> inDegree(n, 0);  \n        vector<vector<int>> graph(n); \n        \n        for (const auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            graph[u].push_back(v);\n            inDegree[v]++; \n        }\n        \n        int candidate = -1;\n        for (int i = 0; i < n; ++i) {\n            if (inDegree[i] == 0) {\n                if (candidate == -1) {\n                    candidate = i;\n                } else {\n                    return -1;\n                }\n            }\n        }\n        \n        vector<bool> visited(n, false);\n        dfs(graph, candidate, visited);\n        \n        for (int i = 0; i < n; ++i) {\n            if (!visited[i]) {\n                return -1; \n            }\n        }\n        \n        return candidate; \n    }\n    \nprivate:\n    void dfs(const vector<vector<int>>& graph, int node, vector<bool>& visited) {\n        visited[node] = true;\n        for (int neighbor : graph[node]) {\n            if (!visited[neighbor]) {\n                dfs(graph, neighbor, visited);\n            }\n        }\n    }\n};\n"
    }
  },
  "2925": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2926": {
    "solution": {
      "binary-indexed-tree": "class FenwickTree {\n public:\n  FenwickTree(int n) : vals(n + 1) {}\n\n    void maximize(int i, long val) {\n        while (i < vals.size()) {\n            vals[i] = max(vals[i], val);\n            i += lowbit(i);\n        }\n    }\n\n  long get(int i) const {\n    long res = 0;\n    while (i > 0) {\n      res = max(res, vals[i]);\n      i -= lowbit(i);\n    }\n    return res;\n  }\n\n private:\n  vector<long> vals;\n\n    static int lowbit(int i) {\n        return i & -i;\n    }\n};\n\nclass Solution {\n public:\n  long long maxBalancedSubsequenceSum(vector<int>& nums) {\n    long ans = LONG_MIN;\n\n    FenwickTree tree(nums.size());\n\n    for (const auto& [_, i] : getPairs(nums)) {\n      const long subseqSum = tree.get(i) + nums[i];\n      tree.maximize(i + 1, subseqSum);\n      ans = max(ans, subseqSum);\n    }\n\n    return ans;\n  }\n\n private:\n  vector<pair<int, int>> getPairs(const vector<int>& nums) {\n    vector<pair<int, int>> pairs;\n    for (int i = 0; i < nums.size(); ++i)\n      pairs.emplace_back(nums[i] - i, i);\n    ranges::sort(pairs);\n    return pairs;\n  }\n}\n;"
    }
  },
  "2927": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2928": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2929": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2930": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2931": {
    "solution": {
      "matrix": ""
    }
  },
  "2932": {
    "solution": {
      "sliding-window": "class TrieNode {\n    public TrieNode[] children = new TrieNode[2];\n    public int min = Integer.MAX_VALUE;\n    public int max = Integer.MIN_VALUE;\n}\n\nclass BitTrie {\n    public BitTrie(int maxBit) {\n        this.maxBit = maxBit;\n    }\n\n    public void insert(int num) {\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (num >> i & 1);\n            if (node.children[bit] == null)\n                node.children[bit] = new TrieNode();\n            node = node.children[bit];\n            node.min = Math.min(node.min, num);\n            node.max = Math.max(node.max, num);\n        }\n    }\n\n    public int getMaxXor(int x) {\n        int maxXor = 0;\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (x >> i & 1);\n            int toggleBit = bit ^ 1;\n            if (node.children[toggleBit] != null && node.children[toggleBit].max > x &&\n                    node.children[toggleBit].min <= 2 * x) {\n                maxXor = maxXor | 1 << i;\n                node = node.children[toggleBit];\n            } else if (node.children[bit] != null) {\n                node = node.children[bit];\n            } else {\n                return 0;\n            }\n        }\n        return maxXor;\n    }\n\n    private int maxBit;\n    private TrieNode root = new TrieNode();\n}\n\nclass Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n        int ans = 0;\n        BitTrie bitTrie = new BitTrie(maxBit);\n\n        for (int num : nums)\n            bitTrie.insert(num);\n\n        for (int num : nums)\n            ans = Math.max(ans, bitTrie.getMaxXor(num));\n\n        return ans;\n    }\n}"
    }
  },
  "2933": {
    "solution": {
      "sorting": ""
    }
  },
  "2934": {
    "solution": {
      "enumeration": ""
    }
  },
  "2935": {
    "solution": {
      "sliding-window": "class TrieNode {\n    public TrieNode[] children = new TrieNode[2];\n    public int min = Integer.MAX_VALUE;\n    public int max = Integer.MIN_VALUE;\n}\n\nclass BitTrie {\n    public BitTrie(int maxBit) {\n        this.maxBit = maxBit;\n    }\n\n    public void insert(int num) {\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (num >> i & 1);\n            if (node.children[bit] == null)\n                node.children[bit] = new TrieNode();\n            node = node.children[bit];\n            node.min = Math.min(node.min, num);\n            node.max = Math.max(node.max, num);\n        }\n    }\n\n    public int getMaxXor(int x) {\n        int maxXor = 0;\n        TrieNode node = root;\n        for (int i = maxBit; i >= 0; --i) {\n            int bit = (int) (x >> i & 1);\n            int toggleBit = bit ^ 1;\n            if (node.children[toggleBit] != null && node.children[toggleBit].max > x &&\n                    node.children[toggleBit].min <= 2 * x) {\n                maxXor = maxXor | 1 << i;\n                node = node.children[toggleBit];\n            } else if (node.children[bit] != null) {\n                node = node.children[bit];\n            } else {\n                return 0;\n            }\n        }\n        return maxXor;\n    }\n\n    private int maxBit;\n    private TrieNode root = new TrieNode();\n}\n\nclass Solution {\n    public int maximumStrongPairXor(int[] nums) {\n        int maxNum = Arrays.stream(nums).max().getAsInt();\n        int maxBit = (int) (Math.log(maxNum) / Math.log(2));\n        int ans = 0;\n        BitTrie bitTrie = new BitTrie(maxBit);\n\n        for (int num : nums)\n            bitTrie.insert(num);\n\n        for (int num : nums)\n            ans = Math.max(ans, bitTrie.getMaxXor(num));\n\n        return ans;\n    }\n}"
    }
  },
  "2936": {
    "solution": {
      "interactive": ""
    }
  },
  "2937": {
    "solution": {
      "string": ""
    }
  },
  "2938": {
    "solution": {
      "two-pointers": ""
    }
  },
  "2939": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    int maximumXorProduct(long long a, long long b, int n) {\n        constexpr int kMod = 1'000'000'007;\n        if (n > 0)\n            for (long bit = 1L << (n - 1); bit > 0; bit >>= 1)\n                // Pick a bit if it makes min(a, b) larger.\n                if ((min(a, b) & bit) == 0) {\n                    a ^= bit;\n                    b ^= bit;\n                }\n        return a % kMod * (b % kMod) % kMod;\n    }\n};"
    }
  },
  "2940": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2941": {
    "solution": {
      "number-theory": ""
    }
  },
  "2942": {
    "solution": {
      "string": ""
    }
  },
  "2943": {
    "solution": {
      "sorting": ""
    }
  },
  "2944": {
    "solution": {
      "monotonic-queue": "class Solution {\n    public int minimumCoins(int[] prices) {\n      int n = prices.length;\n        int ans = Integer.MAX_VALUE;\n\n        Deque<Pair<Integer, Integer>> deque = new ArrayDeque<>();\n        deque.offerFirst(new Pair<>(0, n));\n\n        for (int i = n - 1; i >= 0; --i) {\n            while (!deque.isEmpty() && deque.peekFirst().getValue() > (i + 1) * 2)\n                deque.pollFirst();\n            ans = prices[i] + deque.peekFirst().getKey();\n            while (!deque.isEmpty() && deque.peekLast().getKey() >= ans)\n                deque.pollLast();\n            deque.offerLast(new Pair<>(ans, i));\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2945": {
    "solution": {
      "monotonic-queue": "import java.util.Arrays;\n\nclass Solution {\n    public int findMaximumLength(int[] A) {\n        int n = A.length;\n        int[] pre = new int[n + 2], dp = new int[n + 1];\n        long[] acc = new long[n + 1];\n        for (int i = 1; i <= n; i++) {\n            acc[i] = acc[i - 1] + A[i - 1];\n        }\n        for (int i = 0, j = 1; j <= n; j++) {\n            i = Math.max(i, pre[j]);\n            dp[j] = dp[i] + 1;\n            int k = Arrays.binarySearch(acc, 2 * acc[j] - acc[i]);\n            if (k < 0) {\n                k = -k - 1;\n            }\n            pre[k] = j;\n        }\n        return dp[n];\n    }\n}\n"
    }
  },
  "2946": {
    "solution": {
      "matrix": ""
    }
  },
  "2947": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2948": {
    "solution": {
      "union-find": ""
    }
  },
  "2949": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2950": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2951": {
    "solution": {
      "enumeration": ""
    }
  },
  "2952": {
    "solution": {
      "greedy": ""
    }
  },
  "2953": {
    "solution": {
      "sliding-window": "class Solution {\n    public int countCompleteSubstrings(String word, int k) {\n      int uniqueLetters = word.chars().boxed().collect(Collectors.toSet()).size();\n        int ans = 0;\n\n        for (int windowSize = k; windowSize <= k * uniqueLetters && windowSize <= word.length(); windowSize += k) {\n            ans += countCompleteStrings(word, k, windowSize);\n        }\n\n        return ans;\n    }\n\n    private int countCompleteStrings(final String word, int k, int windowSize) {\n        int res = 0;\n        int countLetters = 0;\n        int[] count = new int[26];\n\n        for (int i = 0; i < word.length(); ++i) {\n            ++count[word.charAt(i) - 'a'];\n            ++countLetters;\n            if (i > 0 && Math.abs(word.charAt(i) - word.charAt(i - 1)) > 2) {\n                count = new int[26];\n                ++count[word.charAt(i) - 'a'];\n                countLetters = 1;\n            }\n            if (countLetters == windowSize + 1) {\n                --count[word.charAt(i - windowSize) - 'a'];\n                --countLetters;\n            }\n            if (countLetters == windowSize)\n                res += Arrays.stream(count).allMatch(freq -> freq == 0 || freq == k) ? 1 : 0;\n        }\n\n        return res;\n    }\n}"
    }
  },
  "2954": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2955": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2956": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    vector<int> findIntersectionValues(vector<int>& nums1, vector<int>& nums2) {\n        const unordered_set<int> set1{nums1.begin(), nums1.end()};\n        const unordered_set<int> set2{nums2.begin(), nums2.end()};\n        const int ans1 = ranges::count_if(\n            nums1, [&set2](int num) { return set2.contains(num); });\n        const int ans2 = ranges::count_if(\n            nums2, [&set1](int num) { return set1.contains(num); });\n        return {ans1, ans2};\n    }\n};"
    }
  },
  "2957": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2958": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxSubarrayLength(int[] nums, int k) {\n        int ans = 0;\n        Map<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            count.merge(nums[right], 1, Integer::sum);\n            while (count.get(nums[right]) == k + 1)\n                count.merge(nums[left++], -1, Integer::sum);\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2959": {
    "solution": {
      "graph": "class Solution {\npublic:\n    int numberOfSets(int n, int maxDistance, vector<vector<int>>& roads) {\n        const int maxMask = 1 << n;\n        int ans = 0;\n\n        for (int mask = 0; mask < maxMask; ++mask)\n            if (floydWarshall(n, maxDistance, roads, mask) <= maxDistance)\n                ++ans;\n\n        return ans;\n    }\n\nprivate:\n    int floydWarshall(int n, int maxDistanceThreshold,\n                      vector<vector<int>>& roads, int mask) {\n        int maxDistance = 0;\n        vector<vector<int>> dist(n, vector<int>(n, maxDistanceThreshold + 1));\n\n        for (int i = 0; i < n; ++i)\n            if (mask >> i & 1)\n                dist[i][i] = 0;\n\n        for (const vector<int>& road : roads) {\n            const int u = road[0];\n            const int v = road[1];\n            const int w = road[2];\n            if (mask >> u & 1 && mask >> v & 1) {\n                dist[u][v] = min(dist[u][v], w);\n                dist[v][u] = min(dist[v][u], w);\n            }\n        }\n\n        for (int k = 0; k < n; ++k)\n            if (mask >> k & 1)\n                for (int i = 0; i < n; ++i)\n                    if (mask >> i & 1)\n                        for (int j = 0; j < n; ++j)\n                            if (mask >> j & 1)\n                                dist[i][j] =\n                                    min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        for (int i = 0; i < n; ++i)\n            if (mask >> i & 1)\n                for (int j = i + 1; j < n; ++j)\n                    if (mask >> j & 1)\n                        maxDistance = max(maxDistance, dist[i][j]);\n\n        return maxDistance;\n    }\n};"
    }
  },
  "2960": {
    "solution": {
      "array": ""
    }
  },
  "2961": {
    "solution": {
      "math": ""
    }
  },
  "2962": {
    "solution": {
      "sliding-window": "class Solution {\n    public long countSubarrays(int[] nums, int k) {\n      int maxNum = Arrays.stream(nums).max().getAsInt();\n        long ans = 0;\n        int count = 0;\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            if (nums[right] == maxNum)\n                ++count;\n            while (count == k)\n                if (nums[left++] == maxNum)\n                    --count;\n            ans += left;\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2963": {
    "solution": {
      "combinatorics": ""
    }
  },
  "2964": {
    "solution": {
      "hash-table": ""
    }
  },
  "2965": {
    "solution": {
      "matrix": "class Solution {\n  public int[] findMissingAndRepeatedValues(int[][] grid) {\n    int n = grid.length;\n    int nSquared = n * n;\n    int[] count = new int[nSquared + 1];\n\n    for (int[] row : grid)\n      for (final int num : row)\n        ++count[num];\n\n    int repeated = -1;\n    int missing = -1;\n\n    for (int i = 1; i <= nSquared; ++i) {\n      if (count[i] == 2)\n        repeated = i;\n      if (count[i] == 0)\n        missing = i;\n    }\n\n    return new int[] {repeated, missing};\n  }\n}"
    }
  },
  "2966": {
    "solution": {
      "greedy": ""
    }
  },
  "2967": {
    "solution": {
      "greedy": ""
    }
  },
  "2968": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maxFrequencyScore(int[] nums, long k) {\n        int ans = 0;\n        long cost = 0;\n\n        Arrays.sort(nums);\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            cost += nums[right] - nums[(left + right) / 2];\n            while (cost > k)\n                cost -= nums[(left + right + 1) / 2] - nums[left++];\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "2969": {
    "solution": {
      "monotonic-queue": "class Solution {\n    public int minimumCoins(int[] prices) {\n        int n = prices.length;\n        Deque<Integer> q = new ArrayDeque<>();\n        for (int i = n; i > 0; --i) {\n            while (!q.isEmpty() && q.peek() > i * 2 + 1) {\n                q.poll();\n            }\n            if (i <= (n - 1) / 2) {\n                prices[i - 1] += prices[q.peek() - 1];\n            }\n            while (!q.isEmpty() && prices[q.peekLast() - 1] >= prices[i - 1]) {\n                q.pollLast();\n            }\n            q.offer(i);\n        }\n        return prices[0];\n    }\n}"
    }
  },
  "2970": {
    "solution": {
      "two-pointers": "class Solution {\n    public int incremovableSubarrayCount(int[] nums) {\n        int n = nums.length;\n        int count = 0;\n        \n        for (int start = 0; start < n; start++) {\n            for (int end = start + 1; end <= n; end++) {\n                if (isIncremovable(nums, start, end)) {\n                    count++;\n                }\n            }\n        }\n        \n        return count;\n    }\n    \n    private boolean isIncremovable(int[] nums, int start, int end) {\n        List<Integer> remaining = new ArrayList<>();\n        \n        for (int i = 0; i < nums.length; i++) {\n            if (i < start || i >= end) {\n                remaining.add(nums[i]);\n            }\n        }\n        \n        for (int i = 1; i < remaining.size(); i++) {\n            if (remaining.get(i) <= remaining.get(i - 1)) {\n                return false;\n            }\n        }\n        \n        return true;\n    }\n}\n"
    }
  },
  "2971": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2972": {
    "solution": {
      "two-pointers": "class Solution {\n    public long incremovableSubarrayCount(int[] nums) {\n        int n = nums.length;\n        int startIndex = getStartIndexOfSuffix(nums);\n        if (startIndex == 0)\n            return (long) n * (n + 1) / 2;\n\n        long ans = n - startIndex + 1;\n\n        for (int i = 0, j = startIndex; i < startIndex; ++i) {\n            if (i > 0 && nums[i] <= nums[i - 1])\n                break;\n            while (j < n && nums[i] >= nums[j])\n                ++j;\n            ans += n - j + 1;\n        }\n\n        return ans;\n    }\n\n    private int getStartIndexOfSuffix(int[] nums) {\n        for (int i = nums.length - 2; i >= 0; --i)\n            if (nums[i] >= nums[i + 1])\n                return i + 1;\n        return 0;\n    }\n\n    private int firstGreater(int[] A, int startIndex, int target) {\n        int i = Arrays.binarySearch(A, startIndex, A.length, target + 1);\n        return i < 0 ? -i - 1 : i;\n    }\n}"
    }
  },
  "2973": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2974": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "2975": {
    "solution": {
      "enumeration": ""
    }
  },
  "2976": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    long long minimumCost(string source, string target, vector<char>& original,\n                          vector<char>& changed, vector<int>& cost) {\n        long ans = 0;\n        // dist[u][v] := the minimum distance to change ('a' + u) to ('a' + v)\n        vector<vector<long>> dist(26, vector<long>(26, LONG_MAX));\n\n        for (int i = 0; i < cost.size(); ++i) {\n            const int u = original[i] - 'a';\n            const int v = changed[i] - 'a';\n            dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n        }\n\n        for (int k = 0; k < 26; ++k)\n            for (int i = 0; i < 26; ++i)\n                if (dist[i][k] < LONG_MAX)\n                    for (int j = 0; j < 26; ++j)\n                        if (dist[k][j] < LONG_MAX)\n                            dist[i][j] =\n                                min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        for (int i = 0; i < source.length(); ++i) {\n            if (source[i] == target[i])\n                continue;\n            const int u = source[i] - 'a';\n            const int v = target[i] - 'a';\n            if (dist[u][v] == LONG_MAX)\n                return -1;\n            ans += dist[u][v];\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "2977": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    long long minimumCost(string source, string target,\n                          vector<string>& original, vector<string>& changed,\n                          vector<int>& cost) {\n        const unordered_set<int> subLengths = getSubLengths(original);\n        const unordered_map<string, int> subToId =\n            getSubToId(original, changed);\n        const int subCount = subToId.size();\n        // dist[u][v] := the minimum distance to change the substring with id u\n        // to the substring with id v\n        vector<vector<long>> dist(subCount, vector<long>(subCount, LONG_MAX));\n        // dp[i] := the minimum cost to change the first i letters of `source`\n        // into `target`, leaving the suffix untouched\n        vector<long> dp(source.length() + 1, LONG_MAX);\n\n        for (int i = 0; i < cost.size(); ++i) {\n            const int u = subToId.at(original[i]);\n            const int v = subToId.at(changed[i]);\n            dist[u][v] = min(dist[u][v], static_cast<long>(cost[i]));\n        }\n\n        for (int k = 0; k < subCount; ++k)\n            for (int i = 0; i < subCount; ++i)\n                if (dist[i][k] < LONG_MAX)\n                    for (int j = 0; j < subCount; ++j)\n                        if (dist[k][j] < LONG_MAX)\n                            dist[i][j] =\n                                min(dist[i][j], dist[i][k] + dist[k][j]);\n\n        dp[0] = 0;\n\n        for (int i = 0; i < source.length(); ++i) {\n            if (dp[i] == LONG_MAX)\n                continue;\n            if (target[i] == source[i])\n                dp[i + 1] = min(dp[i + 1], dp[i]);\n            for (const int subLength : subLengths) {\n                if (i + subLength > source.length())\n                    continue;\n                const string subSource = source.substr(i, subLength);\n                const string subTarget = target.substr(i, subLength);\n                if (!subToId.contains(subSource) ||\n                    !subToId.contains(subTarget))\n                    continue;\n                const int u = subToId.at(subSource);\n                const int v = subToId.at(subTarget);\n                if (dist[u][v] < LONG_MAX)\n                    dp[i + subLength] =\n                        min(dp[i + subLength], dp[i] + dist[u][v]);\n            }\n        }\n\n        return dp[source.length()] == LONG_MAX ? -1 : dp[source.length()];\n    }\n\nprivate:\n    unordered_map<string, int> getSubToId(const vector<string>& original,\n                                          const vector<string>& changed) {\n        unordered_map<string, int> subToId;\n        for (const string& s : original)\n            if (!subToId.contains(s))\n                subToId[s] = subToId.size();\n        for (const string& s : changed)\n            if (!subToId.contains(s))\n                subToId[s] = subToId.size();\n        return subToId;\n    }\n\n    unordered_set<int> getSubLengths(const vector<string>& original) {\n        unordered_set<int> subLengths;\n        for (const string& s : original)\n            subLengths.insert(s.length());\n        return subLengths;\n    }\n};"
    }
  },
  "2978": {
    "solution": {
      "database": ""
    }
  },
  "2979": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2980": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2981": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximumLength(String s) {\n        int n = s.length();\n        int ans = -1;\n        int runningLen = 0;\n        char prevLetter = '@';\n        int[][] counts = new int[26][n + 1];\n\n        for (final char c : s.toCharArray())\n            if (c == prevLetter) {\n                ++counts[c - 'a'][++runningLen];\n            } else {\n                runningLen = 1;\n                ++counts[c - 'a'][runningLen];\n                prevLetter = c;\n            }\n\n        for (int[] count : counts) {\n            ans = Math.max(ans, getMaxFreq(count, n));\n        }\n\n        return ans;\n    }\n\n    private int getMaxFreq(int[] count, int maxFreq) {\n        int times = 0;\n        for (int freq = maxFreq; freq >= 1; --freq) {\n            times += count[freq];\n            if (times >= 3)\n                return freq;\n        }\n        return -1;\n    }\n}"
    }
  },
  "2982": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximumLength(String s) {\n        int n = s.length();\n        int ans = -1;\n        int runningLen = 0;\n        char prevLetter = '@';\n        int[][] counts = new int[26][n + 1];\n\n        for (final char c : s.toCharArray())\n            if (c == prevLetter) {\n                ++counts[c - 'a'][++runningLen];\n            } else {\n                runningLen = 1;\n                ++counts[c - 'a'][runningLen];\n                prevLetter = c;\n            }\n\n        for (int[] count : counts) {\n            ans = Math.max(ans, getMaxFreq(count, n));\n        }\n\n        return ans;\n    }\n\n    private int getMaxFreq(int[] count, int maxFreq) {\n        int times = 0;\n        for (int freq = maxFreq; freq >= 1; --freq) {\n            times += count[freq];\n            if (times >= 3)\n                return freq;\n        }\n        return -1;\n    }\n}"
    }
  },
  "2983": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "2984": {
    "solution": {
      "database": ""
    }
  },
  "2985": {
    "solution": {
      "database": ""
    }
  },
  "2986": {
    "solution": {
      "database": ""
    }
  },
  "2987": {
    "solution": {
      "database": ""
    }
  },
  "2988": {
    "solution": {
      "database": ""
    }
  },
  "2989": {
    "solution": {
      "database": ""
    }
  },
  "2990": {
    "solution": {
      "database": ""
    }
  },
  "2991": {
    "solution": {
      "database": "WITH\n    T AS (\n        SELECT\n            country,\n            CONCAT(winery, ' (', points, ')') AS winery,\n            RANK() OVER (\n                PARTITION BY country\n                ORDER BY points DESC, winery\n            ) AS rk\n        FROM (SELECT country, SUM(points) AS points, winery FROM Wineries GROUP BY 1, 3) AS t\n    )\nSELECT\n    t1.country,\n    t1.winery AS top_winery,\n    IFNULL(t2.winery, 'No second winery') AS second_winery,\n    IFNULL(t3.winery, 'No third winery') AS third_winery\nFROM\n    T AS t1\n    LEFT JOIN T AS t2 ON t1.country = t2.country AND t1.rk = t2.rk - 1\n    LEFT JOIN T AS t3 ON t2.country = t3.country AND t2.rk = t3.rk - 1\nWHERE t1.rk = 1\nORDER BY 1;\n"
    }
  },
  "2992": {
    "solution": {
      "bitmask": "class Solution {\n    private int n;\n    private Integer[] f;\n\n    public int selfDivisiblePermutationCount(int n) {\n        this.n = n;\n        f = new Integer[1 << (n + 1)];\n        return dfs(0);\n    }\n\n    private int dfs(int mask) {\n        if (f[mask] != null) {\n            return f[mask];\n        }\n        int i = Integer.bitCount(mask) + 1;\n        if (i > n) {\n            return 1;\n        }\n        f[mask] = 0;\n        for (int j = 1; j <= n; ++j) {\n            if ((mask >> j & 1) == 0 && (i % j == 0 || j % i == 0)) {\n                f[mask] += dfs(mask | 1 << j);\n            }\n        }\n        return f[mask];\n    }\n}"
    }
  },
  "2993": {
    "solution": {
      "database": ""
    }
  },
  "2994": {
    "solution": {
      "database": ""
    }
  },
  "2995": {
    "solution": {
      "database": ""
    }
  },
  "2996": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    int missingInteger(vector<int>& nums) {\n        const unordered_set<int> numsSet{nums.begin(), nums.end()};\n        int ans = nums[0];\n\n        for (int i = 1; i < nums.size(); ++i) {\n            if (nums[i] != nums[i - 1] + 1)\n                break;\n            ans += nums[i];\n        }\n\n        while (numsSet.contains(ans))\n            ++ans;\n\n        return ans;\n    }\n};"
    }
  },
  "2997": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "2998": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "2999": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3000": {
    "solution": {
      "array": ""
    }
  },
  "3001": {
    "solution": {
      "enumeration": ""
    }
  },
  "3002": {
    "solution": {
      "greedy": ""
    }
  },
  "3003": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3004": {
    "solution": {
      "depth-first-search": "class Solution {\npublic:\n    int maximumSubtreeSize(vector<vector<int>>& edges, vector<int>& colors) {\n        int nodeCount = edges.size() + 1;\n        vector<int> adjacencyList[nodeCount];\n        vector<int> subtreeSize(nodeCount, 1);\n        \n        for (auto& edge : edges) {\n            int u = edge[0], v = edge[1];\n            adjacencyList[u].push_back(v);\n            adjacencyList[v].push_back(u);\n        }\n\n        int maxSubtreeSize = 0;\n        \n        function<bool(int, int)> dfs = [&](int currentNode, int parentNode) {\n            bool isValid = true;\n            for (int neighbor : adjacencyList[currentNode]) {\n                if (neighbor != parentNode) {\n                    bool validChild = dfs(neighbor, currentNode);\n                    isValid = isValid && colors[currentNode] == colors[neighbor] && validChild;\n                    subtreeSize[currentNode] += subtreeSize[neighbor];\n                }\n            }\n            if (isValid) {\n                maxSubtreeSize = max(maxSubtreeSize, subtreeSize[currentNode]);\n            }\n            return isValid;\n        };\n        \n        dfs(0, -1);\n        return maxSubtreeSize;\n    }\n};\n"
    }
  },
  "3005": {
    "solution": {
      "counting": ""
    }
  },
  "3006": {
    "solution": {
      "two-pointers": ""
    }
  },
  "3007": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3008": {
    "solution": {
      "two-pointers": ""
    }
  },
  "3009": {
    "solution": {
      "geometry": ""
    }
  },
  "3010": {
    "solution": {
      "enumeration": ""
    }
  },
  "3011": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    bool canSortArray(vector<int>& nums) {\n        int prevSetBits = 0;\n        int prevMax = INT_MIN;\n        int currMax = INT_MIN;\n        int currMin = INT_MAX;\n\n        for (const int num : nums) {\n            const int setBits = __builtin_popcount(num);\n            if (setBits != prevSetBits) {\n                if (prevMax > currMin)\n                    return false;\n                prevSetBits = setBits;\n                prevMax = currMax;\n                currMax = num;\n                currMin = num;\n            } else {\n                currMax = max(currMax, num);\n                currMin = min(currMin, num);\n            }\n        }\n\n        return prevMax <= currMin;\n    }\n};"
    }
  },
  "3012": {
    "solution": {
      "number-theory": "class Solution {\npublic:\n    int minimumArrayLength(vector<int>& nums) {\n        // Let the minimum number in the array `nums` be x.\n        // * If there exists any element nums[i] where nums[i] % x > 0, a new\n        //   minimum can be generated and all other numbers can be removed.\n        // * If not, count the frequency of x in `nums`. For each pair of x, a 0\n        // is\n        //   generated which cannot be removed. Therefore, the result will be\n        //   (frequency of x + 1) / 2.\n        const int minNum = ranges::min(nums);\n        if (ranges::any_of(nums,\n                           [minNum](int num) { return num % minNum > 0; }))\n            return 1;\n        return (ranges::count(nums, minNum) + 1) / 2;\n    }\n};"
    }
  },
  "3013": {
    "solution": {
      "sliding-window": "class Multiset {\n    public void add(int num) {\n        map.merge(num, 1, Integer::sum);\n        ++sz;\n    }\n\n    public void remove(int num) {\n        map.merge(num, -1, Integer::sum);\n        if (map.get(num) == 0)\n            map.remove(num);\n        --sz;\n    }\n\n    public int min() {\n        return map.firstEntry().getKey();\n    }\n\n    public int max() {\n        return map.lastEntry().getKey();\n    }\n\n    public int size() {\n        return sz;\n    }\n\n    public boolean contains(int num) {\n        return map.containsKey(num);\n    }\n\n    private TreeMap<Integer, Integer> map = new TreeMap<>();\n    private int sz = 0;\n}\n\nclass Solution {\n    public long minimumCost(int[] nums, int k, int dist) {\n        long windowSum = 0;\n        Multiset selected = new Multiset();\n        Multiset candidates = new Multiset();\n\n        for (int i = 1; i <= dist + 1; ++i) {\n            windowSum += nums[i];\n            selected.add(nums[i]);\n        }\n\n        windowSum = balance(windowSum, selected, candidates, k);\n        long minWindowSum = windowSum;\n\n        for (int i = dist + 2; i < nums.length; ++i) {\n          int outOfScope = nums[i - dist - 1];\n            if (selected.contains(outOfScope)) {\n                windowSum -= outOfScope;\n                selected.remove(outOfScope);\n            } else {\n                candidates.remove(outOfScope);\n            }\n            if (nums[i] < selected.max()) {\n                windowSum += nums[i];\n                selected.add(nums[i]);\n            } else {\n                candidates.add(nums[i]);\n            }\n            windowSum = balance(windowSum, selected, candidates, k);\n            minWindowSum = Math.min(minWindowSum, windowSum);\n        }\n\n        return nums[0] + minWindowSum;\n    }\n\n    private long balance(long windowSum, Multiset selected, Multiset candidates, int k) {\n        while (selected.size() < k - 1) {\n          int minCandidate = candidates.min();\n            windowSum += minCandidate;\n            selected.add(minCandidate);\n            candidates.remove(minCandidate);\n        }\n        while (selected.size() > k - 1) {\n          int maxSelected = selected.max();\n            windowSum -= maxSelected;\n            selected.remove(maxSelected);\n            candidates.add(maxSelected);\n        }\n        return windowSum;\n    }\n}"
    }
  },
  "3014": {
    "solution": {
      "greedy": ""
    }
  },
  "3015": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3016": {
    "solution": {
      "counting": ""
    }
  },
  "3017": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3018": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3019": {
    "solution": {
      "string": ""
    }
  },
  "3020": {
    "solution": {
      "enumeration": ""
    }
  },
  "3021": {
    "solution": {
      "math": ""
    }
  },
  "3022": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3023": {
    "solution": {
      "sliding-window": "**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *     public InfiniteStream(int[] bits);\n *     public int next();\n * }\n */\nclass Solution {\n    public int findPattern(InfiniteStream infiniteStream, int[] pattern) {\n        long a = 0, b = 0;\n        int m = pattern.length;\n        int half = m >> 1;\n        long mask1 = (1L << half) - 1;\n        long mask2 = (1L << (m - half)) - 1;\n        for (int i = 0; i < half; ++i) {\n            a |= (long) pattern[i] << (half - 1 - i);\n        }\n        for (int i = half; i < m; ++i) {\n            b |= (long) pattern[i] << (m - 1 - i);\n        }\n        long x = 0, y = 0;\n        for (int i = 1;; ++i) {\n            int v = infiniteStream.next();\n            y = y << 1 | v;\n            v = (int) ((y >> (m - half)) & 1);\n            y &= mask2;\n            x = x << 1 | v;\n            x &= mask1;\n            if (i >= m && a == x && b == y) {\n                return i - m;\n            }\n        }\n    }\n}"
    }
  },
  "3024": {
    "solution": {
      "sorting": "class Solution {\n public:\n  string triangleType(vector<int>& nums) {\n    ranges::sort(nums);\n    if (nums[0] + nums[1] <= nums[2])\n      return \"none\";\n    if (nums[0] == nums[1] && nums[1] == nums[2])\n      return \"equilateral\";\n    if (nums[0] == nums[1] || nums[1] == nums[2])\n      return \"isosceles\";\n    return \"scalene\";\n  }\n};"
    }
  },
  "3025": {
    "solution": {
      "geometry": "class Solution {\n public:\n  int numberOfPairs(vector<vector<int>>& points) {\n    int ans = 0;\n\n    ranges::sort(points, [](const vector<int>& a, const vector<int>& b) {\n      return a[0] < b[0] || (a[0] == b[0] && a[1] > b[1]);\n    });\n\n    for (int i = 0; i < points.size(); ++i) {\n      int maxY = INT_MIN;\n      for (int j = i + 1; j < points.size(); ++j)\n        if (points[i][1] >= points[j][1] && points[j][1] > maxY) {\n          ++ans;\n          maxY = points[j][1];\n        }\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "3026": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3027": {
    "solution": {
      "geometry": ""
    }
  },
  "3028": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3029": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "3030": {
    "solution": {
      "matrix": ""
    }
  },
  "3031": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "3032": {
    "solution": {
      "hash-table": "class Solution {\n public:\n  int numberCount(int a, int b) {\n    int ans = 0;\n    for (int num = a; num <= b; ++num)\n      if (isUniqueDigits(num))\n        ++ans;\n    return ans;\n  }\n\n private:\n  bool isUniqueDigits(int num) {\n    vector<bool> seen(10);\n    while (num > 0) {\n      const int digit = num % 10;\n      if (seen[digit])\n        return false;\n      seen[digit] = true;\n      num /= 10;\n    }\n    return true;\n  }\n};"
    }
  },
  "3033": {
    "solution": {
      "matrix": ""
    }
  },
  "3034": {
    "solution": {
      "rolling-hash": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        const vector<int> numsPattern = getNumsPattern(nums);\n        return kmp(numsPattern, pattern);\n    }\n\nprivate:\n    int getNum(int a, int b) {\n        if (a < b)\n            return 1;\n        if (a > b)\n            return -1;\n        return 0;\n    }\n\n    vector<int> getNumsPattern(const vector<int>& nums) {\n        vector<int> numsPattern;\n        for (int i = 1; i < nums.size(); ++i)\n            numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n        return numsPattern;\n    }\n\n    int kmp(const vector<int>& nums, const vector<int>& pattern) {\n        const vector<int> lps = getLPS(pattern);\n        int res = 0;\n        int i = 0; \n        int j = 0; \n        while (i < nums.size()) {\n            if (nums[i] == pattern[j]) {\n                ++i;\n                ++j;\n                if (j == pattern.size()) {\n                    ++res;\n                    j = lps[j - 1];\n                }\n            }\n            else if (j > 0) {\n                j = lps[j - 1];\n            } else {\n                ++i;\n            }\n        }\n        return res;\n    }\n\n    vector<int> getLPS(const vector<int>& pattern) {\n        vector<int> lps(pattern.size());\n        for (int i = 1, j = 0; i < pattern.size(); ++i) {\n            while (j > 0 && pattern[j] != pattern[i])\n                j = lps[j - 1];\n            if (pattern[i] == pattern[j])\n                lps[i] = ++j;\n        }\n        return lps;\n    }\n};"
    }
  },
  "3035": {
    "solution": {
      "counting": ""
    }
  },
  "3036": {
    "solution": {
      "rolling-hash": "class Solution {\npublic:\n    int countMatchingSubarrays(vector<int>& nums, vector<int>& pattern) {\n        const vector<int> numsPattern = getNumsPattern(nums);\n        return kmp(numsPattern, pattern);\n    }\n\nprivate:\n    int getNum(int a, int b) {\n        if (a < b)\n            return 1;\n        if (a > b)\n            return -1;\n        return 0;\n    }\n\n    vector<int> getNumsPattern(const vector<int>& nums) {\n        vector<int> numsPattern;\n        for (int i = 1; i < nums.size(); ++i)\n            numsPattern.push_back(getNum(nums[i - 1], nums[i]));\n        return numsPattern;\n    }\n\n    int kmp(const vector<int>& nums, const vector<int>& pattern) {\n        const vector<int> lps = getLPS(pattern);\n        int res = 0;\n        int i = 0;\n        int j = 0;\n        while (i < nums.size()) {\n            if (nums[i] == pattern[j]) {\n                ++i;\n                ++j;\n                if (j == pattern.size()) {\n                    ++res;\n                    j = lps[j - 1];\n                }\n            } else if (j > 0) {\n                j = lps[j - 1];\n            } else {\n                ++i;\n            }\n        }\n        return res;\n    }\n\n    vector<int> getLPS(const vector<int>& pattern) {\n        vector<int> lps(pattern.size());\n        for (int i = 1, j = 0; i < pattern.size(); ++i) {\n            while (j > 0 && pattern[j] != pattern[i])\n                j = lps[j - 1];\n            if (pattern[i] == pattern[j])\n                lps[i] = ++j;\n        }\n        return lps;\n    }\n};"
    }
  },
  "3037": {
    "solution": {
      "sliding-window": "/**\n * Definition for an infinite stream.\n * class InfiniteStream {\n *   public InfiniteStream(int[] bits);\n *   public int next();\n * }\n */\n\nclass Solution {\n  public int findPattern(InfiniteStream stream, int[] pattern) {\n    int[] lps = getLPS(pattern);\n    int i = 0;  \n    int j = 0;   \n    int bit = 0;\n    boolean readNext = false;\n    while (true) {\n      if (!readNext) {\n        bit = stream.next();\n        readNext = true;\n      }\n      if (bit == pattern[j]) {\n        ++i;\n        readNext = false;\n        ++j;\n        if (j == pattern.length)\n          return i - j;\n      }\n      else if (j > 0) {\n        j = lps[j - 1];\n      } else {\n        ++i;\n        readNext = false;\n      }\n    }\n  }\n\n\n  private int[] getLPS(int[] pattern) {\n    int[] lps = new int[pattern.length];\n    int j = 0;\n    for (int i = 1; i < pattern.length; ++i) {\n      while (j > 0 && pattern[j] != pattern[i])\n        j = lps[j - 1];\n      if (pattern[i] == pattern[j])\n        lps[i] = ++j;\n    }\n    return lps;\n  }\n}"
    }
  },
  "3038": {
    "solution": {
      "array": ""
    }
  },
  "3039": {
    "solution": {
      "counting": ""
    }
  },
  "3040": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3041": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3042": {
    "solution": {
      "trie": "struct TrieNode {\n    unordered_map<int, shared_ptr<TrieNode>> children;\n    int count = 0;\n};\n\nclass Trie {\npublic:\n    int insert(const string& word) {\n        const int n = word.length();\n        int count = 0;\n        shared_ptr<TrieNode> node = root;\n        for (int i = 0; i < n; ++i) {\n            const int j = hash(word[i], word[n - 1 - i]);\n            if (node->children[j] == nullptr)\n                node->children[j] = make_shared<TrieNode>();\n            node = node->children[j];\n            count += node->count;\n        }\n        ++node->count;\n        return count;\n    }\n\nprivate:\n    shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n    static int hash(char prefix, char suffix) {\n        return 26 * (prefix - 'a') + (suffix - 'a');\n    }\n};\n\nclass Solution {\npublic:\n    long long countPrefixSuffixPairs(vector<string>& words) {\n        long ans = 0;\n        Trie trie;\n\n        for (const string& word : words)\n            ans += trie.insert(word);\n\n        return ans;\n    }\n};"
    }
  },
  "3043": {
    "solution": {
      "trie": ""
    }
  },
  "3044": {
    "solution": {
      "matrix": ""
    }
  },
  "3045": {
    "solution": {
      "rolling-hash": ""
    }
  },
  "3046": {
    "solution": {
      "counting": "class Solution {\npublic:\n    bool isPossibleToSplit(vector<int>& nums) {\n        constexpr int kMax = 100;\n        vector<int> count(kMax + 1);\n\n        for (const int num : nums)\n            ++count[num];\n\n        return ranges::all_of(count, [](int freq) { return freq <= 2; });\n    }\n};"
    }
  },
  "3047": {
    "solution": {
      "geometry": "class Solution {\n public:\n  long long largestSquareArea(vector<vector<int>>& bottomLeft,\n                              vector<vector<int>>& topRight) {\n    int minSide = 0;\n\n    for (int i = 0; i < bottomLeft.size(); ++i)\n      for (int j = i + 1; j < bottomLeft.size(); ++j) {\n        const int ax1 = bottomLeft[i][0];\n        const int ay1 = bottomLeft[i][1];\n        const int ax2 = topRight[i][0];\n        const int ay2 = topRight[i][1];\n        const int bx1 = bottomLeft[j][0];\n        const int by1 = bottomLeft[j][1];\n        const int bx2 = topRight[j][0];\n        const int by2 = topRight[j][1];\n        const int overlapX = min(ax2, bx2) - max(ax1, bx1);\n        const int overlapY = min(ay2, by2) - max(ay1, by1);\n        minSide = max(minSide, min(overlapX, overlapY));\n      }\n\n    return static_cast<long>(minSide) * minSide;\n  }\n};"
    }
  },
  "3048": {
    "solution": {
      "array": ""
    }
  },
  "3049": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "3050": {
    "solution": {
      "database": ""
    }
  },
  "3051": {
    "solution": {
      "database": ""
    }
  },
  "3052": {
    "solution": {
      "database": ""
    }
  },
  "3053": {
    "solution": {
      "database": ""
    }
  },
  "3054": {
    "solution": {
      "database": ""
    }
  },
  "3055": {
    "solution": {
      "database": ""
    }
  },
  "3056": {
    "solution": {
      "database": ""
    }
  },
  "3057": {
    "solution": {
      "database": ""
    }
  },
  "3058": {
    "solution": {
      "database": ""
    }
  },
  "3059": {
    "solution": {
      "database": ""
    }
  },
  "3060": {
    "solution": {
      "database": ""
    }
  },
  "3061": {
    "solution": {
      "database": ""
    }
  },
  "3062": {
    "solution": {
      "linked-list": "/**\n * Definition for singly-linked list.\n * struct ListNode {\n *     int val;\n *     ListNode *next;\n *     ListNode() : val(0), next(nullptr) {}\n *     ListNode(int x) : val(x), next(nullptr) {}\n *     ListNode(int x, ListNode *next) : val(x), next(next) {}\n * };\n */\nclass Solution {\npublic:\n    string gameResult(ListNode* head) {\n        int odd = 0, even = 0;\n        for (; head != nullptr; head = head->next->next) {\n            int a = head->val;\n            int b = head->next->val;\n            odd += a < b;\n            even += a > b;\n        }\n        if (odd > even) {\n            return \"Odd\";\n        }\n        if (odd < even) {\n            return \"Even\";\n        }\n        return \"Tie\";\n    }\n};"
    }
  },
  "3063": {
    "solution": {
      "linked-list": ""
    }
  },
  "3064": {
    "solution": {
      "bit-manipulation": "class Solution {\npublic:\n    int findNumber() {\n        int n = 0;\n        for (int i = 0; i < 32; ++i) {\n            if (commonSetBits(1 << i)) {\n                n |= 1 << i;\n            }\n        }\n        return n;\n    }\n};"
    }
  },
  "3065": {
    "solution": {
      "array": "class Solution {\npublic:\n    int minOperations(vector<int>& nums, int k) {\n        return ranges::count_if(nums, [k](int num) { return num < k; });\n    }\n};"
    }
  },
  "3066": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "3067": {
    "solution": {
      "tree": "class Solution {\npublic:\n    vector<int> countPairsOfConnectableServers(vector<vector<int>>& edges,\n                                               int signalSpeed) {\n        const int n = edges.size() + 1;\n        vector<int> ans;\n        vector<vector<pair<int, int>>> tree(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            tree[u].emplace_back(v, w);\n            tree[v].emplace_back(u, w);\n        }\n\n        for (int i = 0; i < n; ++i)\n            ans.push_back(connectablePairsRootedAt(tree, i, signalSpeed));\n\n        return ans;\n    }\n\nprivate:\n    int connectablePairsRootedAt(const vector<vector<pair<int, int>>>& tree,\n                                 int u, int signalSpeed) {\n        int pairs = 0;\n        int count = 0;\n        for (const auto& [v, w] : tree[u]) {\n            const int childCount = dfs(tree, v, u, w, signalSpeed);\n            pairs += count * childCount;\n            count += childCount;\n        }\n        return pairs;\n    }\n\n    int dfs(const vector<vector<pair<int, int>>>& tree, int u, int prev,\n            int dist, int signalSpeed) {\n        int count = 0;\n        for (const auto& [v, w] : tree[u])\n            if (v != prev)\n                count += dfs(tree, v, u, dist + w, signalSpeed);\n        return (dist % signalSpeed == 0 ? 1 : 0) + count;\n    }\n};"
    }
  },
  "3068": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3069": {
    "solution": {
      "array": ""
    }
  },
  "3070": {
    "solution": {
      "matrix": ""
    }
  },
  "3071": {
    "solution": {
      "matrix": ""
    }
  },
  "3072": {
    "solution": {
      "array": ""
    }
  },
  "3073": {
    "solution": {
      "ordered-set": "class Solution {\npublic:\n    int maximumTripletValue(vector<int>& nums) {\n        int n = nums.size();\n        vector<int> right(n, nums.back());\n        for (int i = n - 2; ~i; --i) {\n            right[i] = max(nums[i], right[i + 1]);\n        }\n        set<int> ts;\n        ts.insert(nums[0]);\n        int ans = 0;\n        for (int j = 1; j < n - 1; ++j) {\n            if (right[j + 1] > nums[j]) {\n                auto it = ts.lower_bound(nums[j]);\n                if (it != ts.begin()) {\n                    --it;\n                    ans = max(ans, *it - nums[j] + right[j + 1]);\n                }\n            }\n            ts.insert(nums[j]);\n        }\n        return ans;\n    }\n};"
    }
  },
  "3074": {
    "solution": {
      "greedy": ""
    }
  },
  "3075": {
    "solution": {
      "greedy": ""
    }
  },
  "3076": {
    "solution": {
      "trie": ""
    }
  },
  "3077": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3078": {
    "solution": {
      "matrix": ""
    }
  },
  "3079": {
    "solution": {
      "math": ""
    }
  },
  "3080": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "3081": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "3082": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3083": {
    "solution": {
      "hash-table": ""
    }
  },
  "3084": {
    "solution": {
      "counting": ""
    }
  },
  "3085": {
    "solution": {
      "counting": ""
    }
  },
  "3086": {
    "solution": {
      "sliding-window": "class Solution {\n  public long minimumMoves(int[] nums, int k, int maxChanges) {\n    int kNumOfIndicesWithinOneDistance = 3;\n    long ans = Long.MAX_VALUE;\n    List<Integer> oneIndices = new ArrayList<>(); \n    List<Long> prefix = new ArrayList<>();       \n    prefix.add(0L);\n\n    for (int i = 0; i < nums.length; ++i)\n      if (nums[i] == 1)\n        oneIndices.add(i);\n\n    for (int oneIndex : oneIndices)\n      prefix.add(prefix.get(prefix.size() - 1) + oneIndex);\n\n    int minOnesByTwo = Math.max(0, k - maxChanges);\n    int maxOnesByTwo =\n        Math.min(k, Math.min(minOnesByTwo + kNumOfIndicesWithinOneDistance, oneIndices.size()));\n\n    for (int onesByTwo = minOnesByTwo; onesByTwo <= maxOnesByTwo; ++onesByTwo)\n      for (int left = 0; left + onesByTwo < prefix.size(); ++left) {\n        int right = left + onesByTwo;\n        long cost1 = (k - onesByTwo) * 2;\n        long cost2 = (prefix.get(right) - prefix.get((left + right) / 2)) -\n                           (prefix.get((left + right + 1) / 2) - prefix.get(left));\n        ans = Math.min(ans, cost1 + cost2);\n      }\n\n    return ans;\n  }\n}"
    }
  },
  "3087": {
    "solution": {
      "database": ""
    }
  },
  "3088": {
    "solution": {
      "greedy": ""
    }
  },
  "3089": {
    "solution": {
      "database": ""
    }
  },
  "3090": {
    "solution": {
      "sliding-window": "class Solution {\n    public int maximumLengthSubstring(String s) {\n        int ans = 0;\n        int[] count = new int[26];\n\n        for (int left = 0, right = 0; right < s.length(); ++right) {\n            ++count[s.charAt(right) - 'a'];\n            while (count[s.charAt(right) - 'a'] > 2)\n                --count[s.charAt(left++) - 'a'];\n            ans = Math.max(ans, right - left + 1);\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "3091": {
    "solution": {
      "enumeration": ""
    }
  },
  "3092": {
    "solution": {
      "heap-(priority-queue)": ""
    }
  },
  "3093": {
    "solution": {
      "trie": "struct TrieNode {\n  vector<shared_ptr<TrieNode>> children;\n  TrieNode() : children(26) {}\n  int length = INT_MAX;\n  int index = -1;\n};\n\nclass Solution {\n public:\n  vector<int> stringIndices(vector<string>& wordsContainer,\n                            vector<string>& wordsQuery) {\n    vector<int> ans;\n    int minIndex = 0;\n\n    for (int i = 0; i < wordsContainer.size(); ++i) {\n      insert(wordsContainer[i], i);\n      if (wordsContainer[i].length() < wordsContainer[minIndex].length())\n        minIndex = i;\n    }\n\n    for (const string& query : wordsQuery) {\n      const int index = search(query);\n      ans.push_back(index == -1 ? minIndex : index);\n    }\n\n    return ans;\n  }\n\n private:\n  shared_ptr<TrieNode> root = make_shared<TrieNode>();\n\n  void insert(const string& word, int index) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int j = word[i] - 'a';\n      if (node->children[j] == nullptr)\n        node->children[j] = make_shared<TrieNode>();\n      node = node->children[j];\n      if (node->length > word.length()) {\n        node->length = word.length();\n        node->index = index;\n      }\n    }\n  }\n\n  int search(const string& word) {\n    shared_ptr<TrieNode> node = root;\n    for (int i = word.length() - 1; i >= 0; --i) {\n      const int j = word[i] - 'a';\n      if (node->children[j] == nullptr)\n        return node->index;\n      node = node->children[j];\n    }\n    return node->index;\n  }\n};"
    }
  },
  "3094": {
    "solution": {
      "bit-manipulation": "/**\n * Definition of commonBits API.\n * int commonBits(int num);\n */\n\nclass Solution {\npublic:\n    int findNumber() {\n        int n = 0;\n        for (int i = 0; i < 32; ++i) {\n            int count1 = commonBits(1 << i);\n            int count2 = commonBits(1 << i);\n            if (count1 > count2) {\n                n |= 1 << i;\n            }\n        }\n        return n;\n    }\n};"
    }
  },
  "3095": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int kMax = 50;\n        int n = nums.length;\n        int ans = n + 1;\n        int ors = 0;\n        int[] count = new int[kMax + 1];\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            ors = orNum(ors, nums[right], count);\n            while (ors >= k && left <= right) {\n                ans = Math.min(ans, right - left + 1);\n                ors = undoOrNum(ors, nums[left], count);\n                ++left;\n            }\n        }\n\n        return (ans == n + 1) ? -1 : ans;\n    }\n\n    private static final int kMaxBit = 30;\n\n    private int orNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && ++count[i] == 1)\n                ors += 1 << i;\n        return ors;\n    }\n\n    private int undoOrNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && --count[i] == 0)\n                ors -= 1 << i;\n        return ors;\n    }\n}"
    }
  },
  "3096": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3097": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minimumSubarrayLength(int[] nums, int k) {\n        int kMax = 50;\n        int n = nums.length;\n        int ans = n + 1;\n        int ors = 0;\n        int[] count = new int[kMax + 1];\n\n        for (int left = 0, right = 0; right < n; ++right) {\n            ors = orNum(ors, nums[right], count);\n            while (ors >= k && left <= right) {\n                ans = Math.min(ans, right - left + 1);\n                ors = undoOrNum(ors, nums[left], count);\n                ++left;\n            }\n        }\n\n        return (ans == n + 1) ? -1 : ans;\n    }\n\n    private static final int kMaxBit = 30;\n\n    private int orNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && ++count[i] == 1)\n                ors += 1 << i;\n        return ors;\n    }\n\n    private int undoOrNum(int ors, int num, int[] count) {\n        for (int i = 0; i < kMaxBit; ++i)\n            if ((num >> i & 1) == 1 && --count[i] == 0)\n                ors -= 1 << i;\n        return ors;\n    }\n}"
    }
  },
  "3098": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3099": {
    "solution": {
      "math": "class Solution {\npublic:\n    int sumOfTheDigitsOfHarshadNumber(int x) {\n        const int digitSum = getDigitSum(x);\n        return x % digitSum == 0 ? digitSum : -1;\n    }\n\nprivate:\n    int getDigitSum(int x) {\n        int digitSum = 0;\n        while (x > 0) {\n            digitSum += x % 10;\n            x /= 10;\n        }\n        return digitSum;\n    }\n};\n"
    }
  },
  "3100": {
    "solution": {
      "math": ""
    }
  },
  "3101": {
    "solution": {
      "math": "class Solution {\npublic:\n    long long countAlternatingSubarrays(vector<int>& nums) {\n        // dp[i] := the number of alternating subarrays ending in index i\n        vector<long> dp(nums.size(), 1);\n\n        for (int i = 1; i < nums.size(); ++i)\n            if (nums[i] != nums[i - 1])\n                dp[i] += dp[i - 1];\n\n        return accumulate(dp.begin(), dp.end(), 0L);\n    }\n};\n"
    }
  },
  "3102": {
    "solution": {
      "ordered-set": ""
    }
  },
  "3103": {
    "solution": {
      "database": "WITH RECURSIVE\n  FebruaryTweets AS (\n    SELECT * FROM Tweets\n    WHERE YEAR(tweet_date) = 2024 AND MONTH(tweet_date) = 2\n  ),\n  HashtagToTweet AS (\n    SELECT\n      REGEXP_SUBSTR(tweet, '#[^\\s]+') AS hashtag,\n      REGEXP_REPLACE(tweet, '#[^\\s]+', '', 1, 1) AS tweet\n    FROM FebruaryTweets\n    UNION ALL\n    SELECT\n      REGEXP_SUBSTR(tweet, '#[^\\s]+') AS hashtag,\n      REGEXP_REPLACE(tweet, '#[^\\s]+', '', 1, 1) AS tweet\n    FROM HashtagToTweet\n    WHERE POSITION('#' IN tweet) > 0\n  )\nSELECT\n  hashtag,\n  COUNT(*) AS count\nFROM HashtagToTweet\nGROUP BY hashtag\nORDER BY count DESC, hashtag DESC\nLIMIT 3;"
    }
  },
  "3104": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3105": {
    "solution": {
      "array": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int longestMonotonicSubarray(vector<int>& nums) {\n        int n = nums.size();\n        if (n == 0) return 0;\n\n        int maxLen = 1; \n        int inc = 1, dec = 1; \n\n        for (int i = 1; i < n; ++i) {\n            if (nums[i] > nums[i-1]) {\n                inc++;\n                dec = 1; \n            } \n            else if (nums[i] < nums[i-1]) {\n                dec++;\n                inc = 1; \n            } \n            else {\n                inc = 1;\n                dec = 1;\n            }\n            \n            maxLen = max(maxLen, max(inc, dec));\n        }\n        \n        return maxLen;\n    }\n};\n"
    }
  },
  "3106": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    string getSmallestString(string s, int k) {\n        string result = s; \n\n        for (char& currentChar : result) {\n            if (k == 0)\n                break;\n            \n            const int distanceToA = min(currentChar - 'a', 'z' - currentChar + 1);\n\n            if (k >= distanceToA) {\n                k -= distanceToA;\n                currentChar = 'a';\n            } else {\n                // If we don't have enough steps to change to 'a', reduce the character as much as possible\n                currentChar -= k;\n                k = 0;\n            }\n        }\n\n        return result;  // Return the lexicographically smallest string\n    }\n};"
    }
  },
  "3107": {
    "solution": {
      "array": "class Solution {\npublic:\n    long long minOperationsToMakeMedianK(vector<int>& nums, int k) {\n        const int n = nums.size();\n        long ans = 0;\n\n        ranges::sort(nums);\n\n        for (int i = 0; i <= n / 2; ++i)\n            ans += max(0, nums[i] - k);\n\n        for (int i = n / 2; i < n; ++i)\n            ans += max(0, k - nums[i]);\n\n        return ans;\n    }\n};"
    }
  },
  "3108": {
    "solution": {
      "union-find": "class UnionFind {\npublic:\n    // 2^17 - 1 is the minimum number in the form 2^x - 1 > 10^5.\n    UnionFind(int n) : id(n), rank(n), weight(n, (1 << 17) - 1) {\n        iota(id.begin(), id.end(), 0);\n    }\n\n    void unionByRank(int u, int v, int w) {\n        const int i = find(u);\n        const int j = find(v);\n        const int newWeight = weight[i] & weight[j] & w;\n        weight[i] = newWeight;\n        weight[j] = newWeight;\n        if (i == j)\n            return;\n        if (rank[i] < rank[j]) {\n            id[i] = j;\n        } else if (rank[i] > rank[j]) {\n            id[j] = i;\n        } else {\n            id[i] = j;\n            ++rank[j];\n        }\n    }\n\n    int getMinCost(int u, int v) {\n        if (u == v)\n            return 0;\n        const int i = find(u);\n        const int j = find(v);\n        return i == j ? weight[i] : -1;\n    }\n\nprivate:\n    vector<int> id;\n    vector<int> rank;\n    vector<int> weight;\n\n    int find(int u) { return id[u] == u ? u : id[u] = find(id[u]); }\n};\n\nclass Solution {\npublic:\n    vector<int> minimumCost(int n, vector<vector<int>>& edges,\n                            vector<vector<int>>& query) {\n        vector<int> ans;\n        UnionFind uf(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            uf.unionByRank(u, v, w);\n        }\n\n        for (const vector<int>& q : query) {\n            const int u = q[0];\n            const int v = q[1];\n            ans.push_back(uf.getMinCost(u, v));\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "3109": {
    "solution": {
      "merge-sort": "class FenwickTree {\n  public FenwickTree(int n) {\n    sums = new int[n + 1];\n  }\n\n  public void add(int i, int delta) {\n    while (i < sums.length) {\n      sums[i] += delta;\n      i += lowbit(i);\n    }\n  }\n\n  public int get(int i) {\n    int sum = 0;\n    while (i > 0) {\n      sum += sums[i];\n      i -= lowbit(i);\n    }\n    return sum;\n  }\n\n  private int[] sums;\n\n  private static int lowbit(int i) {\n    return i & -i;\n  }\n}\n\nclass Solution {\n  public int getPermutationIndex(int[] perm) {\n  int kMod = 1_000_000_007;\n  int n = perm.length;\n    int ans = 0;\n    FenwickTree tree = new FenwickTree(n);\n    int[] fact = new int[n + 1]; \n    Arrays.fill(fact, 1);\n\n    for (int i = 2; i <= n; ++i)\n      fact[i] = (int) ((fact[i - 1] * (long) i) % kMod);\n\n    for (int i = 0; i < n; ++i) {\n    int num = perm[i];\n    int unusedNums = num - 1 - tree.get(num - 1);\n    int suffixLength = fact[n - 1 - i];\n      ans = (int) ((ans + unusedNums * (long) suffixLength) % kMod);\n      tree.add(num, 1);\n    }\n\n    return ans;\n  }\n}"
    }
  },
  "3110": {
    "solution": {
      "string": ""
    }
  },
  "3111": {
    "solution": {
      "array": "class Solution {\npublic:\n    int minRectanglesToCoverPoints(vector<vector<int>>& points, int w) {\n        int ans = 0;\n        int prevX = -w - 1;\n        vector<int> xs;\n\n        for (const vector<int>& point : points) {\n            const int x = point[0];\n            xs.push_back(x);\n        }\n\n        ranges::sort(xs);\n\n        for (const int x : xs)\n            if (x > prevX + w) {\n                ++ans;\n                prevX = x;\n            }\n\n        return ans;\n    }\n};"
    }
  },
  "3112": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    vector<int> minimumTime(int n, vector<vector<int>>& edges,\n                            vector<int>& disappear) {\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        return dijkstra(graph, 0, disappear);\n    }\n\nprivate:\n    vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src,\n                         const vector<int>& disappear) {\n        vector<int> dist(graph.size(), INT_MAX);\n\n        dist[src] = 0;\n        using P = pair<int, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < disappear[v] && d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.push({dist[v], v});\n                }\n        }\n\n        for (int& d : dist)\n            if (d == INT_MAX)\n                d = -1;\n\n        return dist;\n    }\n};"
    }
  },
  "3113": {
    "solution": {
      "monotonic-stack": "class Solution {\n    public long numberOfSubarrays(int[] nums) {\n        Deque<int[]> stack = new ArrayDeque<>();\n        long ans = 0;\n        int top = -1;\n\n        for (int num : nums) {\n            while (!stack.isEmpty() && stack.peek()[0] < num)\n                stack.pop();\n            if (stack.isEmpty() || stack.peek()[0] != num)\n                stack.push(new int[] { num, 0 });\n            ans += ++stack.peek()[1];\n        }\n\n        return ans;\n    }\n}"
    }
  },
  "3114": {
    "solution": {
      "enumeration": ""
    }
  },
  "3115": {
    "solution": {
      "number-theory": "class Solution {\npublic:\n    int maximumPrimeDifference(vector<int>& nums) {\n        constexpr int kMax = 100;\n        const vector<bool> isPrime = sieveEratosthenes(kMax + 1);\n        int minPrimeIndex = -1;\n        int maxPrimeIndex = -1;\n\n        for (int i = 0; i < nums.size(); ++i)\n            if (isPrime[nums[i]]) {\n                if (minPrimeIndex == -1)\n                    minPrimeIndex = i;\n                maxPrimeIndex = i;\n            }\n\n        return maxPrimeIndex - minPrimeIndex;\n    }\n\nprivate:\n    vector<bool> sieveEratosthenes(int n) {\n        vector<bool> isPrime(n, true);\n        isPrime[0] = false;\n        isPrime[1] = false;\n        for (int i = 2; i * i < n; ++i)\n            if (isPrime[i])\n                for (int j = i * i; j < n; j += i)\n                    isPrime[j] = false;\n        return isPrime;\n    }\n};"
    }
  },
  "3116": {
    "solution": {
      "combinatorics": ""
    }
  },
  "3117": {
    "solution": {
      "queue": ""
    }
  },
  "3118": {
    "solution": {
      "database": ""
    }
  },
  "3119": {
    "solution": {
      "greedy": ""
    }
  },
  "3120": {
    "solution": {
      "hash-table": "class Solution {\npublic:\n    int numberOfSpecialChars(string word) {\n        int ans = 0;\n        vector<bool> lower(26);\n        vector<bool> upper(26);\n\n        for (const char c : word)\n            if (islower(c))\n                lower[c - 'a'] = true;\n            else\n                upper[c - 'A'] = true;\n\n        for (int i = 0; i < 26; ++i)\n            if (lower[i] && upper[i])\n                ++ans;\n\n        return ans;\n    }\n};"
    }
  },
  "3121": {
    "solution": {
      "hash-table": ""
    }
  },
  "3122": {
    "solution": {
      "matrix": ""
    }
  },
  "3123": {
    "solution": {
      "shortest-path": "class Solution {\npublic:\n    vector<bool> findAnswer(int n, vector<vector<int>>& edges) {\n        vector<bool> ans;\n        vector<vector<pair<int, int>>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            graph[u].emplace_back(v, w);\n            graph[v].emplace_back(u, w);\n        }\n\n        const vector<int> from0 = dijkstra(graph, 0);\n        const vector<int> from1 = dijkstra(graph, n - 1);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            const int w = edge[2];\n            ans.push_back(from0[u] + w + from1[v] == from0[n - 1] ||\n                          from0[v] + w + from1[u] == from0[n - 1]);\n        }\n\n        return ans;\n    }\n\nprivate:\n    static constexpr int kMax = 1'000'000'000;\n\n    vector<int> dijkstra(const vector<vector<pair<int, int>>>& graph, int src) {\n        vector<int> dist(graph.size(), kMax);\n\n        dist[src] = 0;\n        using P = pair<int, int>; // (d, u)\n        priority_queue<P, vector<P>, greater<>> minHeap;\n        minHeap.emplace(dist[src], src);\n\n        while (!minHeap.empty()) {\n            const auto [d, u] = minHeap.top();\n            minHeap.pop();\n            if (d > dist[u])\n                continue;\n            for (const auto& [v, w] : graph[u])\n                if (d + w < dist[v]) {\n                    dist[v] = d + w;\n                    minHeap.emplace(dist[v], v);\n                }\n        }\n\n        return dist;\n    }\n};"
    }
  },
  "3124": {
    "solution": {
      "database": ""
    }
  },
  "3125": {
    "solution": {
      "greedy": ""
    }
  },
  "3126": {
    "solution": {
      "database": ""
    }
  },
  "3127": {
    "solution": {
      "matrix": "class Solution {\n  public boolean canMakeSquare(char[][] grid) {\n    for (int i = 0; i < 2; ++i)\n      for (int j = 0; j < 2; ++j) {\n        int black = 0;\n        int white = 0;\n        for (int x = 0; x < 2; ++x)\n          for (int y = 0; y < 2; ++y)\n            if (grid[i + x][j + y] == 'B')\n              ++black;\n            else\n              ++white;\n        if (black >= 3 || white >= 3)\n          return true;\n      }\n    return false;\n  }\n}"
    }
  },
  "3128": {
    "solution": {
      "math": "class Solution {\npublic:\n    long long numberOfRightTriangles(vector<vector<int>>& grid) {\n        int m = grid.size(), n = grid[0].size();\n        vector<int> rows(m);\n        vector<int> cols(n);\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                rows[i] += grid[i][j];\n                cols[j] += grid[i][j];\n            }\n        }\n        long long ans = 0;\n        for (int i = 0; i < m; ++i) {\n            for (int j = 0; j < n; ++j) {\n                if (grid[i][j] == 1) {\n                    ans += (rows[i] - 1) * (cols[j] - 1);\n                }\n            }\n        }\n        return ans;\n    }\n};\n"
    }
  },
  "3129": {
    "solution": {
      "dynamic-programming": "class Solution {\\npublic:\\n    int numberOfStableArrays(int zero, int one, int limit) {\\n        constexpr int kMod = 1'000'000'007;\\n        // dp[i][j][k] := the number of stable arrays, where the number of\\n        // ocurrences of 0 is i and the number of ocurrences of 1 is j and the\\n        // last number is k (0/1)\\n        vector<vector<vector<long>>> dp(\\n            zero + 1, vector<vector<long>>(one + 1, vector<long>(2)));\\n\\n        for (int i = 0; i <= min(zero, limit); ++i)\\n            dp[i][0][0] = 1;\\n\\n        for (int j = 0; j <= min(one, limit); ++j)\\n            dp[0][j][1] = 1;\\n\\n        for (int i = 1; i <= zero; ++i)\\n            for (int j = 1; j <= one; ++j) {\\n                dp[i][j][0] =\\n                    (dp[i - 1][j][0] + dp[i - 1][j][1] -\\n                     (i - limit < 1 ? 0 : dp[i - limit - 1][j][1]) + kMod) %\\n                    kMod;\\n                dp[i][j][1] =\\n                    (dp[i][j - 1][0] + dp[i][j - 1][1] -\\n                     (j - limit < 1 ? 0 : dp[i][j - limit - 1][0]) + kMod) %\\n                    kMod;\\n            }\\n\\n        return (dp[zero][one][0] + dp[zero][one][1]) % kMod;\\n    }\\n};"
    }
  },
  "3130": {
    "solution": {
      "dynamic-programming": "class Solution {\\npublic:\\n    int numberOfStableArrays(int zero, int one, int limit) {\\n        constexpr int kMod = 1'000'000'007;\\n        // dp[i][j][k] := the number of stable arrays, where the number of\\n        // ocurrences of 0 is i and the number of ocurrences of 1 is j and the\\n        // last number is k (0/1)\\n        vector<vector<vector<long>>> dp(\\n            zero + 1, vector<vector<long>>(one + 1, vector<long>(2)));\\n\\n        for (int i = 0; i <= min(zero, limit); ++i)\\n            dp[i][0][0] = 1;\\n\\n        for (int j = 0; j <= min(one, limit); ++j)\\n            dp[0][j][1] = 1;\\n\\n        for (int i = 1; i <= zero; ++i)\\n            for (int j = 1; j <= one; ++j) {\\n                dp[i][j][0] =\\n                    (dp[i - 1][j][0] + dp[i - 1][j][1] -\\n                     (i - limit < 1 ? 0 : dp[i - limit - 1][j][1]) + kMod) %\\n                    kMod;\\n                dp[i][j][1] =\\n                    (dp[i][j - 1][0] + dp[i][j - 1][1] -\\n                     (j - limit < 1 ? 0 : dp[i][j - limit - 1][0]) + kMod) %\\n                    kMod;\\n            }\\n\\n        return (dp[zero][one][0] + dp[zero][one][1]) % kMod;\\n    }\\n};"
    }
  },
  "3131": {
    "solution": {
      "array": ""
    }
  },
  "3132": {
    "solution": {
      "two-pointers": ""
    }
  },
  "3133": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3134": {
    "solution": {
      "sliding-window": "class Solution {\n    public int medianOfUniquenessArray(int[] nums) {\n        int n = nums.length;\n        long subarrayCount = n * (n + 1L) / 2;\n        long medianCount = (subarrayCount + 1) / 2;\n        int left = 1;\n        int right = n;\n\n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (subarrayWithAtMostackDistinct(nums, mid) >= medianCount)\n                right = mid;\n            else\n                left = mid + 1;\n        }\n\n        return left;\n    }\n\n    private long subarrayWithAtMostackDistinct(int[] nums, int k) {\n        long res = 0;\n        HashMap<Integer, Integer> count = new HashMap<>();\n\n        for (int left = 0, right = 0; right < nums.length; ++right) {\n            if (count.merge(nums[right], 1, Integer::sum) == 1)\n                --k;\n            while (k == -1)\n                if (count.merge(nums[left++], -1, Integer::sum) == 0)\n                    ++k;\n            res += right - left + 1;\n        }\n\n        return res;\n    }\n}"
    }
  },
  "3135": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minOperations(String initial, String target) {\n        int m = initial.length(), n = target.length();\n        int[][] dp = new int[m + 1][n + 1];\n        int mx = 0;\n        for (int i = 1; i <= m; ++i) {\n            for (int j = 1; j <= n; ++j) {\n                if (initial.charAt(i - 1) == target.charAt(j - 1)) {\n                    dp[i][j] = dp[i - 1][j - 1] + 1;\n                    mx = Math.max(mx, dp[i][j]);\n                }\n            }\n        }\n        return m + n - 2 * mx;\n    }\n}"
    }
  },
  "3136": {
    "solution": {
      "string": ""
    }
  },
  "3137": {
    "solution": {
      "counting": ""
    }
  },
  "3138": {
    "solution": {
      "counting": ""
    }
  },
  "3139": {
    "solution": {
      "enumeration": ""
    }
  },
  "3140": {
    "solution": {
      "database": ""
    }
  },
  "3141": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3142": {
    "solution": {
      "matrix": ""
    }
  },
  "3143": {
    "solution": {
      "sorting": ""
    }
  },
  "3144": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3145": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3146": {
    "solution": {
      "hash-table": ""
    }
  },
  "3147": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3148": {
    "solution": {
      "matrix": ""
    }
  },
  "3149": {
    "solution": {
      "bitmask": "class Solution {\npublic:\n    vector<int> findPermutation(vector<int>& nums) {\n        const int n = nums.size();\n        vector<vector<int>> mem(n, vector<int>(1 << n));\n        // bestPick[last][mask] := the best pick, where `last` is the last\n        // chosen number and `mask` is the bitmask of the chosen numbers\n        vector<vector<int>> bestPick(n, vector<int>(1 << n));\n\n        getScore(nums, 0, 1, bestPick, mem);\n        return construct(bestPick);\n    }\n\nprivate:\n    // Returns the minimum score, where `last` is the last chosen number and\n    // `mask` is the bitmask of the chosen numbers.\n    int getScore(const vector<int>& nums, int last, unsigned mask,\n                 vector<vector<int>>& bestPick, vector<vector<int>>& mem) {\n        if (popcount(mask) == nums.size())\n            return abs(last - nums[0]); // |perm[n - 1] - nums[perm[0]]|\n        if (mem[last][mask] > 0)\n            return mem[last][mask];\n\n        int minScore = INT_MAX;\n        for (int i = 1; i < nums.size(); ++i) {\n            if (mask >> i & 1)\n                continue;\n            const int nextMinScore =\n                abs(last - nums[i]) +\n                getScore(nums, i, mask | 1 << i, bestPick, mem);\n            if (nextMinScore < minScore) {\n                minScore = nextMinScore;\n                bestPick[last][mask] = i;\n            }\n        }\n\n        return mem[last][mask] = minScore;\n    }\n\n    vector<int> construct(const vector<vector<int>>& bestPick) {\n        vector<int> ans;\n        int last = 0;\n        int mask = 1;\n        for (int i = 0; i < bestPick.size(); ++i) {\n            ans.push_back(last);\n            last = bestPick[last][mask];\n            mask |= 1 << last;\n        }\n        return ans;\n    }\n};"
    }
  },
  "3150": {
    "solution": {
      "database": ""
    }
  },
  "3151": {
    "solution": {
      "array": ""
    }
  },
  "3152": {
    "solution": {
      "prefix-sum": ""
    }
  },
  "3153": {
    "solution": {
      "counting": ""
    }
  },
  "3154": {
    "solution": {
      "dynamic-programming": "",
      "memoization": "class Solution {\n    HashMap<String, Integer> memoizeMap = new HashMap<>();\n    int K;\n\n    public int waysToReachStair(int k) {\n\n        K = k;\n        int index = 1;\n        int jump = 0;\n        boolean canJumpBack = true;\n\n        return solve(index, jump, canJumpBack);\n    }\n\n    public int solve(int index, int jump, boolean canJumpBack) {\n\n        if (index > K + 1) {\n            return 0;\n        }\n\n        String str = String.valueOf(index) + \"_\" + String.valueOf(jump) + \"_\" + String.valueOf(canJumpBack);\n\n        if (memoizeMap.containsKey(str)) {\n\n            return memoizeMap.get(str);\n        }\n\n        int totalWays = 0;\n\n        if (index == K) {\n            totalWays++;\n        }\n\n        if (canJumpBack == true) {\n\n            totalWays += solve(index - 1, jump, false);\n        }\n        totalWays += solve(index + (int) Math.pow(2, jump), jump + 1, true);\n        memoizeMap.put(str, totalWays);\n\n        return totalWays;\n    }\n}"
    }
  },
  "3155": {
    "solution": {
      "math": ""
    }
  },
  "3156": {
    "solution": {
      "database": ""
    }
  },
  "3157": {
    "solution": {
      "breadth-first-search": "/**\n * Definition for a binary tree node.\n * struct TreeNode {\n *     int val;\n *     TreeNode *left;\n *     TreeNode *right;\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\n * };\n */\nclass Solution {\npublic:\n    int minimumLevel(TreeNode* root) {\n        queue<TreeNode*> q{{root}};\n        int ans = 0;\n        long long s = 1LL << 60;\n        for (int level = 1; q.size(); ++level) {\n            long long t = 0;\n            for (int m = q.size(); m; --m) {\n                TreeNode* node = q.front();\n                q.pop();\n                t += node->val;\n                if (node->left) {\n                    q.push(node->left);\n                }\n                if (node->right) {\n                    q.push(node->right);\n                }\n            }\n            if (s > t) {\n                s = t;\n                ans = level;\n            }\n        }\n        return ans;\n    }\n};"
    }
  },
  "3158": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3159": {
    "solution": {
      "hash-table": ""
    }
  },
  "3160": {
    "solution": {
      "hash-table": ""
    }
  },
  "3161": {
    "solution": {
      "array": ""
    }
  },
  "3162": {
    "solution": {
      "hash-table": ""
    }
  },
  "3163": {
    "solution": {
      "string": ""
    }
  },
  "3164": {
    "solution": {
      "hash-table": ""
    }
  },
  "3165": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3166": {
    "solution": {
      "database": ""
    }
  },
  "3167": {
    "solution": {
      "counting": "class Solution {\n public:\n  string betterCompression(string compressed) {\n    string ans;\n    vector<int> count(26);\n\n    for (int i = 0; i < compressed.length();) {\n      const char c = compressed[i++];\n      int freq = 0;\n      while (i < compressed.length() && isdigit(compressed[i]))\n        freq = freq * 10 + (compressed[i++] - '0');\n      count[c - 'a'] += freq;\n    }\n\n    for (char c = 'a'; c <= 'z'; ++c)\n      if (count[c - 'a'] > 0)\n        ans += c + to_string(count[c - 'a']);\n\n    return ans;\n  }\n};"
    }
  },
  "3168": {
    "solution": {
      "string": ""
    }
  },
  "3169": {
    "solution": {
      "array": "class Solution {\npublic:\n    int countDays(int days, vector<vector<int>>& meetings) {\n        int freeDays = 0;\n        int prevEnd = 0;\n\n        ranges::sort(meetings);\n\n        for (const vector<int>& meeting : meetings) {\n            const int start = meeting[0];\n            const int end = meeting[1];\n            if (start > prevEnd)\n                freeDays += start - prevEnd - 1;\n            prevEnd = max(prevEnd, end);\n        }\n\n        return freeDays + max(0, days - prevEnd);\n    }\n};"
    }
  },
  "3170": {
    "solution": {
      "string": "class Solution {\npublic:\n    string clearStars(string s) {\n        string ans = s;\n        vector<vector<int>> buckets(26);\n\n        for (int i = 0; i < s.length(); ++i)\n            if (s[i] == '*') {\n                ans[i] = ' ';\n                int j = 0;\n                while (buckets[j].empty())\n                    ++j;\n                ans[buckets[j].back()] = ' ', buckets[j].pop_back();\n            } else {\n                buckets[s[i] - 'a'].push_back(i);\n            }\n\n        std::erase(ans, ' ');\n        return ans;\n    }\n};"
    }
  },
  "3171": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3172": {
    "solution": {
      "database": ""
    }
  },
  "3173": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3174": {
    "solution": {
      "string": "class Solution {\npublic:\n    string clearDigits(string s) {\n        string ans;\n\n        for (const char c : s)\n            if (isdigit(c))\n                ans.pop_back();\n            else\n                ans += c;\n\n        return ans;\n    }\n};"
    }
  },
  "3175": {
    "solution": {
      "array": ""
    }
  },
  "3176": {
    "solution": {
      "dynamic-programming": "class Solution {\\npublic:\\n    int maximumLength(vector<int>& nums, int k) {\\n        // dp[count][num] := the maximum length of a good subsequence with at\\n        // most `count` indices where seq[i] != seq[i + 1] and it ends in `num`.\\n        vector<unordered_map<int, int>> dp(k + 1);\\n        // maxLen[count] := the maximum length of a good subsequence with\\n        // `count` indices where seq[i] != seq[i + 1]\\n        vector<int> maxLen(k + 1);\\n\\n        for (const int num : nums)\\n            for (int count = k; count >= 0; --count) {\\n                ++dp[count][num];\\n                if (count > 0)\\n                    dp[count][num] = max(dp[count][num], maxLen[count - 1] + 1);\\n                maxLen[count] = max(maxLen[count], dp[count][num]);\\n            }\\n\\n        return maxLen[k];\\n    }\\n};"
    }
  },
  "3177": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3178": {
    "solution": {
      "math": "class Solution {\npublic:\n    int numberOfChild(int n, int k) {\n        // the time for the ball to return to 0\n        const int roundTime = 2 * (n - 1);\n        const int pos = k % roundTime;\n        return pos < n ? pos : roundTime - pos;\n    }\n};\n"
    }
  },
  "3179": {
    "solution": {
      "array": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int valueAfterKSeconds(int n, int k) {\n        const int MOD = 1e9 + 7;\n        vector<int> dp(n, 1); \n        \n        for (int second = 0; second < k; ++second) {\n            for (int i = 1; i < n; ++i) {\n                dp[i] = (dp[i] + dp[i - 1]) % MOD; /\n            }\n        }\n        \n        return dp[n - 1]; \n    }\n};\n"
    }
  },
  "3180": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3181": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3182": {
    "solution": {
      "database": ""
    }
  },
  "3183": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3184": {
    "solution": {
      "counting": "class Solution {\n public:\n  int countCompleteDayPairs(vector<int>& hours) {\n    int ans = 0;\n    vector<int> count(24);\n\n    for (const int hour : hours) {\n      ans += count[(24 - hour % 24) % 24];\n      ++count[hour % 24];\n    }\n\n    return ans;\n  }\n};"
    }
  },
  "3185": {
    "solution": {
      "counting": ""
    }
  },
  "3186": {
    "solution": {
      "two-pointers": ""
    }
  },
  "3187": {
    "solution": {
      "binary-indexed-tree": "class FenwickTree {\npublic:\n    FenwickTree(int n) : sums(n + 1) {}\n\n    void add(int i, int delta) {\n        while (i < sums.size()) {\n            sums[i] += delta;\n            i += lowbit(i);\n        }\n    }\n\n    int get(int i) const {\n        int sum = 0;\n        while (i > 0) {\n            sum += sums[i];\n            i -= lowbit(i);\n        }\n        return sum;\n    }\n\nprivate:\n    vector<int> sums;\n\n    static inline int lowbit(int i) { return i & -i; }\n};\n\nclass Solution {\npublic:\n    vector<int> countOfPeaks(vector<int>& nums, vector<vector<int>>& queries) {\n        vector<int> ans;\n        vector<int> peak = getPeak(nums);\n        FenwickTree tree(peak.size());\n\n        for (int i = 0; i < peak.size(); ++i)\n            tree.add(i + 1, peak[i]);\n\n        auto update = [&](int i) {\n            const int newPeak = isPeak(nums, i);\n            if (newPeak != peak[i]) {\n                tree.add(i + 1, newPeak - peak[i]);\n                peak[i] = newPeak;\n            }\n        };\n\n        for (const vector<int>& query : queries)\n            if (query[0] == 1) {\n                const int l = query[1];\n                const int r = query[2];\n                ans.push_back(r - l < 2 ? 0 : tree.get(r) - tree.get(l + 1));\n            } else if (query[0] == 2) {\n                const int index = query[1];\n                const int val = query[2];\n                nums[index] = val;\n                update(index);\n                if (index > 0)\n                    update(index - 1);\n                if (index + 1 < nums.size())\n                    update(index + 1);\n            }\n\n        return ans;\n    }\n\nprivate:\n    vector<int> getPeak(const vector<int>& nums) {\n        vector<int> peak(nums.size());\n        for (int i = 1; i + 1 < nums.size(); ++i)\n            peak[i] = nums[i] > nums[i - 1] && nums[i] > nums[i + 1];\n        return peak;\n    }\n\n    bool isPeak(const vector<int>& nums, int i) {\n        return i > 0 && i + 1 < nums.size() && nums[i] > nums[i - 1] &&\n               nums[i] > nums[i + 1];\n    }\n};"
    }
  },
  "3188": {
    "solution": {
      "database": ""
    }
  },
  "3189": {
    "solution": {
      "greedy": ""
    }
  },
  "3190": {
    "solution": {
      "array": "#include <vector>\nusing namespace std;\n\nclass Solution {\npublic:\n    int minimumOperations(vector<int>& nums) {\n        int operations = 0;\n\n        for (int num : nums) {\n            int remainder = num % 3;\n\n            if (remainder == 1) {\n                operations += 1;  \n            } else if (remainder == 2) {\n                operations += 1;  \n            }\n        }\n\n        return operations;\n    }\n};\n"
    }
  },
  "3191": {
    "solution": {
      "sliding-window": "class Solution {\n    public int minOperations(int[] nums) {\n        int n = nums.length;\n        int ans = 0;\n\n        for (int i = 0; i + 2 < n; ++i)\n            if (nums[i] == 0) {\n                nums[i + 1] ^= 1;\n                nums[i + 2] ^= 1;\n                ++ans;\n            }\n\n        return nums[n - 1] == 0 || nums[n - 2] == 0 ? -1 : ans;\n    }\n}"
    }
  },
  "3192": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3193": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3194": {
    "solution": {
      "two-pointers": "import java.util.Arrays;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Solution {\n    public double minimumAverage(int[] nums) {\n        Arrays.sort(nums); \n        List<Double> averages = new ArrayList<>();\n        int left = 0, right = nums.length - 1;\n        \n        while (left < right) {\n            int min = nums[left++];\n            int max = nums[right--];\n            double avg = (min + max) / 2.0;\n            averages.add(avg);\n        }\n        \n        return averages.stream().mapToDouble(Double::doubleValue).min().orElse(0.0);\n    }\n}\n"
    }
  },
  "3195": {
    "solution": {
      "matrix": "class Solution {\n  public int minimumArea(int[][] grid) {\n    int x1 = Integer.MAX_VALUE;\n    int y1 = Integer.MAX_VALUE;\n    int x2 = 0;\n    int y2 = 0;\n\n    for (int i = 0; i < grid.length; ++i)\n      for (int j = 0; j < grid[0].length; ++j)\n        if (grid[i][j] == 1) {\n          x1 = Math.min(x1, i);\n          y1 = Math.min(y1, j);\n          x2 = Math.max(x2, i);\n          y2 = Math.max(y2, j);\n        }\n\n    return (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n}"
    }
  },
  "3196": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3197": {
    "solution": {
      "matrix": "class Solution {\n  public int minimumSum(int[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = m * n;\n\n    for (int i = 0; i < m; ++i) {\n      int top = minimumArea(grid, 0, i, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = Math.min(ans, top + /*left*/ minimumArea(grid, i + 1, m - 1, 0, j) +\n                                /*right*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int i = 0; i < m; ++i) {\n      int bottom = minimumArea(grid, i, m - 1, 0, n - 1);\n      for (int j = 0; j < n; ++j)\n        ans = Math.min(ans, bottom + /*left*/ minimumArea(grid, 0, i - 1, 0, j) +\n                                /*right*/ minimumArea(grid, 0, i - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      int left = minimumArea(grid, 0, m - 1, 0, j);\n      for (int i = 0; i < m; ++i)\n        ans = Math.min(ans, left + /*top*/ minimumArea(grid, 0, i, j + 1, n - 1) +\n                                /*bottom*/ minimumArea(grid, i + 1, m - 1, j + 1, n - 1));\n    }\n\n    for (int j = 0; j < n; ++j) {\n      int right = minimumArea(grid, 0, m - 1, j, n - 1);\n      for (int i = 0; i < m; ++i)\n        ans = Math.min(ans, right + /*top*/ minimumArea(grid, 0, i, 0, j - 1) +\n                                /*bottom*/ minimumArea(grid, i + 1, m - 1, 0, j - 1));\n    }\n\n    for (int i1 = 0; i1 < m; ++i1)\n      for (int i2 = i1 + 1; i2 < m; ++i2)\n        ans = Math.min(ans, /*top*/ minimumArea(grid, 0, i1, 0, n - 1) +\n                                /*middle*/ minimumArea(grid, i1 + 1, i2, 0, n - 1) +\n                                /*bottom*/ minimumArea(grid, i2 + 1, m - 1, 0, n - 1));\n\n    for (int j1 = 0; j1 < n; ++j1)\n      for (int j2 = j1 + 1; j2 < n; ++j2)\n        ans = Math.min(ans, /*left*/ minimumArea(grid, 0, m - 1, 0, j1) +\n                                /*middle*/ minimumArea(grid, 0, m - 1, j1 + 1, j2) +\n                                /*right*/ minimumArea(grid, 0, m - 1, j2 + 1, n - 1));\n\n    return ans;\n  }\n\n  private int minimumArea(int[][] grid, int si, int ei, int sj, int ej) {\n    int x1 = Integer.MAX_VALUE;\n    int y1 = Integer.MAX_VALUE;\n    int x2 = 0;\n    int y2 = 0;\n    for (int i = si; i <= ei; ++i)\n      for (int j = sj; j <= ej; ++j)\n        if (grid[i][j] == 1) {\n          x1 = Math.min(x1, i);\n          y1 = Math.min(y1, j);\n          x2 = Math.max(x2, i);\n          y2 = Math.max(y2, j);\n        }\n    return x1 == Integer.MAX_VALUE ? 0 : (x2 - x1 + 1) * (y2 - y1 + 1);\n  }\n}"
    }
  },
  "3198": {
    "solution": {
      "database": "SELECT\n  state,\n  GROUP_CONCAT(city ORDER BY city SEPARATOR ', ') AS cities\nFROM Cities\nGROUP BY 1\nORDER BY 1;"
    }
  },
  "3199": {
    "solution": {
      "bit-manipulation": "class Solution {\n public:\n  int tripletCount(vector<int>& a, vector<int>& b, vector<int>& c) {\n    const auto [evenA, oddA] = getEvenOddBitCount(a);\n    const auto [evenB, oddB] = getEvenOddBitCount(b);\n    const auto [evenC, oddC] = getEvenOddBitCount(c);\n    return evenA * oddB * oddC + oddA * evenB * oddC + oddA * oddB * evenC +\n           evenA * evenB * evenC;\n  }\n\n private:\n  pair<int, int> getEvenOddBitCount(const vector<int>& nums) {\n    int even = 0;\n    int odd = 0;\n    for (const unsigned num : nums)\n      if (popcount(num) % 2 == 0)\n        ++even;\n      else\n        ++odd;\n    return {even, odd};\n  }\n};"
    }
  },
  "3200": {
    "solution": {
      "enumeration": "class Solution {\npublic:\n    int maxHeightOfTriangle(int red, int blue) {\n        return max(maxHeight(red, blue), maxHeight(blue, red));\n    }\n\nprivate:\n    // Returns the maximum height of a triangle with the odd levels having `n1`\n    // balls and the even levels having `n2` balls.\n    int maxHeight(int n1, int n2) {\n        //             1 + 3 + ... + h <= n1\n        // ((1 + h) * (n + 1) / 2) / 2 <= n1\n        //                           h <= sqrt(4 * n1) - 1\n        const int oddHeight = sqrt(4 * n1) - 1;\n        //       2 + 4 + ... + h <= n2\n        // ((2 + h) * h / 2) / 2 <= n2\n        //                     h <= sqrt(4 * n2 + 1) - 1\n        const int evenHeight = sqrt(4 * n2 + 1) - 1;\n        // If the difference between the odd and even heights is >= 1, we can\n        // add an extra level to the minimum height.\n        return min(oddHeight, evenHeight) +\n               (abs(oddHeight - evenHeight) >= 1 ? 1 : 0);\n    }\n};"
    }
  },
  "3201": {
    "solution": {
      "dynamic-programming": "class Solution {\npublic:\n    int maximumLength(vector<int>& nums) {\n        // dp[i][j] := the maximum length of a valid subsequence, where the last\n        // number mod 2 equals i and the next desired number mod 2 equals j\n        vector<vector<int>> dp(2, vector<int>(2));\n\n        for (const int x : nums)\n            for (int y = 0; y < 2; ++y)\n                dp[x % 2][y] = dp[y][x % 2] + 1;\n\n        return accumulate(dp.begin(), dp.end(), 0,\n                          [](int acc, const vector<int>& row) {\n                              return max(acc, *max_element(row.begin(), row.end()));\n                          });\n    }\n};"
    }
  },
  "3202": {
    "solution": {
      "dynamic-programming": "class Solution {\\npublic:\\n    int maximumLength(vector<int>& nums, int k) {\\n        // dp[i][j] := the maximum length of a valid subsequence, where the last\\n        // number mod k equal to i and the next desired number mod k equal to j\\n        vector<vector<int>> dp(k, vector<int>(k));\\n\\n        for (const int x : nums)\\n            for (int y = 0; y < k; ++y)\\n                dp[x % k][y] = dp[y][x % k] + 1;\\n\\n        return accumulate(dp.begin(), dp.end(), 0,\\n                          [](int acc, const vector<int>& row) {\\n                              return max(acc, ranges::max(row));\\n                          });\\n    }\\n};"
    }
  },
  "3203": {
    "solution": {
      "tree": "class Solution {\npublic:\n    int minimumDiameterAfterMerge(vector<vector<int>>& edges1,\n                                  vector<vector<int>>& edges2) {\n        const int diameter1 = getDiameter(edges1);\n        const int diameter2 = getDiameter(edges2);\n        const int combinedDiameter =\n            (diameter1 + 1) / 2 + (diameter2 + 1) / 2 + 1;\n        return max({diameter1, diameter2, combinedDiameter});\n    }\n\nprivate:\n    int getDiameter(const vector<vector<int>>& edges) {\n        const int n = edges.size() + 1;\n        vector<vector<int>> graph(n);\n\n        for (const vector<int>& edge : edges) {\n            const int u = edge[0];\n            const int v = edge[1];\n            graph[u].push_back(v);\n            graph[v].push_back(u);\n        }\n\n        int maxDiameter = 0;\n        maxDepth(graph, 0, -1, maxDiameter);\n        return maxDiameter;\n    }\n\n    int maxDepth(const vector<vector<int>>& graph, int u, int prev,\n                 int& maxDiameter) {\n        int maxSubDepth1 = 0;\n        int maxSubDepth2 = 0;\n        for (const int v : graph[u]) {\n            if (v == prev)\n                continue;\n            const int maxSubDepth = maxDepth(graph, v, u, maxDiameter);\n            if (maxSubDepth > maxSubDepth1) {\n                maxSubDepth2 = maxSubDepth1;\n                maxSubDepth1 = maxSubDepth;\n            } else if (maxSubDepth > maxSubDepth2) {\n                maxSubDepth2 = maxSubDepth;\n            }\n        }\n        maxDiameter = max(maxDiameter, maxSubDepth1 + maxSubDepth2);\n        return 1 + maxSubDepth1;\n    }\n};"
    }
  },
  "3204": {
    "solution": {
      "database": ""
    }
  },
  "3205": {
    "solution": {
      "monotonic-stack": ""
    }
  },
  "3206": {
    "solution": {
      "linked-list": ""
    }
  },
  "3207": {
    "solution": {
      "greedy": "class Solution {\npublic:\n    long long maximumPoints(vector<int>& enemyEnergies, int currentEnergy) {\n        const int minEnergy = ranges::min(enemyEnergies);\n        return currentEnergy < minEnergy\n                   ? 0\n                   : (currentEnergy +\n                      accumulate(enemyEnergies.begin(), enemyEnergies.end(),\n                                 0LL) -\n                      minEnergy) /\n                         minEnergy;\n    }\n};"
    }
  },
  "3208": {
    "solution": {
      "array": ""
    }
  },
  "3209": {
    "solution": {
      "bit-manipulation": "using namespace std;\n\nclass Solution {\npublic:\n    long long countSubarrays(vector<int>& nums, int k) {\n        long long ans = 0;\n        unordered_map<int, int> prev;\n\n        for (const int num : nums) {\n            unordered_map<int, int> curr{{num, 1}};\n            for (const auto& [val, freq] : prev)\n                curr[val & num] += freq;\n            ans += curr.contains(k) ? curr[k] : 0;\n            prev = move(curr);\n        }\n\n        return ans;\n    }\n};"
    }
  },
  "3210": {
    "solution": {
      "string": "class Solution {\npublic:\n    string getEncryptedString(string s, int k) {\n        k %= s.length();\n        return s.substr(k) + s.substr(0, k);\n    }\n};"
    }
  },
  "3211": {
    "solution": {
      "recursion": ""
    }
  },
  "3212": {
    "solution": {
      "matrix": "class Solution {\n  public int numberOfSubmatrices(char[][] grid) {\n    int m = grid.length;\n    int n = grid[0].length;\n    int ans = 0;\n    // x[i][j] := the number of 'X' in grid[0..i)[0..j)\n    int[][] x = new int[m + 1][n + 1];\n    // y[i][j] := the number of 'Y' in grid[0..i)[0..j)\n    int[][] y = new int[m + 1][n + 1];\n\n    for (int i = 0; i < m; ++i)\n      for (int j = 0; j < n; ++j) {\n        x[i + 1][j + 1] = (grid[i][j] == 'X' ? 1 : 0) + x[i][j + 1] + x[i + 1][j] - x[i][j];\n        y[i + 1][j + 1] = (grid[i][j] == 'Y' ? 1 : 0) + y[i][j + 1] + y[i + 1][j] - y[i][j];\n        if (x[i + 1][j + 1] > 0 && x[i + 1][j + 1] == y[i + 1][j + 1])\n          ++ans;\n      }\n\n    return ans;\n  }\n}"
    }
  },
  "3213": {
    "solution": {
      "dynamic-programming": ""
    }
  },
  "3214": {
    "solution": {
      "database": "WITH\n  YearlySpends AS (\n    SELECT\n      product_id,\n      YEAR(transaction_date) AS year,\n      SUM(spend) AS spend\n    FROM user_transactions\n    GROUP BY 1, 2\n  )\nSELECT\n  CurrYear.year,\n  CurrYear.product_id,\n  CurrYear.spend AS curr_year_spend,\n  PrevYear.spend AS prev_year_spend,\n  ROUND(100 * (CurrYear.spend - PrevYear.spend) / PrevYear.spend, 2) AS yoy_rate\nFROM YearlySpends AS CurrYear\nLEFT JOIN YearlySpends AS PrevYear\n  ON (\n    CurrYear.product_id = PrevYear.product_id\n    AND CurrYear.year - 1 = PrevYear.year)\nORDER BY product_id, year;"
    }
  },
  "3215": {
    "solution": {
      "bit-manipulation": ""
    }
  },
  "3216": {
    "solution": {
      "string": "class Solution {\n    public String getSmallestString(String s) {\n        char[] chars = s.toCharArray();\n        for (int i = 1; i < chars.length; ++i) {\n            if (chars[i - 1] % 2 == chars[i] % 2 && chars[i - 1] > chars[i]) {\n                char temp = chars[i - 1];\n                chars[i - 1] = chars[i];\n                chars[i] = temp;\n                break;\n            }\n        }\n        return new String(chars);\n    }\n}"
    }
  },
  "3217": {
    "solution": {
      "linked-list": "import java.util.*;\n\nclass ListNode {\n    int val;\n    ListNode next;\n    ListNode() {}\n    ListNode(int val) { this.val = val; }\n    ListNode(int val, ListNode next) { this.val = val; this.next = next; }\n}\n\nclass Solution {\n    public ListNode modifiedList(List<Integer> nums, ListNode head) {\n        Set<Integer> set = new HashSet<>(nums);\n        ListNode dummy = new ListNode(0, head);\n        ListNode curr = dummy;\n\n        while (curr.next != null) {\n            if (set.contains(curr.next.val)) {\n                curr.next = curr.next.next;\n            } else {\n                curr = curr.next;\n            }\n        }\n\n        return dummy.next;\n    }\n}"
    }
  },
  "3218": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public int minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        int cost = 0;\n        int sumH = Arrays.stream(horizontalCut).sum();\n        int sumV = Arrays.stream(verticalCut).sum();\n\n        Arrays.sort(horizontalCut);\n        Arrays.sort(verticalCut);\n        int i = horizontalCut.length - 1, j = verticalCut.length - 1;\n\n        while (i >= 0 && j >= 0) {\n            if (horizontalCut[i] > verticalCut[j]) {\n                cost += horizontalCut[i--] + sumV;\n                sumH -= horizontalCut[i + 1];\n            } else {\n                cost += verticalCut[j--] + sumH;\n                sumV -= verticalCut[j + 1];\n            }\n        }\n\n        while (i >= 0) cost += horizontalCut[i--] + sumV;\n        while (j >= 0) cost += verticalCut[j--] + sumH;\n\n        return cost;\n    }\n}"
    }
  },
  "3219": {
    "solution": {
      "greedy": "import java.util.*;\n\nclass Solution {\n    public long minimumCost(int m, int n, int[] horizontalCut, int[] verticalCut) {\n        long cost = 0;\n        long sumH = 0, sumV = 0;\n        for (int h : horizontalCut) sumH += h;\n        for (int v : verticalCut) sumV += v;\n\n        Arrays.sort(horizontalCut);\n        Arrays.sort(verticalCut);\n        int i = horizontalCut.length - 1, j = verticalCut.length - 1;\n\n        while (i >= 0 && j >= 0) {\n            if (horizontalCut[i] > verticalCut[j]) {\n                cost += horizontalCut[i--] + sumV;\n                sumH -= horizontalCut[i + 1];\n            } else {\n                cost += verticalCut[j--] + sumH;\n                sumV -= verticalCut[j + 1];\n            }\n        }\n\n        while (i >= 0) cost += horizontalCut[i--] + sumV;\n        while (j >= 0) cost += verticalCut[j--] + sumH;\n\n        return cost;\n    }\n}"
    }
  }
}