{
  "biconnected_component": [
    "Biconnected components in a network are essentially the edges that, if removed, would disconnect the network. These are crucial for maintaining connectivity within the network.",
    "The problem typically involves representing a network as a graph, where nodes represent entities (such as computers or routers) and edges represent connections between these entities. The task is to find all the critical connections in the network, i.e., the edges whose removal would increase the number of connected components in the graph.",
    "One common approach to solving this problem is by using Tarjan's algorithm for finding articulation points and bridges in an undirected graph. In this algorithm, you perform a depth-first search (DFS) on the graph, keeping track of certain properties of the nodes and edges encountered during the traversal.",
    "Here's a high-level overview of the algorithm:",
    "1. Perform a DFS traversal of the graph, starting from any node\n2. During the traversal, maintain a timestamp for each node indicating when it was visited.\n3. Keep track of the lowest timestamp reachable from each node in the DFS traversal, which helps in identifying back edges.\n4. If you encounter a back edge (an edge to an ancestor in the DFS tree), update the lowest reachable timestamp for the corresponding node.\n5. If the lowest reachable timestamp of a child node is greater than or equal to the timestamp of the current node, then the edge connecting them is a critical connection.",
    "By applying Tarjan's algorithm, you can identify all the critical connections in the network efficiently. This algorithm typically runs in linear time complexity relative to the size of the graph.",
    "Once you've identified the critical connections, you can return them as a list of edges."
  ],
  "rejection_sampling": [
    "Rejection Sampling typically involves generating random samples that meet specific criteria or fit a desired distribution.",
    "LeetCode Problem: Implement Rand10() Using Rand7() (LeetCode 470)",
    "Problem Statement:",
    "You have a function rand7() that generates a random integer from 1 to 7. You need to write a function rand10() that generates a random integer from 1 to 10 uniformly using rand7().",
    "Rejection Sampling Approach:",
    "The key idea behind using rejection sampling for this problem is to transform the output of rand7() to achieve a uniform distribution over a different range (1 to 10) by generating a larger set of candidate numbers and then rejecting those that do not fit the desired criteria.",
    "Here's a step-by-step explanation of how rejection sampling can be applied to this problem:",
    "Generate a Candidate from rand7():",
    "1. Use rand7() twice to generate a number in the range 1 to 49. This can be done by interpreting the results of two rand7() calls as digits in a base-7 number.\n2. Specifically, compute the candidate number as (rand7() - 1) * 7 + rand7(). This generates a uniform integer in the range 1 to 49 because rand7() produces each number 1 through 7 with equal probability.",
    "Reject or Accept the Candidate:",
    "1. Since 49 is not a multiple of 10, not all numbers from 1 to 49 map evenly to the range 1 to 10. To maintain uniformity, we only accept numbers in the range 1 to 40 because 40 is the largest multiple of 10 less than 49.\n2. If the generated number falls within this range (1 to 40), we map it to the range 1 to 10 using modulo operation and return the result.\n3. If the number is outside this range (41 to 49), we reject it and repeat the process.",
    "Implementation in Python:",
    "Hereâ€™s how the rejection sampling algorithm can be implemented:",
    "import random",
    "def rand7():\n\treturn random.randint(1, 7)",
    "def rand10():\n\twhile True:\n\t\tnum = (rand7() - 1) * 7 + rand7()  # Generate a number in the range 1 to 49\n\t\tif num <= 40:  # Accept only if the number is in the range 1 to 40\n\t\t\treturn 1 + (num - 1) % 10  # Map to range 1 to 10",
    "print([rand10() for _ in range(10)])",
    "Detailed Explanation:",
    "Generate Candidate: (rand7() - 1) * 7 + rand7() produces a number from 1 to 49 because rand7() generates a number from 1 to 7, and multiplying by 7 shifts the range accordingly.",
    "Acceptance Condition: if num <= 40 ensures we only consider numbers that can be mapped uniformly to 1 to 10.",
    "Mapping: 1 + (num - 1) % 10 converts the accepted number to the desired range 1 to 10.",
    "By only accepting numbers from 1 to 40, we ensure that each number from 1 to 10 can be mapped equally using modulo operation. Numbers 41 to 49 are rejected to avoid bias.",
    "This example illustrates how rejection sampling can be used to transform a random number generator into a uniform random generator over a different range. The key steps are generating a candidate, checking if it falls within the acceptable range, and rejecting or accepting it based on that criterion. This ensures that the resulting distribution is uniform and meets the problem requirements."
  ],
  "radix_sort": [
    "For input list with negative integers, please refer to the 912. Sort an Array question",
    "Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by processing individual digits. It is particularly effective when the range of possible key values is not too large and is well-suited for sorting large lists of integers. Radix sort can be performed using either the least significant digit (LSD) or the most significant digit (MSD) method.\n\nHere's an overview of both methods:\n\nRadix sort can be a suitable choice for problems involving sorting large lists of integers or strings where the maximum value or length is not excessively large.\n\nLSD Radix Sort (Least Significant Digit)\n\n1. Initialize:\n   - Start with the least significant digit (rightmost).\n   \n2. Sorting:\n   - Group the numbers based on the current digit being considered.\n   - Sort the numbers within each group.\n\n3. Repeat:\n   - Move to the next significant digit to the left and repeat the process.\n   - Continue until the most significant digit is processed.\n\nMSD Radix Sort (Most Significant Digit)\n\n1. Initialize:\n   - Start with the most significant digit (leftmost).\n\n2. Sorting:\n   - Group the numbers based on the current digit being considered.\n   - Sort the numbers within each group.\n\n3. Recursion:\n   - Recursively sort the groups using the next significant digit to the right.\n   - Continue the process until the least significant digit is processed.\n\nExample of LSD Radix Sort\n\nConsider sorting the following list of integers:\n\n\n[170, 45, 75, 90, 802, 24, 2, 66]\n\n\nStep-by-Step Process\n\n1. Sort by the least significant digit (units place):\n\n   \n   [170, 90, 802, 2, 24, 45, 75, 66]\n   \n\n2. Sort by the next significant digit (tens place):\n\n   \n   [802, 2, 24, 45, 66, 170, 75, 90]\n   \n\n3. Sort by the most significant digit (hundreds place):\n\n   \n   [2, 24, 45, 66, 75, 90, 170, 802]\n   \n\nThe list is now sorted.\n\nAdvantages of Radix Sort\n\n- Efficiency: Radix sort can be faster than comparison-based sorting algorithms (like quicksort, mergesort) when the range of the keys (digits) is not too large.\n- Simplicity: The algorithm is simple and can be implemented easily for integer keys.\n- Stability: Radix sort is stable, meaning that it preserves the relative order of records with equal keys.\n\nDisadvantages of Radix Sort\n\n- Memory Usage: Radix sort requires additional memory for temporary storage during sorting.\n- Limited Applicability: Radix sort is not suitable for all types of data, particularly for floating-point numbers or strings with varying lengths.\n\nImplementation in Java\n\nHere's a Java implementation of LSD radix sort:\n\njava\nimport java.util.Arrays;\n\npublic class RadixSort {\n\n    public static void radixSort(int[] arr) {\n        int max = Arrays.stream(arr).max().getAsInt();\n        int exp = 1;\n        while (max / exp > 0) {\n            countingSort(arr, exp);\n            exp *= 10;\n        }\n    }\n\n    private static void countingSort(int[] arr, int exp) {\n        int n = arr.length;\n        int[] output = new int[n];\n        int[] count = new int[10];\n        \n        // Store the count of occurrences in count[]\n        for (int i = 0; i < n; i++) {\n            int index = (arr[i] / exp) % 10;\n            count[index]++;\n        }\n        \n        // Change count[i] so that it contains the actual position of this digit in output[], We transform this array so that each entry at index i contains the cumulative sum of counts up to i. This tells us the position where each digit should be placed in the output array. \n        for (int i = 1; i < 10; i++) {\n            count[i] += count[i - 1];\n        }\n        \n        // Build the output array\n        for (int i = n - 1; i >= 0; i--) {\n            int index = (arr[i] / exp) % 10;\n            output[count[index] - 1] = arr[i];\n            count[index]--;\n        }\n        \n        // Copy the output array to arr[], so that arr now contains sorted numbers according to the current digit\n        System.arraycopy(output, 0, arr, 0, n);\n    }\n\n    public static void main(String[] args) {\n        int[] arr = {170, 45, 75, 90, 802, 24, 2, 66};\n        radixSort(arr);\n        System.out.println(Arrays.toString(arr)); // Output: [2, 24, 45, 66, 75, 90, 170, 802]\n    }\n}\n\n\nExplanation\n\n1. Counting Sort Function:\n   - A helper function that sorts elements based on the current digit (specified by `exp`).\n\n2. Radix Sort Function:\n   - It repeatedly calls the counting sort for each digit, starting from the least significant digit to the most significant digit.\n   - `exp` is used to isolate each digit.\n\nRadix sort can be very efficient for specific types of data, especially when the number of digits (d) and the range of digits (k) are relatively small. It avoids the (O(n log n)) lower bound of comparison-based sorting algorithms, making it useful in certain scenarios.\n\nTime and Space Complexities\n\nTime Complexity:\n- Average Case: (O(d. (n + k)))\n- Worst Case: (O(d. (n + k)))\n  - Where (d) is the number of digits in the largest number (or length of the longest string), (n) is the number of elements, and (k) is the range of the digits (e.g., 0-9 for decimal numbers).\n\nSpace Complexity:\n- Auxiliary Space: (O(n + k))\n  - Additional space is used to create buckets for grouping digits or characters. The space complexity depends on the number of elements (n) and the range of digits (k).\n",
    "Time Complexity of Radix Sort\n\nThe time complexity of Radix Sort is determined by the following factors:\n- (d): The number of digits in the largest number (or the length of the longest string if sorting strings).\n- (n): The number of elements in the input array.\n- (k): The range of the digits (for decimal numbers, (k) is 10, since digits range from 0 to 9).\n\nThe overall time complexity is given by (O(d (n + k))).\n\n#Breaking it Down:\n1. Counting Sort Complexity: \n   - Counting Sort is used as a subroutine within Radix Sort.\n   - The time complexity of Counting Sort is (O(n + k)).\n\n2. Number of Passes (d):\n   - Radix Sort performs Counting Sort for each digit. If the maximum number in the array has (d) digits, then there will be (d) passes.\n   - Therefore, the total time complexity of Radix Sort is (O(d (n + k))).\n\nAnalysis:\n1. Average Case: (O(d (n + k)))\n   - This is the expected performance in general situations.\n\n2. Worst Case: (O(d (n + k)))\n   - This is also the performance in the worst-case scenario since Radix Sort does not have a different behavior for worst-case inputs as some other sorting algorithms might.\n\nComparing with Other Complexities:\n- Linear Time Complexity: (O(n))\n  - Radix Sort can achieve linear time complexity if (d) and (k) are constant values or do not grow with (n). For example, if all numbers have a fixed number of digits and the digit range is fixed.\n  \n- Quadratic Time Complexity: (O(n^2))\n  - Radix Sort does not reach (O(n^2)) time complexity unless (d) and (k) are very large in relation to (n), which is uncommon in practical scenarios. In typical uses, (d) and (k) are much smaller compared to (n), leading to a more efficient sort than (O(n^2)).\n\nBest Time Complexity:\nThe best time complexity of Radix Sort is (O(n)). This occurs under the following conditions:\n- (d) (number of digits) is a small constant.\n- (k) (range of digits) is also a small constant.\n\nIn such cases, the overall time complexity simplifies to (O(n)), since (d) and (k) do not grow with (n).\n\nSummary:\n- Average Case Time Complexity: (O(d (n + k)))\n- Worst Case Time Complexity: (O(d (n + k)))\n- Best Case Time Complexity: (O(n)) (when (d) and (k) are constants)\n\nRadix Sort is very efficient when the number of digits (d) and the range (k) are relatively small compared to the number of elements (n). It provides a linear time sorting alternative in such scenarios, outperforming typical comparison-based sorts like Quick Sort and Merge Sort which have (O(n log n)) time complexity."
  ],
  "eulerian_circuit": [
    "An Eulerian Circuit in a graph is a circuit that visits every edge exactly once and returns to the starting vertex. The necessary conditions for an Eulerian Circuit are:\n\n1. For undirected graphs: Every vertex must have an even degree, and all vertices with non-zero degree must be connected.\n2. For directed graphs: Every vertex must have equal in-degree and out-degree, and all vertices with non-zero degree must be strongly connected.\n\nHierholzerâ€™s algorithm is used to find an Eulerian path or circuit in a graph. In this problem, we adapt the algorithm to find an Eulerian path in a directed graph, where we must visit every edge (flight) exactly once. The algorithm involves traversing the graph and backtracking as necessary to cover all edges.\n\nA De Bruijn graph is a directed graph that represents overlapping subsequences of symbols from a larger sequence. It has applications in various fields, including computer science, bioinformatics, and cryptography.\n\nConsider a De Bruijn graph ðµ ( 2 , 3 ) B(2,3) over the binary alphabet {(0, 1)} {(0, 1)}. It consists of vertices representing all possible 3-bit binary sequences: 000, 001, 010, 011, 100, 101, 110, and 111. The edges are determined by the overlapping subsequences of length ð‘› âˆ’ 1 = 2.\n\nFor example, there is an edge from 001 to 010 because the last 2 bits of 001 match the first 2 bits of 010. Similarly, there is an edge from 110 to 101 because the last 2 bits of 110 match the first 2 bits of 101.\n\nJava Implementation Using Hierholzerâ€™s Algorithm\n\nExample\nHere is an example of how Hierholzerâ€™s algorithm works in a graph with an Eulerian circuit.\n\nGiven graph:\n\n    A - B\n    |     |\n    D - C\nAdjacency List:\n\nA: B, D\nB: A, C\nC: B, D\nD: A, C\n\nSteps:\n\nStart at vertex A.\nFollow an edge from A to B, removing the edge A-B.\nFollow an edge from B to C, removing the edge B-C.\nFollow an edge from C to D, removing the edge C-D.\nFollow an edge from D to A, removing the edge D-A.\nSince A has no more edges, backtrack, appending A to the path.\nContinue backtracking and appending each vertex to the path until the stack is empty.\nFinal Eulerian circuit path: A -> B -> C -> D -> A\n\nHereâ€™s how you can implement the solution in Java:\n\nGraph Representation: Use an adjacency list.\nDegree Calculation: Track in-degrees and out-degrees.\nCondition Checking: Ensure each vertex has equal in-degree and out-degree.\n\nHierholzerâ€™s Algorithm: To find the Eulerian Circuit.\n\nimport java.util.*;\n\npublic class EulerianCircuit {\n\n    // Function to perform Hierholzer's Algorithm\n    public static List<Integer> hierholzer(Map<Integer, LinkedList<Integer>> graph, int startNode) {\n        Stack<Integer> stack = new Stack<>();\n        List<Integer> circuit = new ArrayList<>();\n        stack.push(startNode);\n\n        while (!stack.isEmpty()) {\n            int u = stack.peek();\n            if (graph.get(u).size() > 0) {\n                int v = graph.get(u).removeFirst();\n                stack.push(v);\n            } else {\n                circuit.add(stack.pop());\n            }\n        }\n        Collections.reverse(circuit);\n        return circuit;\n    }\n\n    public static List<Integer> findEulerianCircuit(List<int[]> edges) {\n        Map<Integer, LinkedList<Integer>> adjList = new HashMap<>();\n        Map<Integer, Integer> inDegree = new HashMap<>();\n        Map<Integer, Integer> outDegree = new HashMap<>();\n\n        // Step 1: Build the graph from the edge list\n        for (int[] edge : edges) {\n            int u = edge[0], v = edge[1];\n            adjList.putIfAbsent(u, new LinkedList<>());\n            adjList.putIfAbsent(v, new LinkedList<>());\n            adjList.get(u).add(v);\n            outDegree.put(u, outDegree.getOrDefault(u, 0) + 1);\n            inDegree.put(v, inDegree.getOrDefault(v, 0) + 1);\n        }\n\n        // Step 2: Check the necessary conditions for an Eulerian Circuit\n        Integer startNode = null;\n        for (int node : adjList.keySet()) {\n            if (!outDegree.getOrDefault(node, 0).equals(inDegree.getOrDefault(node, 0))) {\n                return Collections.emptyList(); // No Eulerian Circuit exists\n            }\n            if (startNode == null) {\n                startNode = node;\n            }\n        }\n\n        // Step 3: Find Eulerian Circuit using Hierholzer's Algorithm\n        if (startNode == null) return Collections.emptyList();\n        return hierholzer(adjList, startNode);\n    }\n\n    public static void main(String[] args) {\n        List<int[]> edges = Arrays.asList(\n            new int[]{0, 1},\n            new int[]{1, 2},\n            new int[]{2, 0}\n        );\n\n        List<Integer> eulerianCircuit = findEulerianCircuit(edges);\n        System.out.println(eulerianCircuit);\n    }\n}\n\n\nExplanation\n\nGraph Representation:\n\nThe graph is represented using a Map<Integer, LinkedList<Integer>> where each key is a node, and the value is a list of nodes it is connected to.\ninDegree and outDegree maps keep track of the in-degree and out-degree of each node.\n\nBuilding the Graph:\n\nFor each edge (u, v), update the adjacency list, out-degree of u, and in-degree of v.\n\nChecking Conditions:\n\nEnsure each vertex has equal in-degree and out-degree. If any vertex fails this condition, an Eulerian Circuit does not exist.\nIdentify a start node for the algorithm.\n\nHierholzerâ€™s Algorithm:\n\nUse a stack to traverse the graph starting from the identified start node. Remove edges as they are traversed to avoid revisiting them.\nWhen you cannot continue from a node, backtrack and add the node to the circuit list.\nFinally, reverse the circuit list to get the correct order of traversal.\n\nMain Method:\n\nDemonstrates calling findEulerianCircuit with a sample edge list and prints the resulting Eulerian Circuit.\n"
  ],
  "strongly_connected component": [
    "In graph theory, a strongly connected component (SCC) of a directed graph is a maximal strongly connected subgraph. That is, a subgraph where there is a path from each vertex to every other vertex within the subgraph. SCCs are significant in various applications like understanding the structure of networks, optimizing compilers, and analyzing social networks.\n\nKosaraju's Algorithm in Java\n\nKosaraju's Algorithm consists of two main phases. Here is a detailed implementation in Java:\n\nimport java.util.*;\n    \npublic class KosarajuSCC {\n        \n        // First DFS to fill stack according to finishing times\n        private void fillOrder(int v, boolean[] visited, Stack<Integer> stack, List<List<Integer>> adj) {\n            visited[v] = true;\n            for (int neighbor : adj.get(v)) {\n                if (!visited[neighbor]) {\n                    fillOrder(neighbor, visited, stack, adj);\n                }\n            }\n            stack.push(v);\n        }\n    \n        // Transpose the graph\n        private List<List<Integer>> getTranspose(List<List<Integer>> adj, int V) {\n            List<List<Integer>> transpose = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                transpose.add(new ArrayList<>());\n            }\n            for (int v = 0; v < V; v++) {\n                for (int neighbor : adj.get(v)) {\n                    transpose.get(neighbor).add(v);\n                }\n            }\n            return transpose;\n        }\n    \n        // DFS for the transposed graph\n        private void DFSUtil(int v, boolean[] visited, List<List<Integer>> adj, List<Integer> component) {\n            visited[v] = true;\n            component.add(v);\n            for (int neighbor : adj.get(v)) {\n                if (!visited[neighbor]) {\n                    DFSUtil(neighbor, visited, adj, component);\n                }\n            }\n        }\n    \n        // Function to find and print all SCCs\n        public List<List<Integer>> stronglyConnectedComponents(int V, List<List<Integer>> adj) {\n            Stack<Integer> stack = new Stack<>();\n            boolean[] visited = new boolean[V];\n    \n            // Fill vertices in stack according to their finishing times\n            for (int i = 0; i < V; i++) {\n                if (!visited[i]) {\n                    fillOrder(i, visited, stack, adj);\n                }\n            }\n    \n            // Create a transposed graph\n            List<List<Integer>> transpose = getTranspose(adj, V);\n    \n            // Mark all vertices as not visited (for second DFS)\n            Arrays.fill(visited, false);\n            List<List<Integer>> sccs = new ArrayList<>();\n    \n            // Process all vertices in order defined by Stack\n            while (!stack.isEmpty()) {\n                int v = stack.pop();\n                if (!visited[v]) {\n                    List<Integer> component = new ArrayList<>();\n                    DFSUtil(v, visited, transpose, component);\n                    sccs.add(component);\n                }\n            }\n            return sccs;\n        }\n    \n        public static void main(String[] args) {\n            KosarajuSCC kosaraju = new KosarajuSCC();\n            int V = 5;\n            List<List<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                adj.add(new ArrayList<>());\n            }\n    \n            adj.get(0).add(2);\n            adj.get(2).add(1);\n            adj.get(1).add(0);\n            adj.get(0).add(3);\n            adj.get(3).add(4);\n    \n            List<List<Integer>> sccs = kosaraju.stronglyConnectedComponents(V, adj);\n            System.out.println('Strongly Connected Components:');\n            for (List<Integer> scc : sccs) {\n                System.out.println(scc);\n            }\n        }\n    }\n\nTarjan's Algorithm in Java\n\nTarjan's Algorithm is a single-pass DFS algorithm that uses low-link values to identify SCCs.\n\nimport java.util.*;\n    \npublic class TarjanSCC {\n        private int time = 0;\n        private List<List<Integer>> sccs = new ArrayList<>();\n    \n        // Function to perform DFS and find SCCs using Tarjan's Algorithm\n        private void tarjanDFS(int v, int[] disc, int[] low, Deque<Integer> stack, boolean[] inStack, List<List<Integer>> adj) {\n            disc[v] = low[v] = ++time;\n            stack.push(v);\n            inStack[v] = true;\n    \n            for (int neighbor : adj.get(v)) {\n                if (disc[neighbor] == -1) {\n                    tarjanDFS(neighbor, disc, low, stack, inStack, adj);\n                    low[v] = Math.min(low[v], low[neighbor]);\n                } else if (inStack[neighbor]) {\n                    low[v] = Math.min(low[v], disc[neighbor]);\n                }\n            }\n    \n            if (low[v] == disc[v]) {\n                List<Integer> component = new ArrayList<>();\n                int w;\n                do {\n                    w = stack.pop();\n                    inStack[w] = false;\n                    component.add(w);\n                } while (w != v);\n                sccs.add(component);\n            }\n        }\n    \n        public List<List<Integer>> stronglyConnectedComponents(int V, List<List<Integer>> adj) {\n            int[] disc = new int[V];\n            int[] low = new int[V];\n            boolean[] inStack = new boolean[V];\n            Deque<Integer> stack = new ArrayDeque<>();\n    \n            Arrays.fill(disc, -1);\n            Arrays.fill(low, -1);\n    \n            for (int i = 0; i < V; i++) {\n                if (disc[i] == -1) {\n                    tarjanDFS(i, disc, low, stack, inStack, adj);\n                }\n            }\n            return sccs;\n        }\n    \n        public static void main(String[] args) {\n            TarjanSCC tarjan = new TarjanSCC();\n            int V = 5;\n            List<List<Integer>> adj = new ArrayList<>();\n            for (int i = 0; i < V; i++) {\n                adj.add(new ArrayList<>());\n            }\n    \n            adj.get(0).add(2);\n            adj.get(2).add(1);\n            adj.get(1).add(0);\n            adj.get(0).add(3);\n            adj.get(3).add(4);\n    \n            List<List<Integer>> sccs = tarjan.stronglyConnectedComponents(V, adj);\n            System.out.println('Strongly Connected Components:');\n            for (List<Integer> scc : sccs) {\n                System.out.println(scc);\n            }\n        }\n    }\n\nExplanation\n\nKosaraju's Algorithm:\n\nFirst DFS:\nTraverse the graph and push vertices onto a stack when finished (finishing time).\n\nTranspose Graph:\nReverse the direction of all edges.\n\nSecond DFS:\nPop vertices from the stack and perform DFS on the transposed graph. Each DFS tree gives one SCC.\n\nTarjan's Algorithm:\n\nDFS with Low-Link Values:\nPerform a single DFS traversal. Maintain discovery times and low-link values.\n\nUse a stack to keep track of the current path in the DFS tree.\n\nIf a node's low-link value equals its discovery time, it is the root of an SCC.\n\nComparing the Algorithms:\n\nKosaraju's Algorithm:\nSimpler to understand and implement.\nRequires two passes of the graph (two DFS traversals).\nUses an auxiliary stack to record finishing order.\n\nTarjan's Algorithm:\nMore efficient with a single pass of the graph.\nUses low-link values to identify SCCs.\nSlightly more complex due to the management of low-link values and the stack.\n\nBoth algorithms have a time complexity of O(V+E) and are efficient for large graphs. The choice depends on the specific problem constraints and personal preference for implementation complexity."
  ],
  "reservoir_sampling": [
    "Reservoir Sampling is a clever algorithm used for selecting a random sample of k items from an unknown or large stream of items, where the total number of items is not known in advance. It ensures that each item in the stream has an equal probability of being selected in the final sample.\n\n    Here's a Python implementation of Reservoir Sampling for selecting k elements from a list:\n    \n    python\n    Copy code\n    import random\n    \n    def reservoir_sampling(stream, k):\n        reservoir = []\n        \n        # Fill the reservoir with the first k elements from the stream\n        for i in range(k):\n            reservoir.append(stream[i])\n        \n        # Iterate through the remaining elements in the stream\n        for i in range(k, len(stream)):\n            # Generate a random index j between 0 and i (inclusive)\n            j = random.randint(0, i)\n            \n            # If j is less than k, replace the jth element in the reservoir with the current element from the stream\n            if j < k:\n                reservoir[j] = stream[i]\n        \n        return reservoir\n    \n    # Example usage:\n    stream = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n    k = 3\n    sample = reservoir_sampling(stream, k)\n    print('Random sample of size', k, ':', sample)\n    In this implementation, we maintain a reservoir of size k. We fill the reservoir with the first k elements from the stream. Then, for each subsequent element in the stream, we generate a random index between 0 and the current index. If the random index is less than k, we replace the element at that index in the reservoir with the current element from the stream. This way, each element in the stream has an equal probability of being included in the final sample."
  ]
}
